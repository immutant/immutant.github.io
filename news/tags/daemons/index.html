<!DOCTYPE html>
<html>
  <head>
    <title>
      Immutant | News
    </title>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <link href="/stylesheets/styles.css" rel="stylesheet" type="text/css">
    <!--[if lt IE 9]>
      <script src="//html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]-->
    <link href="/news.atom" rel="alternate" type="application/atom+xml">
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
    <script src="/javascripts/dateformat.js" type="text/javascript"></script>
  </head>
  <body>
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">
            <img id="logo" src="/images/logos/logo-horizontal-centered.png">
          </a>
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <div class="nav-collapse">
            <ul class="nav">
              <li>
                <a href="/news/">News</a>
              </li>
              <li>
                <a href="/documentation/">Documentation</a>
              </li>
              <li>
                <a href="/community/">Community</a>
              </li>
              <li>
                <a href="/development/">Development</a>
              </li>
              <li class="dropdown">
                <a class="dropdown-toggle" data-toggle="dropdown" href="#">
                  Quick Links
                  <b class="caret"></b>
                </a>
                <ul class="dropdown-menu">
                  <li>
                    <a href="/documentation/current/apidoc/">2.x API Docs & Guides</a>
                  </li>
                  <li>
                    <a href="/builds/2x/">2.x Incremental Builds</a>
                  </li>
                  <li class="divider"></li>
                  <li>
                    <a href="/documentation/1.1.4/" rel="nofollow">1.x Manual</a>
                  </li>
                  <li>
                    <a href="/documentation/1.1.4/apidoc/" rel="nofollow">1.x API Docs</a>
                  </li>
                  <li>
                    <a href="/tutorials-1x/" rel="nofollow">1.x Tutorials</a>
                  </li>
                  <li>
                    <a href="/builds/" rel="nofollow">1.x Incremental Builds</a>
                  </li>
                  <li class="divider"></li>
                  <li>
                    <a href="/releases/">All Versioned Releases</a>
                  </li>
                  <li>
                    <a href="https://issues.jboss.org/browse/IMMUTANT">Issues</a>
                  </li>
                  <li>
                    <a href="http://webchat.freenode.net/?channels=immutant">#immutant on IRC</a>
                  </li>
                  <li>
                    <a href="https://github.com/immutant/immutant">Source</a>
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div id="wrapper">
      <div class="container" id="main-content">
        <div class="page-header">
          <h1>
            News
          </h1>
        </div>
        <div class="row">
          <div class="span8" id="main-column">
            <div class="post">
              <h2 class="title">
                <a href="/news/2013/09/23/websocket-sockjs-part-deux/">WebSockets and SockJS with Immutant and Vert.x - Part 2</a>
              </h2>
              <div class="byline">
                <div class="author">
                  Toby Crawley
                </div>
                <div class="date">
                  Monday, September 23, 2013
                </div>
              </div>
              <div class="tags">
                <a href="/news/tags/daemons/">daemons</a>
                <a href="/news/tags/vertx/">vertx</a>
                <a href="/news/tags/websockets/">websockets</a>
                <a href="/news/tags/sockjs/">sockjs</a>
                <a href="/news/tags/messaging/">messaging</a>
              </div>
              <div class="body">
                <p>This is a followup to our
                <a href="/news/2013/09/17/websocket-sockjs/">post last week on WebSockets with Vert.x</a>. If you haven&#39;t read
                it, you should do so now. In that post, we set up a simple echo
                service in <a href="http://vertx.io/">Vert.x</a> that bridged the Vert.x <a href="https://github.com/vert-x/mod-lang-clojure/blob/master/docs/core_manual_clojure.md#the-event-bus">EventBus</a> to the
                browser. But that echo service wasn&#39;t very useful - there was no way
                to process incoming messages outside of the daemon, and no way to send
                messages down to the browser client from other parts of the
                application. Today, we&#39;re going to look at bridging the EventBus over
                to <a href="/documentation/current/messaging.html">Immutant messaging</a>, allowing us to actually interact with the
                client from anywhere within our application.</p>
                
                <h2 id="Our_application" onclick="window.location = '#Our_application'">Our application</h2>
                
                <p>We&#39;ll be using the <a href="https://github.com/immutant/simple-immutant-vertx-demo">same application</a> we used in the last post, but
                will be working off of a <a href="https://github.com/immutant/simple-immutant-vertx-demo/tree/with-messaging">branch</a>.</p>
                
                <p>To get started, <a href="https://github.com/immutant/simple-immutant-vertx-demo">clone the app</a> and run it:<sup id="bfn1"><a href="#fn1">1</a></sup></p>
                
                <pre><code>cd /path/to/simple-immutant-vertx-demo&#x000A;git checkout with-messaging&#x000A;lein do immutant deploy, immutant run&#x000A;</code></pre>
                
                <p>Then browse to <a href="http://localhost:8080/">http://localhost:8080/</a>. You should see a UI that lets
                you send messages and see those messages echoed back, but now they
                come back in uppercase:</p>
                
                <p><img src="/images/news/sockjs2.png" alt="[UI activity]" class="bordered aligncenter"/></p>
                
                <h2 id="Let&#39;s_see_some_code!" onclick="window.location = '#Let&#39;s_see_some_code!'">Let&#39;s see some code!</h2>
                
                <p>Most of the application remains the same as it did before. But instead
                of just copying messages from the request address to the response
                address, we&#39;ve now wired our
                <a href="https://github.com/immutant/simple-immutant-vertx-demo/blob/with-messaging/src/demo/bridge.clj"><code>demo.bridge</code> namespace</a>
                to the Immutant messaging system. We now have functions that bridge
                EventBus addresses to Immutant messaging destinations, and vice-versa,
                and have modified the <code>init-bridge</code> function to map the appropriate
                addresses and destinations:</p>
                
                <pre class="syntax clojure">(ns demo.bridge&#x000A;  (:require [vertx.embed :as vembed :refer [with-vertx]]&#x000A;            [vertx.http :as http]&#x000A;            [vertx.http.sockjs :as sockjs]&#x000A;            [vertx.eventbus :as eb]&#x000A;            [immutant.messaging :as msg]))&#x000A;&#x000A;(defn dest->eventbus&#x000A;  "Sets up a bridge to copy messages from an Immutant messaging dest to a Vertx address."&#x000A;  [vertx dest address]&#x000A;  (msg/listen dest #(with-vertx vertx&#x000A;                      (eb/publish address %))))&#x000A;&#x000A;(defn eventbus->dest&#x000A;  "Sets up a bridge to copy messages from a Vertx address to an Immutant messaging dest."&#x000A;  [vertx address dest]&#x000A;  (with-vertx vertx&#x000A;    (eb/on-message address (partial msg/publish dest))))&#x000A;&#x000A;(defn- start-sockjs-bridge&#x000A;  "Creates a Vert.x http server, a sockjs server within that http&#x000A;  server, then installs an eventbus bridge in the sockjs server."&#x000A;  [vertx host port path]&#x000A;  (println (format "Starting SockJS bridge at http://%s:%s%s" host port path))&#x000A;  (with-vertx vertx&#x000A;    (let [server (http/server)]&#x000A;      (-> server&#x000A;          (sockjs/sockjs-server)&#x000A;          (sockjs/bridge {:prefix path} [{}] [{}]))&#x000A;      (http/listen server port host))))&#x000A;&#x000A;(defn init-bridge&#x000A;  "Initializes the embedded vertx instance, bridges to Immutant destinations, and starts the sockjs bridge."&#x000A;  [{:keys [request-dest response-dest]}]&#x000A;  (let [vertx (vembed/vertx)]&#x000A;    (eventbus->dest vertx "demo.request" request-dest)&#x000A;    (dest->eventbus vertx response-dest "demo.response")&#x000A;    {:vertx vertx&#x000A;     :server (start-sockjs-bridge vertx "localhost" 8081 "/eventbus")}))</pre>
                
                <p>Now that <code>demo.bridge</code> no longer echos, but instead expects something
                on the other end of the <code>request-dest</code>, we need something listening on
                the other end to do the work. We&#39;ve added this to the
                <a href="https://github.com/immutant/simple-immutant-vertx-demo/blob/with-messaging/src/demo/init.clj"><code>demo.init</code> namespace</a>,
                which is also where we define the request/response destination
                names. Our listener here just watches <code>queue.request</code>, uppercases each
                message, and publishes it to <code>topic.response</code>. Since we have bridged
                those same destinations in <code>demo.bridge</code>, we again have a completed
                circle from the client and back:</p>
                
                <pre class="syntax clojure">(ns demo.init&#x000A;  (:require [demo.web :as web]&#x000A;            [demo.daemon :as daemon]&#x000A;            [immutant.messaging :as msg]))&#x000A;&#x000A;(def config {:response-dest "topic.response"&#x000A;             :request-dest "queue.request"&#x000A;             :process-fn (memfn toUpperCase)})&#x000A;&#x000A;(defn init []&#x000A;  (let [{:keys [request-dest response-dest process-fn]} config]&#x000A;    (msg/start request-dest)&#x000A;    (msg/start response-dest)&#x000A;    (msg/listen request-dest&#x000A;                #(msg/publish response-dest (process-fn %))))&#x000A;  (web/start)&#x000A;  (daemon/start config))</pre>
                
                <h2 id="Touch_the_UI_from_anywhere" onclick="window.location = '#Touch_the_UI_from_anywhere'">Touch the UI from anywhere</h2>
                
                <p>Now that we&#39;ve bridged the EventBus to the Immutant messaging system,
                we can interact with our client UI from anywhere within our
                application. Just to beat the horse a bit more, let&#39;s do it from the
                repl. Connect to the <a href="/documentation/current/development.html#interactive">nREPL endpoint</a> in the application running on
                port <code>5309</code><sup id="bfn2"><a href="#fn2">2</a></sup> using your favorite client, then try sending messages
                directly to the response topic, or to the request queue to have them
                uppercased first:</p>
                
                <pre class="syntax clojure">user&gt; (require '[immutant.messaging :as msg])&#x000A;nil&#x000A;user&gt; (msg/publish "topic.response" "ahoyhoy")&#x000A;#&lt;HornetQTextMessage HornetQMessage[ID:8af51642-2478-11e3-9deb-25745b71356d]:PERSISTENT&gt;&#x000A;user&gt; (msg/publish "queue.request" "ahoyhoy")&#x000A;#&lt;HornetQTextMessage HornetQMessage[ID:90e4b5b8-2478-11e3-9deb-25745b71356d]:PERSISTENT&gt;&#x000A;user&gt; </pre>
                
                <p>You can also send structured messages:</p>
                
                <pre class="syntax clojure">user&gt; (msg/publish "topic.response" {:x :y})&#x000A;#&lt;HornetQTextMessage HornetQMessage[ID:e09bf794-2478-11e3-9deb-25745b71356d]:PERSISTENT&gt;</pre>
                
                <p>And see them all displayed in the client UI:</p>
                
                <p><img src="/images/news/sockjs3.png" alt="[repl UI activity]" class="bordered aligncenter"/></p>
                
                <h2 id="Fare_thee_well" onclick="window.location = '#Fare_thee_well'">Fare thee well</h2>
                
                <p>We&#39;ve extended our <a href="/news/2013/09/17/websocket-sockjs/">prior example</a> to make it actually useful, and
                maintained a separation of concerns within our application - code
                outside of the <code>demo.bridge</code> namespace has no knowledge of Vert.x, nor
                of the UI communication mechanism. We think this provides a compelling
                way to provide dynamic updates to the browser, but if you don&#39;t, or
                have any other questions, comments, or feedback, please
                <a href="/community/">get in touch</a>.</p>
                
                <hr>
                
                <ol>
                <li id="fn1" class="footnote"> <a href="#bfn1">^</a> This assumes you have a recent Immutant
                <a href="/install/">installed</a>.</li>
                <li id="fn2" class="footnote"> <a href="#bfn2">^</a> The demo application specifies <code>5309</code> as the <code>:nrepl-port</code> in
                its <code>project.clj</code>. If you have <code>:immutant {:nrepl-port some-port}</code>
                set in your <code>~/.lein/profiles.clj</code>, that will override <code>5309</code> and
                you&#39;ll need to connect to whatever port the endpoint is bound to.</li>
                </ol>
              </div>
              <div class="tail">
                 <a href="/news/2013/09/23/websocket-sockjs-part-deux/#disqus_thread">Comments</a>
                <hr>
              </div>
            </div>
            <div class="post">
              <h2 class="title">
                <a href="/news/2013/09/17/websocket-sockjs/">WebSockets and SockJS with Immutant and Vert.x</a>
              </h2>
              <div class="byline">
                <div class="author">
                  Toby Crawley
                </div>
                <div class="date">
                  Tuesday, September 17, 2013
                </div>
              </div>
              <div class="tags">
                <a href="/news/tags/daemons/">daemons</a>
                <a href="/news/tags/vertx/">vertx</a>
                <a href="/news/tags/websockets/">websockets</a>
                <a href="/news/tags/sockjs/">sockjs</a>
              </div>
              <div class="body">
                <p>Currently, Immutant doesn&#39;t provide any native WebSockets
                support. However, it is possible to use another WebSockets-capable
                server from within an <a href="/documentation/current/daemons.html">Immutant daemon</a>. There are quite a few
                well-known options in the Clojure ecosystem that we could use here,
                like <a href="https://github.com/ztellman/aleph">Aleph</a>, <a href="http://http-kit.org/">http-kit</a>, or raw <a href="http://www.eclipse.org/jetty/">Jetty</a> or <a href="http://netty.io/">Netty</a>. Instead, we&#39;re
                going to use a relative newcomer to the Clojure space: <a href="http://vertx.io/">Vert.x</a>.</p>
                
                <h2 id="What_is_Vert.x?" onclick="window.location = '#What_is_Vert.x?'">What is Vert.x?</h2>
                
                <p>Vert.x is an asynchronous polyglot application platform built on top
                of Netty that has been around for a while, but just recently gained
                <a href="https://github.com/vert-x/mod-lang-clojure">Clojure support</a>. It provides (among other things) its own message
                passing system (the <a href="https://github.com/vert-x/mod-lang-clojure/blob/master/docs/core_manual_clojure.md#the-event-bus">EventBus</a>), and provides a <a href="http://sockjs.org">SockJS</a>
                implementation that allows browser clients to participate as peers in
                the EventBus over WebSockets, falling back to other protocols as the
                browser and network topology dictate. SockJS and an EventBus that is
                bridged to the client abstracts away some of the complexity of
                managing dynamic updates to the browser, and is the primary reason
                we&#39;re using Vert.x over some of the alternatives mentioned above.</p>
                
                <p>Vert.x includes a <a href="https://github.com/eclipse/vert.x/blob/master/src/dist/client/vertxbus.js">javascript EventBus client</a> for use in client-side
                code that allows the browser to participate in the EventBus as a
                peer. The Vert.x Clojure language module includes a
                <a href="https://github.com/vert-x/mod-lang-clojure/blob/master/api/src/main/clojure/vertx/client/eventbus.cljs">ClojureScript wrapper</a> around that javascript client, which we&#39;ll use
                in a bit.</p>
                
                <h2 id="Our_application" onclick="window.location = '#Our_application'">Our application</h2>
                
                <p>To demonstrate using the Vert.x EventBus bridge from Immutant, we&#39;re
                going to look at a simple application that embeds<sup id="bfn1"><a href="#fn1">1</a></sup> Vert.x into an
                <a href="/documentation/current/daemons.html">Immutant daemon</a> to provide an echo service over the EventBus.</p>
                
                <p>To get started,
                <a href="https://github.com/immutant/simple-immutant-vertx-demo">clone the app</a>
                and run it:<sup id="bfn2"><a href="#fn2">2</a></sup></p>
                
                <pre><code>cd /path/to/simple-immutant-vertx-demo&#x000A;lein do immutant deploy, immutant run&#x000A;</code></pre>
                
                <p>Then browse to <a href="http://localhost:8080/">http://localhost:8080/</a>. You should see a UI that lets
                you send messages and see those messages echoed back. If you&#39;re using
                a browser with a Network console, you should be able to see the
                the SockJS WebSockets traffic, like so:</p>
                
                <p><img src="/images/news/sockjs.png" alt="[websocket activity]"/></p>
                
                <h2 id="Let&#39;s_see_some_code!" onclick="window.location = '#Let&#39;s_see_some_code!'">Let&#39;s see some code!</h2>
                
                <p>First, let&#39;s take a look at the <a href="https://github.com/immutant/simple-immutant-vertx-demo/blob/master/src-cljs/demo/client.cljs">ClojureScript client</a>. It&#39;s fairly
                standard <a href="https://github.com/ckirkendall/enfocus">Enfocus</a> transformations, with EventBus calls mixed in:</p>
                
                <pre class="syntax clojure">(ns demo.client&#x000A;  (:require [enfocus.core :as ef]&#x000A;            [enfocus.events :as events]&#x000A;            [vertx.client.eventbus :as eb]))&#x000A;&#x000A;(defn open-eventbus&#x000A;  "Opens a connection to the remote EventBus endpoint."&#x000A;  [& on-open]&#x000A;  (let [eb (eb/eventbus "http://localhost:8081/eventbus")]&#x000A;    (eb/on-open eb #(.log js/console "eventbus opened"))&#x000A;    (mapv #(eb/on-open eb (fn [] (% eb))) on-open)))&#x000A;&#x000A;(defn append-content&#x000A;  "Append the given content to the element specified by id"&#x000A;  [id content]&#x000A;  (ef/at id (ef/append (ef/html [:div content]))))&#x000A;&#x000A;(defn send-message&#x000A;  "Sends a message to the request address."&#x000A;  [eb message]&#x000A;  (eb/publish eb "demo.request" message))&#x000A;&#x000A;(defn attach-listeners&#x000A;  "Attaches listeners to both the the request and response addresses,&#x000A;   displaying the received messages in the appropriate divs."&#x000A;  [eb]&#x000A;  (eb/on-message eb "demo.request" (partial append-content "#sent"))&#x000A;  (eb/on-message eb "demo.response" (partial append-content "#rcvd")))&#x000A;&#x000A;(defn attach-send-click&#x000A;  "Attaches handler to send a message when the send button is clicked."&#x000A;  [eb]&#x000A;  (ef/at "#send-message"&#x000A;         (events/listen :click&#x000A;                        #(send-message eb (ef/from "#message"&#x000A;                                                   (ef/get-prop :value))))))&#x000A;(defn init []&#x000A;  (open-eventbus&#x000A;   attach-listeners&#x000A;   attach-send-click))&#x000A;&#x000A;(set! (.-onload js/window) init)</pre>
                
                <p>On the server side, we start up the SockJS EventBus bridge as an
                Immutant daemon in the
                <a href="https://github.com/immutant/simple-immutant-vertx-demo/blob/master/src/demo/daemon.clj"><code>demo.daemon</code> namespace</a>,
                and is standard Immutant daemon management code.  The functions that
                actually do the work of setting up the bridge are in the
                <a href="https://github.com/immutant/simple-immutant-vertx-demo/blob/master/src/demo/bridge.clj"><code>demo.bridge</code> namespace</a>:<sup id="bfn3"><a href="#fn3">3</a></sup></p>
                
                <pre class="syntax clojure">(ns demo.bridge&#x000A;  (:require [vertx.embed :as vembed :refer [with-vertx]]&#x000A;            [vertx.http :as http]&#x000A;            [vertx.http.sockjs :as sockjs]&#x000A;            [vertx.eventbus :as eb]))&#x000A;&#x000A;(defn- start-sockjs-bridge&#x000A;  "Creates a Vert.x http server, a sockjs server within that http&#x000A;  server, then installs an eventbus bridge in the sockjs server."&#x000A;  [vertx host port path]&#x000A;  (println (format "Starting SockJS bridge at http://%s:%s%s" host port path))&#x000A;  (with-vertx vertx&#x000A;    (let [server (http/server)]&#x000A;      (-> server&#x000A;          (sockjs/sockjs-server)&#x000A;          (sockjs/bridge {:prefix path} [{}] [{}]))&#x000A;      (http/listen server port host))))&#x000A;&#x000A;(defn init-bridge&#x000A;  "Initializes the embedded vertx instance, sets up our echo handler,&#x000A;   and starts the sockjs bridge."&#x000A;  []&#x000A;  (let [vertx (vembed/vertx)]&#x000A;    (with-vertx vertx&#x000A;      (eb/on-message "demo.request"&#x000A;                     (partial eb/publish "demo.response")))&#x000A;    {:vertx vertx&#x000A;     :server (start-sockjs-bridge vertx "localhost" 8081 "/eventbus")}))</pre>
                
                <h2 id="A_nice,_neat_little_package?" onclick="window.location = '#A_nice,_neat_little_package?'">A nice, neat little package?</h2>
                
                <p>So, what have we done here? We&#39;ve added dynamic updates over
                WebSockets (with fallback) to an Immutant application, without having
                to handle the minutiae of bi-directional communication over WebSockets
                and any fallback protocols. And since Vert.x allows the browser client
                to be an equal peer in the EventBus, we were able to use a similar API
                on the server and client.</p>
                
                <p>However, it&#39;s not all roses - there is a drawback to this approach:
                since Immutant doesn&#39;t support WebSockets natively, we can&#39;t share the
                http port and upgrade connections to WebSockets on request. This means
                that any WebSockets solution we run as a daemon has to bind to its own
                port.</p>
                
                <p>This has been an exploration of one way to add simple dynamic
                interaction to an Immutant application, but is certainly not the only
                way. If you try this approach with another WebSockets server, let us
                know how it goes.</p>
                
                <p>Watch for a post in the future that presents a more complex
                application that bridges the Vert.x EventBus to <a href="/documentation/current/messaging.html">Immutant messaging</a>
                destinations.</p>
                
                <p>If you have any questions, comments, or feedback, please
                <a href="/community/">get in touch</a>.</p>
                
                <hr>
                
                <ol>
                <li id="fn1" class="footnote"> <a href="#bfn1">^</a> Vert.x provides its own <a href="http://vertx.io/manual.html#using-vertx-from-the-command-line">application container</a>, but we&#39;re
                using it embedded, which is an advanced usage.</li>
                <li id="fn2" class="footnote"> <a href="#bfn2">^</a> This assumes you have a recent Immutant
                <a href="/install/">installed</a>.</li>
                <li id="fn3" class="footnote"> <a href="#bfn3">^</a> For this example, we&#39;re not securing the EventBus bridge at
                all. <a href="https://github.com/vert-x/mod-lang-clojure/blob/master/docs/core_manual_clojure.md#securing-the-bridge">Doing so</a> is probably a good idea.</li>
                </ol>
              </div>
              <div class="tail">
                 <a href="/news/2013/09/17/websocket-sockjs/#disqus_thread">Comments</a>
                <hr>
              </div>
            </div>
            <div class="post">
              <h2 class="title">
                <a href="/news/2013/08/20/openshift-clustering/">Clustering Immutants on OpenShift</a>
              </h2>
              <div class="byline">
                <div class="author">
                  Jim Crossley
                </div>
                <div class="date">
                  Tuesday, August 20, 2013
                </div>
              </div>
              <div class="tags">
                <a href="/news/tags/openshift/">openshift</a>
                <a href="/news/tags/tutorial/">tutorial</a>
                <a href="/news/tags/clustering/">clustering</a>
                <a href="/news/tags/messaging/">messaging</a>
                <a href="/news/tags/caching/">caching</a>
                <a href="/news/tags/daemons/">daemons</a>
                <a href="/news/tags/scheduled-jobs/">scheduled-jobs</a>
                <a href="/news/tags/ring/">ring</a>
              </div>
              <div class="body">
                <p>Lately I&#39;ve been spending a lot of time on <a href="http://openshift.com/">OpenShift</a>, building and
                testing a <a href="https://www.openshift.com/developers/technologies">cartridge</a> for Immutant that will properly form a cluster
                across multiple OpenShift <a href="https://www.openshift.com/products/pricing">gears</a>. In this post, I&#39;ll go through the steps
                of deploying a simple application that demonstrates all of the
                Immutant clustering features running on the three small gears you get
                for free on OpenShift.</p>
                
                <p>Here are the features we&#39;ll be demonstrating:</p>
                
                <ul>
                <li>Load-balanced message distribution with automatic peer discovery</li>
                <li>Replicated caching</li>
                <li>Highly-Available, long-running daemons</li>
                <li>HA scheduled jobs</li>
                <li>Web load balancing and session replication</li>
                </ul>
                
                <p>If you haven&#39;t already, go <a href="https://www.openshift.com/get-started#cli">set up an OpenShift account</a> and update
                your <code>rhc</code> gem to the latest version. I used 1.12.4 for this article.
                Below you&#39;ll see references to <em>$namespace</em> -- this corresponds to
                your OpenShift domain name, set by running <code>rhc setup</code>.</p>
                
                <p><em>Note</em>: If this is the first time you&#39;ve used OpenShift, you&#39;ll need
                to visit the <a href="https://openshift.redhat.com/app/console">console</a> and accept the usage agreement before running
                the <code>rhc</code> command.</p>
                
                <h2 id="Create_a_scaled_OpenShift_app" onclick="window.location = '#Create_a_scaled_OpenShift_app'">Create a scaled OpenShift app</h2>
                
                <p>The Immutant cartridge is available here:
                <a href="https://github.com/immutant/openshift-immutant-cart">https://github.com/immutant/openshift-immutant-cart</a>. As described in
                its README, we create our app using the following command:</p>
                
                <pre><code>rhc app-create -s demo https://raw.github.com/immutant/openshift-immutant-cart/master/metadata/manifest.yml&#x000A;</code></pre>
                
                <p>We&#39;re calling our app <em>demo</em> and we&#39;re passing the <code>-s</code> option to
                make our app scalable. Notice that we&#39;re passing a raw URL to the
                cartridge&#39;s <code>manifest.yml</code>.</p>
                
                <p>Small gears are pretty slow, but when <code>app-create</code> finally completes,
                you&#39;ll have a bare-bones, standard Leiningen application beneath the
                <code>demo/</code> directory. At this point, you might tail your app&#39;s logs or
                ssh into your gear:</p>
                
                <pre><code>rhc tail demo&#x000A;rhc ssh demo&#x000A;</code></pre>
                
                <p>The critical log file for Immutant on OpenShift is
                <code>immutant/logs/server.log</code>. Monitor this file until you eventually see
                the line, <em>Deployed &quot;your-clojure-application.clj&quot;</em>. Then point a
                browser at <a href="http://demo-$namespace.rhcloud.com">http://demo-$namespace.rhcloud.com</a> to see a simple
                welcome page.</p>
                
                <p>Now we&#39;ll put some meat on our bare-bones app!</p>
                
                <h2 id="Push_Me,_Pull_You" onclick="window.location = '#Push_Me,_Pull_You'">Push Me, Pull You</h2>
                
                <p>Typically, you will add the remote git repository for your real
                application to the local OpenShift repository you just created. We&#39;re
                going to use <a href="https://github.com/immutant/cluster-demo">https://github.com/immutant/cluster-demo</a> as our &quot;real&quot;
                application.</p>
                
                <pre><code>git remote add upstream -m master git@github.com:immutant/cluster-demo.git&#x000A;</code></pre>
                
                <p>Deployment of your app to OpenShift amounts to pulling from your real
                repository and pushing to OpenShift&#39;s.</p>
                
                <pre><code>git pull -s recursive -X theirs upstream master&#x000A;git push&#x000A;</code></pre>
                
                <p>While waiting for that to complete, run <code>rhc tail demo</code> in another
                shell to monitor your log. This time, the <em>Deployed
                &quot;your-clojure-application.clj&quot;</em> message is going to scroll off the
                screen as the cluster-demo app starts logging its output. Eventually,
                the app should settle into a steady state looking something like this:</p>
                
                <p><img src="/images/news/demo-log.png"/></p>
                
                <h2 id="The_cluster-demo_app" onclick="window.location = '#The_cluster-demo_app'">The cluster-demo app</h2>
                
                <p>If you can ignore the inconsistent thread identifiers in the above
                output, you&#39;ll notice there are exactly four types of messages:
                <strong>send</strong>, <strong>recv</strong>, <strong>web</strong>, and <strong>job</strong>. Noting the timestamps in the
                left column, a <strong>send</strong> is logged every 5 seconds, as is its
                corresponding <strong>recv</strong>, a <strong>web</strong> logged every 2 seconds, and a
                <strong>job</strong> every 20 seconds.</p>
                
                <p>The cluster-demo app is comprised of the following:</p>
                
                <ul>
                <li>A message queue named <em>/queue/msg</em></li>
                <li>A distributed cache named <em>counters</em></li>
                <li>A listener for the queue that prints the received message and the
                current contents of the cache</li>
                <li>An HA daemon named <em>counter</em> that queues a cached value and
                increments it every 5 seconds</li>
                <li>An HA scheduled job named <em>ajob</em> that increments another counter in
                the cache every 20 seconds</li>
                <li>A web request handler mounted at <strong>/</strong> that logs its <code>:path-info</code>
                and returns the current values of the two cached counters</li>
                <li>Another request handler mounted at <strong>/count</strong> that increments a
                counter in the user&#39;s web session.</li>
                </ul>
                
                <p>All the code (~60 lines) is <a href="https://github.com/immutant/cluster-demo/blob/master/src/immutant/init.clj">contained in a single file</a>.</p>
                
                <h2 id="Programming_is_hard,_let&#39;s_build_a_cluster!" onclick="window.location = '#Programming_is_hard,_let&#39;s_build_a_cluster!'">Programming is hard, let&#39;s build a cluster!</h2>
                
                <p>Now we&#39;re ready to form a cluster by adding a gear to our app:</p>
                
                <pre><code>rhc scale-cartridge immutant -a demo 2&#x000A;</code></pre>
                
                <p>Again, this will take a few minutes, and it may return an error even
                though the operation actually succeeded. You can run the following to
                see the definitive state of your gears:</p>
                
                <pre><code>rhc show-app --gears&#x000A;</code></pre>
                
                <p>This also gives you the SSH URLs for your two gears. Fire up two
                shells and ssh into each of your gears using those SSH URLs. Then
                tail the log on each:</p>
                
                <pre><code>tail -f immutant/logs/server.log&#x000A;</code></pre>
                
                <p>When the dust settles, you&#39;ll eventually see the gears discover each
                other, and you should see both gears logging <strong>recv</strong> messages, one
                getting the even numbers and one getting the odd. This is your
                automatic load-balanced message distribution. </p>
                
                <p>Note also that the counters cache logged in the <strong>recv</strong> message is
                correct on both gears, even though it&#39;s only being updated by one.
                This is our cache replication at work.</p>
                
                <h2 id="Let&#39;s_break_stuff!" onclick="window.location = '#Let&#39;s_break_stuff!'">Let&#39;s break stuff!</h2>
                
                <p>And see how robust our cluster is.</p>
                
                <h3 id="High_Availability_Daemons_and_Jobs" onclick="window.location = '#High_Availability_Daemons_and_Jobs'">High Availability Daemons and Jobs</h3>
                
                <p>Of course, the <strong>send</strong> and <strong>job</strong> log entries should still only
                appear on our original gear, because those are our HA singletons. If
                that gear crashes, our daemon and job should migrate to the other
                gear. While logged into the gear running your singletons, run this:</p>
                
                <pre><code>immutant/bin/control stop&#x000A;</code></pre>
                
                <p>And watch the other gear&#39;s log to verify the daemon and job pick up
                right where they left off, fetching their counters from the replicated
                cache. That gear should be consuming all the queued messages, too. Now
                start the original gear back up:</p>
                
                <pre><code>immutant/bin/control start&#x000A;</code></pre>
                
                <p>Eventually, it&#39;ll start receiving half the messages again.</p>
                
                <h3 id="Web" onclick="window.location = '#Web'">Web</h3>
                
                <p>You may be wondering about those <strong>web</strong> entries showing up in both
                logs. They are &quot;health check&quot; requests from the <a href="https://www.openshift.com/blogs/how-haproxy-scales-openshift-apps">HAProxy</a> web load
                balancer, automatically installed on your primary gear. You can always
                check the state of your cluster from HAProxy&#39;s perspective by visiting
                <a href="http://demo-$namespace.rhcloud.com/haproxy-status">http://demo-$namespace.rhcloud.com/haproxy-status</a>. If you see that
                page without intending to, it means something about your app is
                broken, so check <code>immutant/logs/server.log</code> for errors and make sure
                your app responds to a request for the root context, i.e. &quot;/&quot;.</p>
                
                <p>Let&#39;s try some web stuff. Use curl to hit your app while observing the
                logs on both gears:</p>
                
                <pre><code>curl http://demo-$namespace.rhcloud.com/xxxxxxxxxxxxxxxxxxxx&#x000A;curl http://demo-$namespace.rhcloud.com/yyyyyyyyyyyyyyyyyyyy&#x000A;curl http://demo-$namespace.rhcloud.com/zzzzzzzzzzzzzzzzzzzz&#x000A;</code></pre>
                
                <p>Use an obnoxious path to distinguish your request from the health
                checks. Repeat the command a few times to observe the gears taking
                turns responding to your request. Now try it in a browser, and you&#39;ll
                see the same gear handling your request every time you reload. This is
                because HAProxy is setting cookies in the response to enable session
                affinity, which your browser is probably sending back. And <code>curl</code>
                didn&#39;t.</p>
                
                <p>Speaking of session affinity, let&#39;s break that while we&#39;re at it, by
                invoking our other web handler, the one that increments a counter in
                the user&#39;s web session: <a href="http://demo-$namespace.rhcloud.com/count">http://demo-$namespace.rhcloud.com/count</a></p>
                
                <p>You should see the counter increment each time you reload your
                browser. (You&#39;ll need to give <code>curl</code> a cookie store to see it respond
                with anything other than &quot;1 times&quot;)</p>
                
                <p>Pay attention to which gear is responding to the <em>/count</em> request. Now
                stop that gear like you did before. When you reload your browser, you
                should see the other gear return the expected value. This is the
                automatic session replication provided by
                <code>immutant.web.session/servlet-store</code>.</p>
                
                <p>Don&#39;t forget to restart that gear.</p>
                
                <h2 id="The_Hat_Trick" onclick="window.location = '#The_Hat_Trick'">The Hat Trick</h2>
                
                <p>Hey, OpenShift is giving us 3 free gears, we may as well use &#39;em all,
                right?</p>
                
                <pre><code>rhc scale-cartridge immutant -a demo 3&#x000A;</code></pre>
                
                <p>When the third one finally comes up, there are a couple of things you
                may notice:</p>
                
                <ul>
                <li>The health checks will disappear from the primary gear as HAProxy
                takes it out of the rotation when 2 or more other gears are
                available, ostensibly to mitigate the <a href="http://en.wikipedia.org/wiki/Observer_effect_(information_technology)">observer effect</a> of the
                health checks.</li>
                <li>Each cache key will only show up in the <strong>recv</strong> log messages on 2
                of the 3 gears. This is because Immutant caches default to
                Infinispan&#39;s <code>:distributed</code> replication mode in a cluster. This
                enables Infinispan clusters to achieve &quot;linear scalability&quot; as
                entries are copied to a fixed number of cluster nodes (default 2)
                regardless of the cluster size. Distribution uses a consistent
                hashing algorithm to determine which nodes will store a given entry.</li>
                </ul>
                
                <h2 id="Now_what?" onclick="window.location = '#Now_what?'">Now what?</h2>
                
                <p>Well, that was a lot to cover. I doubt many apps will use all these
                features, but I think it&#39;s nice to have a free playground on which to
                try them out, even with the resources as constrained as they are on a
                small gear.</p>
                
                <p>Regardless, I&#39;m pretty happy that Immutant is finally feature-complete
                on OpenShift now. :-)</p>
                
                <p>Of course, I had a lot of help getting things to this point. Many
                folks on the OpenShift and JBoss teams were generous with their
                expertise, but the &quot;three B&#39;s&quot; deserve special mention:
                <a href="https://twitter.com/bbrowning">Ben</a>,
                <a href="http://belaban.blogspot.com/">Bela</a>, and
                <a href="http://www.billdecoste.net/">Bill</a>.</p>
                
                <p>Thanks!</p>
              </div>
              <div class="tail">
                 <a href="/news/2013/08/20/openshift-clustering/#disqus_thread">Comments</a>
                <hr>
              </div>
            </div>
            <div class="post">
              <h2 class="title">
                <a href="/news/2012/02/16/clustering/">Getting Started: Simulated Clustering</a>
              </h2>
              <div class="byline">
                <div class="author">
                  Jim Crossley
                </div>
                <div class="date">
                  Thursday, February 16, 2012
                </div>
              </div>
              <div class="tags">
                <a href="/news/tags/clustering/">clustering</a>
                <a href="/news/tags/tutorial/">tutorial</a>
                <a href="/news/tags/getting-started/">getting-started</a>
                <a href="/news/tags/daemons/">daemons</a>
              </div>
              <div class="body">
                <p>For this installment of our <a href="/news/tags/getting-started/">getting started series</a>
                we&#39;ll experiment a bit with clustering, one of the primary benefits
                provided by the <a href="http://www.jboss.org/jbossas">JBoss AS7</a> application server, upon which
                Immutant is built. AS7 features a brand new way of configuring and
                managing clusters called <em>Domain Mode</em>, but unfortunately its
                documentation is still evolving. If you insist, try <a href="http://xebee.xebia.in/2011/11/01/all-about-managed-domain-jboss-as7/">this</a> or
                possibly <a href="https://docs.jboss.org/author/display/AS71/AS7+Cluster+Howto">this</a>.</p>
                
                <p>We&#39;ll save <em>Domain Mode</em> with respect to Immutant for a future
                post. It&#39;s not required for clustering, but it is an option for easier
                cluster management. In this post, we&#39;ll reveal a trick to simulate a
                cluster on your development box so that you can experiment with
                Immutant clustering features, which we should probably enumerate now:</p>
                
                <ul>
                <li>Automatic load balancing and failover of message consumers</li>
                <li>HTTP session replication</li>
                <li>Fine-grained, dynamic web-app configuration and control via
                <a href="http://www.jboss.org/mod_cluster">mod_cluster</a></li>
                <li>Efficiently-replicated distributed caching via <a href="http://infinispan.org">Infinispan</a></li>
                <li>Singleton scheduled jobs</li>
                <li>Automatic failover of singleton daemons</li>
                </ul>
                
                <h2 id="Running_an_Immutant" onclick="window.location = '#Running_an_Immutant'">Running an Immutant</h2>
                
                <p>As you know, <a href="/news/2011/12/21/installing-redux/">installing</a> Immutant is simple:</p>
                
                <pre><code>$ lein plugin install lein-immutant 0.4.1&#x000A;$ lein immutant install&#x000A;</code></pre>
                
                <p>And running an Immutant is, too:</p>
                
                <pre><code>$ lein immutant run&#x000A;</code></pre>
                
                <p>By passing the <code>--clustered</code> option, you configure the Immutant as a
                node that will discover other nodes (via multicast, by default) to
                form a cluster:</p>
                
                <pre><code>$ lein immutant run --clustered&#x000A;</code></pre>
                
                <p>From the first line of its output, you can see what that command is
                really running:</p>
                
                <pre><code>$ $JBOSS_HOME/bin/standalone.sh --server-config=standalone-ha.xml&#x000A;</code></pre>
                
                <p>Any options passed to <code>lein immutant run</code> are forwarded to
                <code>standalone.sh</code>, so run the following to see what those are:</p>
                
                <pre><code>$ lein immutant run --help&#x000A;</code></pre>
                
                <h2 id="Simulating_a_Cluster" onclick="window.location = '#Simulating_a_Cluster'">Simulating a Cluster</h2>
                
                <h3 id="TL;DR" onclick="window.location = '#TL;DR'">TL;DR</h3>
                
                <p>To run two immutant instances on a single machine, fire up two shells and...</p>
                
                <p>In one shell, run:</p>
                
                <pre><code>$ lein immutant run --clustered -Djboss.node.name=one -Djboss.server.data.dir=/tmp/one&#x000A;</code></pre>
                
                <p>In another shell, run:</p>
                
                <pre><code>$ lein immutant run --clustered -Djboss.node.name=two -Djboss.server.data.dir=/tmp/two -Djboss.socket.binding.port-offset=100&#x000A;</code></pre>
                
                <p>Boom, you&#39;re a cluster!</p>
                
                <h3 id="Details" onclick="window.location = '#Details'">Details</h3>
                
                <p>Each cluster node requires a unique name, which is usually derived
                from the hostname, but since our Immutants are on the same host, we
                set the <code>jboss.node.name</code> property uniquely.</p>
                
                <p>Each Immutant will attempt to persist its runtime state to the same
                files. Hijinks will ensue. We prevent said hijinks by setting the
                <code>jboss.server.data.dir</code> property uniquely.</p>
                
                <p>JBoss listens for various types of connections on a few ports. One
                obvious solution to the potential conflicts is to bind each Immutant
                to a different interface, which we could specify using the <code>-b</code>
                option. </p>
                
                <p>But rather than go through a platform-specific example of creating an
                IP alias, I&#39;m going to take advantage of another JBoss feature: the
                <code>jboss.socket.binding.port-offset</code> property will cause each default
                port number to be incremented by a specified amount.</p>
                
                <p>So for the second Immutant, I set the offset to 100, resulting in its
                HTTP service, for example, listening on 8180 instead of the default
                8080, on which the first Immutant is listening.</p>
                
                <h2 id="Deploy_an_Application" onclick="window.location = '#Deploy_an_Application'">Deploy an Application</h2>
                
                <p>With any luck at all, you have two Immutants running locally, both
                hungry for an app to deploy, so let&#39;s create one.</p>
                
                <p>We&#39;ve been over how to <a href="/news/2011/11/08/deploying-an-application/">deploy</a> an application before, but this time
                we&#39;re gonna keep it real simple: create a new directory and add two
                files.</p>
                
                <p>First, you&#39;ll need a <code>project.clj</code></p>
                
                <pre class="syntax clojure">(defproject example "1.0.0-SNAPSHOT"&#x000A;  :dependencies [[org.clojure/clojure "1.3.0"]])</pre>
                
                <p>Next, the Immutant application bootstrap file, <code>immutant.clj</code>, into
                which we&#39;ll put all our code for this example.</p>
                
                <pre class="syntax clojure">(ns example.init&#x000A;  (:require [immutant.messaging :as messaging]&#x000A;            [immutant.daemons :as daemon])&#x000A;&#x000A;;; Create a message queue&#x000A;(messaging/start "/queue/msg")&#x000A;;; Define a consumer for our queue&#x000A;(def listener (messaging/listen "/queue/msg" #(println "received:" %)))&#x000A;&#x000A;;; Controls the state of our daemon&#x000A;(def done (atom false))&#x000A;&#x000A;;; Our daemon's start function&#x000A;(defn start []&#x000A;  (reset! done false)&#x000A;  (loop [i 0]&#x000A;    (Thread/sleep 1000)&#x000A;    (when-not @done&#x000A;      (println "sending:" i)&#x000A;      (messaging/publish "/queue/msg" i)&#x000A;      (recur (inc i)))))&#x000A;&#x000A;;; Our daemon's stop function&#x000A;(defn stop []&#x000A;  (reset! done true))&#x000A;&#x000A;;; Register the daemon&#x000A;(daemon/start "counter" start stop :singleton true)</pre>
                
                <p>We&#39;ve defined a message queue, a message listener, and a daemon
                service that, once started, publishes messages to the queue every
                second. </p>
                
                <p>Daemons require a name (for referencing as a JMX MBean), a start
                function to be invoked asynchronously, and a stop function that will
                be automatically invoked when your app is undeployed, allowing you to
                cleanly teardown any resources used by your service. Optionally, you
                can declare the service to be a <em>singleton</em>. This means it will only
                be started on one node in your cluster, and should that node crash, it
                will be automatically started on another node, essentially giving you
                a robust, highly-available service.</p>
                
                <p>In the same directory that contains your files, run this:</p>
                
                <pre><code>$ lein immutant deploy&#x000A;</code></pre>
                
                <p>Because both Immutants are monitoring the same deployment directory,
                this should trigger both to deploy the app.</p>
                
                <p>Now watch the output of the shells in which your Immutants are
                running. You should see the daemon start up on only one of them, but
                both should be receiving messages. This is the automatic load
                balancing of message consumers.</p>
                
                <p>Now kill the Immutant running the daemon. Watch the other one to see
                that the daemon will start there within seconds. There&#39;s your
                automatic failover. Restart the killed Immutant to see him start to
                receive messages again. It&#39;s fun, right? :)</p>
                
                <h2 id="Whew!" onclick="window.location = '#Whew!'">Whew!</h2>
                
                <p>So that&#39;s probably enough to show for now. Give it a try, and let us
                know if it worked for you the very first time. If it doesn&#39;t, please
                reach out to us <a href="/community/">in the usual ways</a> and we&#39;ll be happy to
                get you going. Above all, have fun!</p>
              </div>
              <div class="tail">
                 <a href="/news/2012/02/16/clustering/#disqus_thread">Comments</a>
                <hr>
              </div>
            </div>
            <div class="pagination-links"><span class="current-page">1</span> </div>
          </div>
          <div class="span4" id="sidebar-column">
            <div class="tags">
              <div class="tag-cloud">
                <span class="tag tag-0">
                  <a href="/news/tags/announcement/">announcement</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/app-server/">app-server</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/bears/">bears</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/beginning/">beginning</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/boot/">boot</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/boot-immutant/">boot-immutant</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/caching/">caching</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/clustering/">clustering</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/daemons/">daemons</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/datomic/">datomic</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/deploy/">deploy</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/distribution/">distribution</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/enterprise/">enterprise</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/event/">event</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/first/">first</a>
                </span>
                <span class="tag tag-2">
                  <a href="/news/tags/getting-started/">getting-started</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/hotrod/">hotrod</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/infinispan/">infinispan</a>
                </span>
                <span class="tag tag-2">
                  <a href="/news/tags/installation/">installation</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/isolation/">isolation</a>
                </span>
                <span class="tag tag-2">
                  <a href="/news/tags/lein/">lein</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/lein-immutant/">lein-immutant</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/luminus/">luminus</a>
                </span>
                <span class="tag tag-2">
                  <a href="/news/tags/messaging/">messaging</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/openshift/">openshift</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/overlay/">overlay</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/pipelines/">pipelines</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/polyglot/">polyglot</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/poorsmatic/">poorsmatic</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/postgresql/">postgresql</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/presentations/">presentations</a>
                </span>
                <span class="tag tag-6">
                  <a href="/news/tags/releases/">releases</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/ring/">ring</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/runtime/">runtime</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/scheduled-jobs/">scheduled-jobs</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/scheduling/">scheduling</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/screencast/">screencast</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/slim/">slim</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/sockjs/">sockjs</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/survey/">survey</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/thedeuce/">thedeuce</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/torquebox/">torquebox</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/transactions/">transactions</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/transit/">transit</a>
                </span>
                <span class="tag tag-2">
                  <a href="/news/tags/tutorial/">tutorial</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/under-the-hood/">under-the-hood</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/vertx/">vertx</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/web/">web</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/websockets/">websockets</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/wildfly/">wildfly</a>
                </span>
                <span class="tag tag-1">
                  <a href="/news/tags/wtf/">wtf</a>
                </span>
                <span class="tag tag-0">
                  <a href="/news/tags/xa/">xa</a>
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id="footer-push"></div>
    </div>
    <div id="footer">
      <div class="container">
        <div class="row" id="bottom-nav">
          <div class="span8">
            <div id="legal">
              <p>The Immutant project is a member of the <a href="http://jboss.org/">JBoss
              Community</a> and produced by the
              <a href="http://projectodd.org/">Project:odd</a> team.  It is a
              community-driven open-source project, and is licensed under
              the <a href="/license-lgpl.txt">GNU LGPL</a> or <a href="/license-asl.txt">Apache Software
              License</a>, depending on the version.</p>
              
              <p>Copyright 2011 - 2017 <a href="http://redhat.com/">Red Hat, Inc.</a>
              Immutant&trade; is a trademark of Red Hat, Inc.</p>
              
              <p>Content licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.</p>
            </div>
          </div>
          <div class="span4">
            <div id="badges">
              <a href="http://jboss.org/"><img id="jbosscommunity-logo" src="http://torquebox.org/images/jbosscommunity-logo.png"></a>
              <a href="http://projectodd.org/"><img id="projectodd-logo" src="http://projectodd.org/images/projectodd-logo.png"></a>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script src="/javascripts/bootstrap-collapse.js" type="text/javascript"></script>
    <script src="/javascripts/bootstrap-dropdown.js" type="text/javascript"></script>
    <script src="/javascripts/bootstrap-tab.js" type="text/javascript"></script>
    <script>
      $( function () {
         var syntax_root = "/javascripts/jquery-syntax/"
      
         if (!$.browser.msie && $( '.syntax' ).length) {
           $.getScript( syntax_root + "jquery.syntax.min.js", function () {
             $.syntax( {root: syntax_root,
                       blockLayout: 'plain'} )
           } )
         }
       } )
    </script>
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-6435340-7', 'auto');
    ga('send', 'pageview');
    </script>
  </body>
</html>
