<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>Immutant 2.1.4 API documentation</title><link href="assets/immutant.css" rel="stylesheet" type="text/css"></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Immutant 2.1.4 API documentation</a></h1></div><div class="sidebar" id="namespaces"><div id="guides"><h3><a href="index.html"><span class="inner">Guides</span></a></h3><ul><li class="guide Migration-current"><a href="guide-migration.html"><div class="inner"><span>Migration</span></div></a></li><li class="guide Installation-current"><a href="guide-installation.html"><div class="inner"><span>Installation</span></div></a></li><li class="guide current"><a href="guide-web.html"><div class="inner"><span>Web</span></div></a></li><li class="guide Messaging-current"><a href="guide-messaging.html"><div class="inner"><span>Messaging</span></div></a></li><li class="guide Scheduling-current"><a href="guide-scheduling.html"><div class="inner"><span>Scheduling</span></div></a></li><li class="guide Caching-current"><a href="guide-caching.html"><div class="inner"><span>Caching</span></div></a></li><li class="guide Transactions-current"><a href="guide-transactions.html"><div class="inner"><span>Transactions</span></div></a></li><li class="guide WildFly-current"><a href="guide-wildfly.html"><div class="inner"><span>WildFly</span></div></a></li><li class="guide EAP 6.4.x-current"><a href="guide-EAP.html"><div class="inner"><span>EAP 6.4.x</span></div></a></li><li class="guide Logging-current"><a href="guide-logging.html"><div class="inner"><span>Logging</span></div></a></li></ul></div><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>immutant</span></div></div></li><li class="depth-2"><a href="immutant.caching.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>caching</span></div></a></li><li class="depth-3 branch"><a href="immutant.caching.core-cache.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core-cache</span></div></a></li><li class="depth-3"><a href="immutant.caching.core-memoize.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core-memoize</span></div></a></li><li class="depth-2"><a href="immutant.codecs.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>codecs</span></div></a></li><li class="depth-3"><a href="immutant.codecs.fressian.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fressian</span></div></a></li><li class="depth-2 branch"><a href="immutant.coercions.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>coercions</span></div></a></li><li class="depth-2 branch"><a href="immutant.daemons.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>daemons</span></div></a></li><li class="depth-2"><a href="immutant.messaging.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>messaging</span></div></a></li><li class="depth-3 branch"><a href="immutant.messaging.hornetq.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>hornetq</span></div></a></li><li class="depth-3"><a href="immutant.messaging.pipeline.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pipeline</span></div></a></li><li class="depth-2"><a href="immutant.scheduling.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>scheduling</span></div></a></li><li class="depth-3 branch"><a href="immutant.scheduling.joda.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>joda</span></div></a></li><li class="depth-3"><a href="immutant.scheduling.quartz.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quartz</span></div></a></li><li class="depth-2"><a href="immutant.transactions.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>transactions</span></div></a></li><li class="depth-3 branch"><a href="immutant.transactions.jdbc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jdbc</span></div></a></li><li class="depth-3"><a href="immutant.transactions.scope.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scope</span></div></a></li><li class="depth-2 branch"><a href="immutant.util.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-2"><a href="immutant.web.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>web</span></div></a></li><li class="depth-3 branch"><a href="immutant.web.async.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>async</span></div></a></li><li class="depth-3 branch"><a href="immutant.web.middleware.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>middleware</span></div></a></li><li class="depth-3 branch"><a href="immutant.web.sse.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sse</span></div></a></li><li class="depth-3 branch"><a href="immutant.web.ssl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ssl</span></div></a></li><li class="depth-3"><a href="immutant.web.undertow.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>undertow</span></div></a></li><li class="depth-2"><a href="immutant.wildfly.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>wildfly</span></div></a></li></ul></div><div class='namespace-index guide' id='content'><div class='markdown doc'><div class="guide-content"><h1>Web Guide</h1><div class="description"><span>Running Clojure web applications</span></div><div id="toc"><ul><li><a href="#h5370"><span>The Namespaces</span></a></li><li><a href="#h5371"><span>A sample REPL session</span></a><ul><li><a href="#h5372"><span>Common Usage</span></a></li><li><a href="#h5373"><span>Advanced Usage</span></a></li></ul></li><li><a href="#h5374"><span>Virtual Hosts</span></a></li><li><a href="#h5375"><span>Advanced Undertow Configuration</span></a><ul><li><a href="#h5376"><span>TLS/SSL</span></a></li><li><a href="#h5377"><span>HTTP/2</span></a></li></ul></li><li><a href="#h5378"><span>Handler Types</span></a></li><li><a href="#h5379"><span>Development Mode</span></a></li><li><a href="#h5380"><span>Asynchrony</span></a><ul><li><a href="#h5381"><span>HTTP Streams</span></a></li><li><a href="#h5382"><span>WebSockets</span></a></li><li><a href="#h5383"><span>Server-Sent Events (SSE)</span></a></li><li><a href="#h5384"><span>Knowing when a send! completes or fails</span></a></li></ul></li><li><a href="#h5385"><span>Feature Demo</span></a></li></ul></div><p>The <code>org.immutant/web</code> library changed quite a bit from Immutant 1.x to 2.x, both its API and its foundation: the <a href="http://undertow.io/">Undertow</a> web server. Among other things, this resulted in <a href="https://github.com/ptaoussanis/clojure-web-server-benchmarks">much better performance</a> (~35% more throughput than v1.1.1) and built-in support for WebSockets.</p><h2 id="h5370">The Namespaces</h2><p>The primary namespace, <a href="immutant.web.html">immutant.web</a>, includes the two main functions you&rsquo;ll use to run your handlers:</p>
<ul>
  <li><code>run</code> - runs your handler in a specific environment, responding to  web requests matching a given host, port, path and virtual host. The  handler may be either a <a href="https://github.com/ring-clojure/ring/wiki">Ring</a> function, Servlet instance, or  Undertow HttpHandler</li>
  <li><code>stop</code> - stops your handler[s]</li>
</ul><p>Also included:</p>
<ul>
  <li><code>run-dmc</code> - runs your handler in <em>Development Mode</em> (the &lsquo;C&rsquo; is silent)</li>
  <li><code>server</code> - provides finer-grained control over the embedded web  server hosting your handler[s].</li>
</ul><p>The <a href="immutant.web.middleware.html">immutant.web.middleware</a> namespace provides some Ring middleware:</p>
<ul>
  <li><code>wrap-websocket</code> - attach websocket callbacks to your Ring handler</li>
  <li><code>wrap-session</code> - enables session sharing among your Ring handler and  its WebSockets, as well as automatic session replication when your  app is deployed to a WildFly cluster.</li>
  <li><code>wrap-development</code> - included automatically by <code>run-dmc</code>, this  aggregates some middleware handy during development.</li>
</ul><p>The <a href="immutant.web.async.html">immutant.web.async</a> namespace enables the creation of <a href="http://en.wikipedia.org/wiki/WebSocket">WebSockets</a> and <a href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">HTTP streams</a>. And support for <a href="http://www.w3.org/TR/eventsource/">Server-Sent Events</a> is provided by <a href="immutant.web.sse.html">immutant.web.sse</a>.</p><p>The <a href="immutant.web.undertow.html">immutant.web.undertow</a> namespace exposes tuning options for Undertow, the ability to open additional listeners, and flexible SSL configuration.</p><h2 id="h5371">A sample REPL session</h2><p>Now, let&rsquo;s fire up a REPL and work through some of the features of the library.</p><p>If you haven&rsquo;t already, you should read through the <a href="guide-installation.html">installation</a> guide and require the <code>immutant.web</code> namespace at a REPL to follow along:</p>
<pre><code class="clojure">(require &#39;[immutant.web :refer :all])
</code></pre><h3 id="h5372">Common Usage</h3><p>First, you&rsquo;ll need a <a href="https://github.com/ring-clojure/ring/wiki">Ring</a> handler. If you generated your app using a template from <a href="https://github.com/weavejester/compojure">Compojure</a>, <a href="http://www.luminusweb.net/">Luminus</a>, <a href="http://let-caribou.in/">Caribou</a> or some other Ring-based library, yours will be associated with the <code>:handler</code> key of your <code>:ring</code> map in your <code>project.clj</code> file. Of course, a far less fancy handler will suffice:</p>
<pre><code class="clojure">(defn app [request]
  {:status 200
   :body &quot;Hello world!&quot;})
</code></pre><p>To make the app available at <a href="http://localhost:8080/">http://localhost:8080/</a>, do this:</p>
<pre><code class="clojure">(run app)
</code></pre><p>Which, if we make the default values explicit, is equivalent to this:</p>
<pre><code class="clojure">(run app {:host &quot;localhost&quot; :port 8080 :path &quot;/&quot;})
</code></pre><p>Or, since <a href="immutant.web.html#var-run">run</a> takes options as either an explicit map or keyword arguments (kwargs), this:</p>
<pre><code class="clojure">(run app :host &quot;localhost&quot; :port 8080 :path &quot;/&quot;)
</code></pre><p>The options passed to <code>run</code> determine the URL used to invoke your handler: <code>http://{host}:{port}{path}</code></p><p>To replace your <code>app</code> handler with another, just call run again with the same options, and it&rsquo;ll replace the old handler with the new:</p>
<pre><code class="clojure">(run (fn [_] {:status 200 :body &quot;hi!&quot;}))
</code></pre><p>To stop the handler, do this:</p>
<pre><code class="clojure">(stop)
</code></pre><p>Which is equivalent to this:</p>
<pre><code class="clojure">(stop {:host &quot;localhost&quot; :port 8080 :path &quot;/&quot;})
</code></pre><p>Or like <code>run</code>, if you prefer kwargs, this:</p>
<pre><code class="clojure">(stop :host &quot;localhost&quot; :port 8080 :path &quot;/&quot;)
</code></pre><p>Alternatively, you can save the return value from <code>run</code> and pass it to <code>stop</code> to stop your handler.</p>
<pre><code class="clojure">(def server (run app {:port 4242 :path &quot;/hello&quot;}))
...
(stop server)
</code></pre><p>Stopping your handlers isn&rsquo;t strictly necessary if you&rsquo;re content to just let the JVM exit, but it can be handy at a REPL.</p><h3 id="h5373">Advanced Usage</h3><p>The <code>run</code> function returns a map that includes the options passed to it, so you can thread <code>run</code> calls together, useful when your application runs multiple handlers. For example,</p>
<pre><code class="clojure">(def everything (-&gt; (run hello)
                  (assoc :path &quot;/howdy&quot;)
                  (-&gt;&gt; (run howdy))
                  (merge {:path &quot;/&quot; :port 8081})
                  (-&gt;&gt; (run hola))))
</code></pre><p>The above actually creates two Undertow web server instances: one serving requests for the <code>hello</code> and <code>howdy</code> handlers on port 8080, and one serving <code>hola</code> responses on port 8081.</p><p>You can stop all three apps (and shutdown the two web servers) like so:</p>
<pre><code class="clojure">(stop everything)
</code></pre><p>Alternatively, you could stop only the <code>hola</code> app like so:</p>
<pre><code class="clojure">(stop {:path &quot;/&quot; :port 8081})
</code></pre><p>You could even omit <code>:path</code> since &ldquo;/&rdquo; is the default. And because <code>hola</code> was the only app running on the web server listening on port 8081, it will be shutdown automatically.</p><h2 id="h5374">Virtual Hosts</h2><p>The <code>:host</code> option denotes the IP interface to which the web server is bound, which may not be publicly accessible. You can extend access to other hosts using the <code>:virtual-host</code> option, which takes either a single hostname or multiple:</p>
<pre><code class="clojure">(run app :virtual-host &quot;yourapp.com&quot;)
(run app :virtual-host [&quot;app.io&quot; &quot;app.us&quot;])
</code></pre><p>Multiple applications can run on the same <code>:host</code> and <code>:port</code> as long as each has a unique combination of <code>:virtual-host</code> and <code>:path</code>.</p><h2 id="h5375">Advanced Undertow Configuration</h2><p>The <a href="immutant.web.undertow.html">immutant.web.undertow</a> namespace includes a number of composable functions that turn a map of various keywords into a map containing an <code>io.undertow.Undertow$Builder</code> instance mapped to the keyword, <code>:configuration</code>. So Undertow configuration is exposed via a composite of these functions called <a href="immutant.web.undertow.html#var-options">immutant.web.undertow/options</a>.</p><p>For a contrived example, say we wanted our handler to run with 42 worker threads, and listen for requests on two ports, 8888 and 9999. Weird, but possible. To do it, we&rsquo;ll need to pass the <code>:port</code> option twice, in a manner of speaking:</p>
<pre><code class="clojure">(require &#39;[immutant.web.undertow :refer (options)])
(def opts (-&gt; (options :port 8888 :worker-threads 42)
            (assoc :port 9999)
            options))
(run app opts)
</code></pre><h3 id="h5376">TLS/SSL</h3><p>SSL and Java is a notoriously gnarly combination that is way outside the scope of this guide. Ultimately, Undertow needs either a <code>javax.net.ssl.SSLContext</code> or a <code>javax.net.ssl.KeyManager[]</code> and an optional <code>javax.net.ssl.TrustManager[]</code>.</p><p>You may also pass a <code>KeyStore</code> instance or a path to one on disk, and the <code>SSLContext</code> will be created for you. For example,</p>
<pre><code class="clojure">(run app (immutant.web.undertow/options
           :ssl-port 8443
           :keystore &quot;/path/to/keystore.jks&quot;
           :key-password &quot;password&quot;))
</code></pre><p>Another option is to use the <a href="https://github.com/aphyr/less-awful-ssl">less-awful-ssl</a> library; maybe something along these lines:</p>
<pre><code class="clojure">(def context (less.awful.ssl/ssl-context &quot;client.pkcs8&quot; &quot;client.crt&quot; &quot;ca.crt&quot;))
(run app (immutant.web.undertow/options
           :ssl-port 8443
           :ssl-context context))
</code></pre><p>Client authentication may be specified using the <code>:client-auth</code> option, where possible values are <code>:want</code> and <code>:need</code>. Or, if you&rsquo;re fancy, <code>:requested</code> and <code>:required</code>.</p><h3 id="h5377">HTTP/2</h3><p>There are three steps to enabling HTTP/2 or SPDY:</p>
<ul>
  <li>Set the <code>:http2?</code> option to <code>true</code></li>
  <li>Configure an SSL listener (see previous section)</li>
  <li>Prepend the appropriate <code>alpn-boot.jar</code> to your <em>bootclasspath</em></li>
</ul><p>You&rsquo;ll need to consult the <a href="http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html">ALPN</a> docs to know which version of <code>alpn-boot.jar</code> is appropriate for your JVM version. Most importantly, it needs to be prepended (note the <code>/p</code>) to the <em>bootclasspath</em>, e.g.</p>
<pre><code>java -Xbootclasspath/p:{/path/to/alpn-boot.jar} ...
</code></pre><p>See the <a href="https://github.com/immutant/feature-demo">Immutant Feature Demo</a> for an HTTP/2 configuration example, including the use of a <a href="https://github.com/sunng87/lein-bootclasspath-deps">plugin</a> to set the bootclasspath for REPL development.</p><h2 id="h5378">Handler Types</h2><p>Though the handlers you run will typically be Ring functions, you can also pass any valid implementation of <code>javax.servlet.Servlet</code> or <code>io.undertow.server.HttpHandler</code>. For an example of the former, here&rsquo;s a very simple <a href="https://github.com/pedestal/pedestal">Pedestal</a> service running on Immutant:</p>
<pre><code class="clojure">(ns testing.hello.service
  (:require [io.pedestal.http :as http]
            [io.pedestal.http.route.definition :refer [defroutes]]
            [ring.util.response :refer [response]]
            [immutant.web :refer [run]]))

(defn home-page [request] (response &quot;Hello World!&quot;))
(defroutes routes [[[&quot;/&quot; {:get home-page}]]])
(def service {::http/routes routes})

(defn start [options]
  (run (::http/servlet (http/create-servlet service)) options))
</code></pre><h2 id="h5379">Development Mode</h2><p>The <a href="immutant.web.html#var-run-dmc">run-dmc</a> macro resulted from a desire to provide a no-fuss way to enjoy all the benefits of REPL-based development. Before calling <code>run</code>, <code>run-dmc</code> will first ensure that your Ring handler is var-quoted and wrapped in the <code>reload</code> and <code>stacktrace</code> middleware from the <a href="https://github.com/ring-clojure/ring/tree/master/ring-devel">ring-devel</a> library (which must be included among your <code>[:profiles :dev :dependencies]</code> in <code>project.clj</code>). It&rsquo;ll then open your app in a browser.</p><p>Both <code>run</code> and <code>run-dmc</code> accept the same options. You can even mix them within a single threaded call.</p><h2 id="h5380">Asynchrony</h2><p><a href="http://en.wikipedia.org/wiki/WebSocket">WebSockets</a>, <a href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">HTTP streams</a>, and <a href="http://www.w3.org/TR/eventsource/">Server-Sent Events</a> are all enabled by the <a href="immutant.web.async.html#var-as-channel">immutant.web.async/as-channel</a> function, which should be called from your Ring handler, as it takes a request map and some callbacks and returns a valid response map. Its polymorphic design enables graceful degradation from bidirectional WebSockets to unidirectional chunked responses, e.g. streams. In either case, data is sent from the server using <a href="immutant.web.async.html#var-send.21">immutant.web.async/send!</a>.</p><p>It&rsquo;s important to note that <code>as-channel</code> returns a normal Ring response map, so it&rsquo;s completely compatible with Ring middleware that might affect other entries in the response, allowing you to <code>assoc</code> <code>:status</code>, <code>:headers</code>, etc on to it. The only requirement is that the <code>:body</code> entry needs to be ultimately returned by any downstream middleware.</p><p>The signatures of the callback functions supported by <code>as-channel</code> are as follows:</p>
<pre><code class="clojure">  :on-open    (fn [channel])
  :on-close   (fn [channel {:keys [code reason]}])
  :on-error   (fn [channel throwable])
  :on-message (fn [channel message])
</code></pre><p>The <code>:on-message</code> handler is only relevant to WebSockets, as are the <code>:code</code> and <code>:reason</code> keys passed to <code>:on-close</code>: they will be nil for HTTP streams.</p><h3 id="h5381">HTTP Streams</h3><p>Creating chunked responses is straightforward, as the following Ring handler demonstrates:</p>
<pre><code class="clojure">(require &#39;[immutant.web.async :as async])

(defn app [request]
  (async/as-channel request
    {:on-open (fn [stream]
                (dotimes [msg 10]
                  (async/send! stream (str msg) {:close? (= msg 9)})
                  (Thread/sleep 1000))})))
(run app)
</code></pre><p>When a client connects to our app, the <code>:on-open</code> handler is asynchronously called with the appropriate channel. Our contrived callback sends a number to the client every second. On the 10th time it sets the <code>:close?</code> option to true. Its default value is false, causing the channel to remain open after the data is sent.</p><p>If you don&rsquo;t know the status or headers that you need to send until the <code>send!</code> call, you can pass a map of the form <code>{:body msg :status
code :headers [...]}</code> in place of the message, but only on the <em>first</em> send to that channel. A <code>:status</code> or <code>:headers</code> value in that map will override the <code>:status</code> or <code>:headers</code> returned by the Ring handler invocation that called <code>as-channel</code>.</p><p>The message passed to <code>send!</code> (or the <code>:body</code> of a map passed to <code>send!</code>) can be any of the standard Ring body types (<code>String</code>, <code>File</code>, <code>InputStream</code>, <code>ISeq</code>), as well as <code>byte[]</code>.</p><h3 id="h5382">WebSockets</h3><p>To support graceful client degradation, WebSockets are coded exactly like HTTP Streams, except that an additional callback option is supported, <code>:on-message</code>, for bidirectional communication.</p>
<pre><code class="clojure">(def callbacks
  {:on-message (fn [ch msg]
                 (async/send! ch (.toUpperCase msg)))})

(defn app [request]
  (async/as-channel request callbacks))

(run app)
</code></pre><p>The message passed to <code>send!</code> can be any of the standard Ring body types (<code>String</code>, <code>File</code>, <code>InputStream</code>, <code>ISeq</code>), as well as <code>byte[]</code>. Note that each entry in an <code>ISeq</code> will pass through <code>send!</code>, so will be sent as at least one message (more if the entry itself is a type that triggers multiple messages). <code>File</code>s and <code>InputStream</code>s may also be broken up in to multiple messages if they are too large (we hint that they should be sent as up to 16KB messages, but the actual sizes of the messages may vary, depending on the WildFly or Undertow heuristics and configuration).</p><p>You can identify a WebSocket upgrade request by the presence of <code>:websocket?</code> in the request map. This enables you to construct your handlers so that they correctly respond to both normal HTTP requests as well as WebSockets.</p>
<pre><code class="clojure">(defn app [request]
  (if (:websocket? request)
    (async/as-channel request callbacks)
    (-&gt; request
      (get-in [:params &quot;msg&quot;])
      .toUpperCase
      ring.util.response/response)))

(run app)
</code></pre><p>Immutant provides a convenient Ring middleware function that encapsulates the check for the upgrade request: <a href="immutant.web.middleware.html#var-wrap-websocket">immutant.web.middleware/wrap-websocket</a>.</p>
<pre><code class="clojure">(web/run (-&gt; my-app
           (wrap-websocket callbacks)))
</code></pre><p>But using <code>wrap-websocket</code> means losing the <code>request</code> closure in your Ring handler, representing the original WebSocket upgrade request from the client. You can still access it, however, with <a href="immutant.web.async.html#var-originating-request">immutant.web.async/originating-request</a>.</p><p>Note the <code>:path</code> argument to <a href="immutant.web.html#var-run">immutant.web/run</a> applies to both the Ring handler and the WebSocket, distinguished only by the request protocol. Given a <code>:path</code> of &ldquo;/foo&rdquo;, for example, you&rsquo;d have both <code>http://your.host.com/foo</code> and <code>ws://your.host.com/foo</code>.</p><h3 id="h5383">Server-Sent Events (SSE)</h3><p><a href="http://www.w3.org/TR/eventsource/">Server-Sent Events</a> are a stream of specially-formatted chunked responses with a <code>Content-Type</code> header of <code>text/event-stream</code>. The <a href="immutant.web.sse.html">immutant.web.sse</a> namespace provides its own <code>send!</code> and <code>as-channel</code> functions that are composed from their <a href="immutant.web.async.html">immutant.web.async</a> counterparts. <em>Events</em> are polymorphic: any <code>Object</code> other than a <code>Collection</code> or <code>Map</code> is considered a simple data field that will be string-ified, prefixed with &ldquo;data:&rdquo;, and suffixed with &ldquo;\n&rdquo;. A <code>Collection</code> represents a multi-line data field. And a <code>Map</code> is expected to contain at least one of the following keys: <code>:event</code>, <code>:data</code>, <code>:id</code>, and <code>:retry</code>.</p><p>Let&rsquo;s modify the HTTP streaming example to use SSE:</p>
<pre><code class="clojure">(require &#39;[immutant.web.sse :as sse])

(defn app [request]
  (sse/as-channel request
    {:on-open (fn [stream]
                (dotimes [e 10]
                  (sse/send! stream e)
                  (Thread/sleep 1000))
                (sse/send! stream {:event &quot;close&quot;, :data &quot;bye!&quot;}))}))

(run app)
</code></pre><p>Because we&rsquo;re using <code>sse/send!</code> the client will receive newline-delimited messages formatted with field names, e.g.</p>
<pre><code>data: 0

data: 1

 ...

data: 8

data: 9

event: close
data: bye!

</code></pre><p>And note that most EventSource clients will attempt to reconnect if the server closes the connection, so instead we send a special &ldquo;close&rdquo; event on which our client can dispatch to initiate the close.</p><h3 id="h5384">Knowing when a send! completes or fails</h3><p>Calling <code>send!</code> (<code>sse/</code> or <code>async/</code>) is an async operation - the send is immediately queued, and <code>send!</code> returns to the caller. To know when the send has completed, you can provide an <code>:on-success</code> callback. You can also provide an <code>:on-error</code> callback to know when an error occurs:</p>
<pre><code>(async/send! ch a-message
  :on-success #(println &quot;yay!&quot;)
  :on-error   (fn [e] (println &quot;boo!&quot; e)))
</code></pre><h2 id="h5385">Feature Demo</h2><p>We maintain a Leiningen project called the <a href="https://github.com/immutant/feature-demo">Immutant Feature Demo</a> demonstrating all the Immutant namespaces, including simple examples of <a href="https://github.com/immutant/feature-demo/blob/master/src/demo/web.clj">the features described herein</a>.</p><p>You should be able to clone it somewhere, cd there, and <code>lein run</code>.</p><p>Have fun!</p></div></div></div><script src="assets/jquery.syntax.min.js" type="text/javascript"></script><script src="assets/immutant.js" type="text/javascript"></script></body></html>