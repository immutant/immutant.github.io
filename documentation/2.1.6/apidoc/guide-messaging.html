<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>Immutant 2.1.6 API documentation</title><link href="assets/immutant.css" rel="stylesheet" type="text/css"></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Immutant 2.1.6 API documentation</a></h1></div><div class="sidebar" id="namespaces"><div id="guides"><h3><a href="index.html"><span class="inner">Guides</span></a></h3><ul><li class="guide Migration-current"><a href="guide-migration.html"><div class="inner"><span>Migration</span></div></a></li><li class="guide Installation-current"><a href="guide-installation.html"><div class="inner"><span>Installation</span></div></a></li><li class="guide Web-current"><a href="guide-web.html"><div class="inner"><span>Web</span></div></a></li><li class="guide current"><a href="guide-messaging.html"><div class="inner"><span>Messaging</span></div></a></li><li class="guide Scheduling-current"><a href="guide-scheduling.html"><div class="inner"><span>Scheduling</span></div></a></li><li class="guide Caching-current"><a href="guide-caching.html"><div class="inner"><span>Caching</span></div></a></li><li class="guide Transactions-current"><a href="guide-transactions.html"><div class="inner"><span>Transactions</span></div></a></li><li class="guide WildFly-current"><a href="guide-wildfly.html"><div class="inner"><span>WildFly</span></div></a></li><li class="guide EAP 6.4.x-current"><a href="guide-EAP.html"><div class="inner"><span>EAP 6.4.x</span></div></a></li><li class="guide Logging-current"><a href="guide-logging.html"><div class="inner"><span>Logging</span></div></a></li></ul></div><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>immutant</span></div></div></li><li class="depth-2"><a href="immutant.caching.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>caching</span></div></a></li><li class="depth-3 branch"><a href="immutant.caching.core-cache.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core-cache</span></div></a></li><li class="depth-3"><a href="immutant.caching.core-memoize.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core-memoize</span></div></a></li><li class="depth-2"><a href="immutant.codecs.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>codecs</span></div></a></li><li class="depth-3"><a href="immutant.codecs.fressian.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fressian</span></div></a></li><li class="depth-2 branch"><a href="immutant.coercions.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>coercions</span></div></a></li><li class="depth-2 branch"><a href="immutant.daemons.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>daemons</span></div></a></li><li class="depth-2"><a href="immutant.messaging.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>messaging</span></div></a></li><li class="depth-3 branch"><a href="immutant.messaging.hornetq.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>hornetq</span></div></a></li><li class="depth-3"><a href="immutant.messaging.pipeline.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pipeline</span></div></a></li><li class="depth-2"><a href="immutant.scheduling.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>scheduling</span></div></a></li><li class="depth-3 branch"><a href="immutant.scheduling.joda.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>joda</span></div></a></li><li class="depth-3"><a href="immutant.scheduling.quartz.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quartz</span></div></a></li><li class="depth-2"><a href="immutant.transactions.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>transactions</span></div></a></li><li class="depth-3 branch"><a href="immutant.transactions.jdbc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jdbc</span></div></a></li><li class="depth-3"><a href="immutant.transactions.scope.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scope</span></div></a></li><li class="depth-2 branch"><a href="immutant.util.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-2"><a href="immutant.web.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>web</span></div></a></li><li class="depth-3 branch"><a href="immutant.web.async.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>async</span></div></a></li><li class="depth-3 branch"><a href="immutant.web.middleware.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>middleware</span></div></a></li><li class="depth-3 branch"><a href="immutant.web.sse.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sse</span></div></a></li><li class="depth-3 branch"><a href="immutant.web.ssl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ssl</span></div></a></li><li class="depth-3"><a href="immutant.web.undertow.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>undertow</span></div></a></li><li class="depth-2"><a href="immutant.wildfly.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>wildfly</span></div></a></li></ul></div><div class='namespace-index guide' id='content'><div class='markdown doc'><div class="guide-content"><h1>Messaging Guide</h1><div class="description"><span>Simple creation and usage of distributed queues and topics</span></div><div id="toc"><ul><li><a href="#h3346"><span>The API</span></a><ul><li><a href="#h3347"><span>Some Examples</span></a></li></ul></li><li><a href="#h3348"><span>Concurrency</span></a></li><li><a href="#h3349"><span>Durable Topic Subscriptions</span></a></li><li><a href="#h3350"><span>Contexts</span></a></li><li><a href="#h3351"><span>Remote Destinations</span></a></li><li><a href="#h3352"><span>Destination creation in WildFly</span></a></li><li><a href="#h3353"><span>Context modes</span></a></li><li><a href="#h3354"><span>Context modes for listeners</span></a></li><li><a href="#h3355"><span>HornetQ configuration</span></a></li><li><a href="#h3356"><span>Transactions</span></a><ul><li><a href="#h3357"><span>Listeners</span></a></li></ul></li></ul></div><p>If you&rsquo;re coming from Immutant 1.x, you may notice that the messaging artifact has been renamed (<code>org.immutant/immutant-messaging</code> is now <code>org.immutant/messaging</code>), and the API has changed a bit. We&rsquo;ll point out the notable API changes as we go.</p><h2 id="h3346">The API</h2><p>The messaging <a href="immutant.messaging.html">API</a> is backed by <a href="http://hornetq.jboss.org/">HornetQ</a>, which is an implementation of <a href="https://en.wikipedia.org/wiki/Java_Message_Service">JMS</a>. JMS provides two primary destination types: <em>queues</em> and <em>topics</em>. Queues represent point-to-point destinations, and topics publish/subscribe.</p><p>To use a destination, we need to get a reference to one via the <a href="immutant.messaging.html#var-queue">queue</a> or <a href="immutant.messaging.html#var-topic">topic</a> functions, depending on the type required. This will create the destination if it does not already exist. This is a bit different than the 1.x API, which provided a single <code>start</code> function for this, and determined the type of destination based on conventions around the provided name. In 2.x, we&rsquo;ve removed those naming conventions.</p><p>Once we have a reference to a destination, we can operate on it with the following functions:</p>
<ul>
  <li><a href="immutant.messaging.html#var-publish">publish</a> - sends a message to the destination</li>
  <li><a href="immutant.messaging.html#var-receive">receive</a> - receives a single message from the destination</li>
  <li><a href="immutant.messaging.html#var-listen">listen</a> - registers a function to be called each time a message  arrives at the destination</li>
</ul><p>If the destination is a queue, we can do synchronous messaging (<a href="https://en.wikipedia.org/wiki/Request-response">request-response</a>):</p>
<ul>
  <li><a href="immutant.messaging.html#var-respond">respond</a> - registers a function that receives each request, and  the returned value will be sent back to the requester</li>
  <li><a href="immutant.messaging.html#var-request">request</a> - sends a message to the responder</li>
</ul><p>Finally, to deregister listeners, responders, and destinations, we provide a single <a href="immutant.messaging.html#var-stop">stop</a> function. This is another difference from 1.x - the <code>unlisten</code> and <code>stop</code> functions have been collapsed to <code>stop</code>.</p><h3 id="h3347">Some Examples</h3><p>You should follow the instructions in the <a href="guide-installation.html">installation</a> guide to set up a project using Immutant 2.x, and in addition to <code>org.immutant/messaging</code> add <code>[cheshire &quot;5.3.1&quot;]</code> to the project dependencies (we&rsquo;ll be encoding some messages as JSON in our examples below, so we&rsquo;ll go ahead and add <a href="https://github.com/dakrone/cheshire">cheshire</a> while we&rsquo;re at it). Then, fire up a REPL, and require the <code>immutant.messaging</code> namespace to follow along:</p>
<pre><code class="clojure">(require &#39;[immutant.messaging :refer :all])
</code></pre><p>First, let&rsquo;s create a queue:</p>
<pre><code class="clojure">(queue &quot;my-queue&quot;)
</code></pre><p>That will create the queue in the HornetQ broker for us. We&rsquo;ll need a reference to that queue to operate on it. Let&rsquo;s go ahead and store that reference in a var:</p>
<pre><code class="clojure">(def q (queue &quot;my-queue&quot;))
</code></pre><p>We can call <code>queue</code> any number of times - if the queue already exists, we&rsquo;re just grabbing a reference to it.</p><p>Now, let&rsquo;s register a listener on our queue. Let&rsquo;s just print every message we get:</p>
<pre><code class="clojure">(def listener (listen q println))
</code></pre><p>We can publish to that queue, and see that the listener gets called:</p>
<pre><code class="clojure">(publish q {:hi :there})
</code></pre><p>You&rsquo;ll notice that we&rsquo;re publishing a map there - we can publish pretty much any data structure as a message. By default, that message will be encoded using <a href="https://github.com/edn-format/edn">edn</a>. We also support other encodings, namely: <code>:fressian</code>, <code>:json</code>, and <code>:none</code>. We can choose a different encoding by passing an :encoding option to <code>publish</code>:</p>
<pre><code class="clojure">(publish q {:hi :there} :encoding :json)
</code></pre><p>If you want to use <code>:fressian</code> or <code>:json</code>, you&rsquo;ll need to add <code>org.clojure/data.fressian</code> or <code>cheshire</code> to your dependencies to enable them, respectively.</p><p>We passed our options to <code>publish</code> as keyword arguments, but they can also be passed as a map:</p>
<pre><code class="clojure">(publish q {:hi :there} {:encoding :json})
</code></pre><p>This holds true for any of the messaging functions that take options.</p><p>We&rsquo;re also passing the destination reference to <code>publish</code> instead of the destination name. That&rsquo;s a departure from 1.x, where you could just pass the destination name. Since we no longer have conventions about how queues and topics should be named, we can no longer determine the type of the destination from the name alone.</p><p>We can deregister the listener by either passing it to <code>stop</code> or calling <code>.close</code> on it:</p>
<pre><code class="clojure">(stop listener)
;; identical to
(.close listener)
</code></pre><p>Now let&rsquo;s take a look at synchronous messaging. Let&rsquo;s create a new queue for this (you&rsquo;ll want to use a dedicated queue for each responder, and not use this queue for <code>publish</code>/<code>listen</code>) and register a responder that just increments the request:</p>
<pre><code class="clojure">(def sync-q (queue &quot;sync&quot;))

(def responder (respond sync-q inc))
</code></pre><p>Then, we make a request, which returns a <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html">Future</a> that we can dereference:</p>
<pre><code class="clojure">@(request sync-q 1)
</code></pre><p>The responder is just a fancy listener, and can be deregistered the same way as a listener.</p><h2 id="h3348">Concurrency</h2><p>Listeners can have multiple threads invoking their handler as messages are consumed. You control how many with the <code>:concurrency</code> option provided by <a href="immutant.messaging.html#var-listen">listen</a> and <a href="immutant.messaging.html#var-respond">respond</a>. By default, it is set to 1 for topics and the number of available processors for queues, but for IO-bound handlers, you may see better performance as you increase the number. It very much depends on what your handler is doing and how many messages it needs to process concurrently.</p><h2 id="h3349">Durable Topic Subscriptions</h2><p>Typically, messages published to a topic are only delivered to listeners connected to the topic at that time. But it&rsquo;s possible to <a href="immutant.messaging.html#var-subscribe">subscribe</a> to a topic with a unique name, so that the broker will accumulate messages for that client when it&rsquo;s disconnected and deliver them in the proper order when the client reconnects.</p><p>Use the <a href="immutant.messaging.html#var-subscribe">subscribe</a> function to create a &ldquo;durable topic subscriber&rdquo;. Like <a href="immutant.messaging.html#var-listen">listen</a> it expects a callback function. Unlike <a href="immutant.messaging.html#var-listen">listen</a>, the destination <em>must</em> be a topic, and a unique <code>subscription-name</code> is required. If the resulting client gets disconnected for any reason, simply call <a href="immutant.messaging.html#var-subscribe">subscribe</a> again with the same <code>subscription-name</code> and any messages published to the topic in the client&rsquo;s absence will be mapped to the callback function.</p><p>Some additional server-side resources are required to track each subscriber, of course, so <a href="immutant.messaging.html#var-unsubscribe">unsubscribe</a> is provided to tear down a durable topic subscription when no longer needed.</p><h2 id="h3350">Contexts</h2><p>Immutant borrows the <code>Context</code> abstraction introduced in <a href="https://en.wikipedia.org/wiki/Java_Message_Service">JMS</a> 2.0, which is essentially a mashup of <code>Connection</code> and <code>Session</code>.</p><p>Most of the messaging functions accept a <code>:context</code> option. If omitted, one is automatically created on the caller&rsquo;s behalf, used, and then disposed of. This is fine for most use cases, but some will require you to manage the lifecycle of one or more <code>Contexts</code> yourself. Two cases, in particular:</p>
<ul>
  <li>Remote destinations, discussed in the next section</li>
  <li>Publishing or receiving a batch of messages</li>
</ul><p>When publishing a batch of messages, it&rsquo;s more efficient to create a single <a href="immutant.messaging.html#var-context">context</a> and pass it to each <a href="immutant.messaging.html#var-publish">publish</a> or <a href="immutant.messaging.html#var-request">request</a> call. Otherwise, a new one is created and torn down for every message in the batch. Of course, you&rsquo;re responsible for closing any <code>Context</code> you create so <code>with-open</code> is your friend:</p>
<pre><code class="clojure">(with-open [ctx (context)]
  (let [q (queue &quot;foo&quot;)]
    (dotimes [n 10000]
      (publish q n :context ctx))))
</code></pre><p>This is not a problem for <a href="immutant.messaging.html#var-listen">listen</a>, <a href="immutant.messaging.html#var-subscribe">subscribe</a> or <a href="immutant.messaging.html#var-respond">respond</a> since each only requires a single <code>Context</code> no matter how many times their callback function is invoked. It is potentially an issue for <a href="immutant.messaging.html#var-receive">receive</a>, but if you&rsquo;re receiving a batch of messages, you should consider using <a href="immutant.messaging.html#var-listen">listen</a> instead.</p><h2 id="h3351">Remote Destinations</h2><p>To connect to a remote HornetQ instance, you&rsquo;ll need to create a remote context (via the <a href="immutant.messaging.html#var-context">context</a> function), and use it when getting a reference to the destination:</p>
<pre><code class="clojure">(with-open [context (context :host &quot;some-host&quot; :port 5445)]
  (publish
    (queue &quot;foo&quot; :context context)
    &quot;a message&quot;))
</code></pre><p>A few things to note about the above example:</p>
<ul>
  <li>We&rsquo;re using <code>with-open</code> because you need to close any contexts you  make.</li>
  <li>We don&rsquo;t need to pass the context to <a href="immutant.messaging.html#var-publish">publish</a>, since it will  reuse the context that was used to create the queue reference.</li>
</ul><p>Most importantly, since we&rsquo;re passing the context to <a href="immutant.messaging.html#var-queue">queue</a>, a queue with that name must already exist on the remote host. When <a href="immutant.messaging.html#var-queue">queue</a> is passed a remote context, it will return a reference to the remote queue <em>without asking HornetQ to create it</em>.</p><h2 id="h3352">Destination creation in WildFly</h2><p>Outside of WildFly, i.e. embedded in your standalone app, creating destinations is as simple as calling either <a href="immutant.messaging.html#var-queue">queue</a> (or <a href="immutant.messaging.html#var-topic">topic</a>) without a remote context.</p><p>But creating destinations dynamically like that is not something WildFly is built for. JEE apps expect their queues/topics to already exist; creating them is the job of the server administrator.</p><p>Calling <a href="immutant.messaging.html#var-queue">queue</a> or <a href="immutant.messaging.html#var-topic">topic</a> within WildFly <em>might</em> work, but it could also result in deadlock depending on the CPU resources available and the number of apps being deployed simultaneously. You can avoid that uncertainty by configuring the destinations yourself using the normal WildFly mechanisms. You still have to call <a href="immutant.messaging.html#var-queue">queue</a> or <a href="immutant.messaging.html#var-topic">topic</a> in your Clojure code, but because the named destinations already exist, no deadlock will occur.</p><p>As <a href="https://docs.jboss.org/author/display/WFLY9/Messaging+configuration">this guide</a> explains, there are 3 common ways to create your destinations with WildFly: the main config file, one or more <code>-jms.xml</code> files, or the CLI.</p><p>Here&rsquo;s a snippet from the main config file, e.g. <code>standalone-full.xml</code> with comments showing the Clojure code required to reference each one:</p>
<pre><code class="xml">...
  &lt;hornetq-server&gt;
    ...
    &lt;jms-destinations&gt;

      &lt;!-- (queue &quot;foo&quot;) --&gt;
      &lt;jms-queue name=&quot;foo&quot;&gt;
        &lt;entry name=&quot;java:/jms/queue/foo&quot;/&gt;
      &lt;/jms-queue&gt;

      &lt;!-- (topic &quot;/foo/bar&quot;) --&gt;
      &lt;jms-topic name=&quot;/foo/bar&quot;&gt;
        &lt;entry name=&quot;java:/jms/topic/_/foo/bar&quot;/&gt;
      &lt;/jms-topic&gt;

    &lt;/jms-destinations&gt;
  &lt;/hornetq-server&gt;
&lt;/subsystem&gt;
</code></pre><p>Note that Immutant looks the destination up via JNDI, so you must have an entry of the same form as those given above. Also note that if the name of the destination starts with <code>/</code>, you must include a <code>_</code> segment in the JNDI names, as JNDI does not allow blank segments. Immutant will insert the <code>_</code> when looking up or creating destination entries where the name starts with <code>/</code>.</p><h2 id="h3353">Context modes</h2><p>When creating a context, you can pass a <code>:mode</code> option that controls how messages will be acknowledged and delivered.</p><p>Immutant provides three modes:</p>
<ul>
  <li><p><code>:auto-ack</code> - <em>the default for contexts</em>, when this mode is active,  receipt of a message is automatically acknowledged when a <code>receive</code>  call completes. This mode doesn&rsquo;t affect publication - <code>publish</code>  calls will complete immediately.</p></li>
  <li><p><code>:client-ack</code> - when this mode is active, you are responsible for  acknowledging the message manually by calling <code>.acknowledge</code> on the  Message object. This means you need to get the raw message (by  passing <code>:decode? false</code> to <code>receive</code>). This mode doesn&rsquo;t affect  publication - <code>publish</code> calls will complete immediately.</p></li>
  <li><p><code>:transacted</code> - <em>the default for listeners</em>, when this mode is  active, you are responsible for committing or rolling back (by  calling <code>.commit</code> or <code>.rollback</code> on the context, respectively) any  actions performed on the context. This applies to publishes <em>and</em>  receives.</p></li>
</ul><p>If a context is created with <code>:xa? true</code>, the <code>:mode</code> option is ignored. See the <a href="guide-transactions.html">Transactions Guide</a> for more details.</p><h2 id="h3354">Context modes for listeners</h2><p>The <a href="immutant.messaging.html#var-listen">listen</a> and <a href="immutant.messaging.html#var-respond">respond</a> functions take a <code>:mode</code> option, which is used <em>instead</em> of the mode of any <code>:context</code> option (listeners need a context per thread, so create and manage their own contexts). The <code>:mode</code> option to these functions takes the same modes as above, with the following behavioral differences (note that <code>:transacted</code> is the default for listeners, <em>not</em> <code>:auto-ack</code>):</p>
<ul>
  <li><p><code>:auto-ack</code> - when active, the receipt of the message will  automatically be acknowledged when the handler function completes.</p></li>
  <li><p><code>:client-ack</code> - when active, you are responsible for  acknowledging the message manually by calling <code>.acknowledge</code> on the  Message object. This means you need to get the raw message (by  passing <code>:decode? false</code> to <code>listen</code>).</p></li>
  <li><p><code>:transacted</code> - <em>the default for listeners!</em> when active, <code>.commit</code>  is called on the context automatically if the handler function  completes successfully. If it throws an exception, <code>.rollback</code> is  called on the context. Any messaging operations that take a context  will use the context that is active for the listener itself (if not  passed one explicitly). This means that any messaging operations  within the handler function <em>become participants in the listener&rsquo;s  transaction</em>, by default. This can lead to deadlock when a  transacted handler calls <code>publish</code> or <code>request</code> since those calls  can&rsquo;t complete until the handler completes. In such a case, either  set <code>:mode</code> to <code>:auto-ack</code> or use distributed transactions.</p></li>
</ul><p>If you need to use distributed transactions (XA) within a listener function, you are responsible for demarcating the transaction. See the <a href="guide-transactions.html">Transactions Guide</a> for more details.</p><h2 id="h3355">HornetQ configuration</h2><p>When used outside of WildFly, we configure <a href="http://hornetq.jboss.org/">HornetQ</a> via a pair of xml files. If you need to adjust any of the HornetQ <a href="https://docs.jboss.org/hornetq/2.4.0.Final/docs/user-manual/html_single/#server.configuration">configuration options</a>, you can provide a copy of one (or both) of those files (<code>hornetq-configuration.xml</code> and <code>hornetq-jms.xml</code>, which should be based off of the <a href="https://github.com/projectodd/wunderboss/blob/0.12.2/messaging-hornetq/src/main/resources/">default versions</a>) on your application&rsquo;s classpath and your copies will be used instead of the default ones. When making changes to these files, be careful about changing existing settings, as Immutant relies on some of them.</p><p>We&rsquo;ve also exposed a few HornetQ settings as system properties, namely:</p>
<table>
  <thead>
    <tr>
      <th>Property </th>
      <th>Description </th>
      <th>Default </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>hornetq.data.dir</code> </td>
      <td>The base directory for HornetQ to store its data files </td>
      <td><code>./hornetq-data/</code> </td>
    </tr>
    <tr>
      <td><code>hornetq.netty.port</code> </td>
      <td>The port that HornetQ will listen on for remote connections </td>
      <td><code>5445</code> </td>
    </tr>
    <tr>
      <td><code>hornetq.netty.host</code> </td>
      <td>The host that HornetQ will listen on for remote connections </td>
      <td><code>localhost</code> </td>
    </tr>
  </tbody>
</table><p>Note that any custom xml or system properties will be ignored when running inside WildFly - you&rsquo;ll need to make adjustments to the WildFly configuration to achieve similar effects.</p><p>In addition, it is possible to override many HornetQ configuration settings at runtime using <a href="immutant.messaging.hornetq.html#var-set-address-options">immutant.messaging.hornetq/set-address-options</a>.</p><h2 id="h3356">Transactions</h2><p>When the messaging operations are left to create their own <code>Context</code>, they check to see whether an XA transaction is active. If so, an XA context is created and automatically enlisted as a resource in the active transaction. Otherwise, a more efficient non-XA <code>Context</code> is used.</p><p>So you only pay for transactions if you need them.</p><p>However, the default value for the <a href="immutant.messaging.html#var-context">context</a> function&rsquo;s <code>:xa?</code> option is <code>false</code>, so if you&rsquo;re managing <code>Context</code> instances yourself, you must set <code>:xa?</code> to true if you need that <code>Context</code> to be part of a distributed XA transaction.</p><h3 id="h3357">Listeners</h3><p>In Immutant 1.x, message listeners were automatically enlisted participants in an XA transaction, but that is not the case with Immutant 2.x. Within the listener function, you must now explicitly define a transaction using one of the macros in <a href="immutant.transactions.html">immutant.transactions</a>. If an exception escapes its body, the transaction will be rolled back, and if the exception bubbles out of the listener function, the message will be queued for redelivery.</p><p>But the rollback of the transaction has no relationship to message redelivery, which is only triggered by the exception. The transaction <em>could</em> be rolled back as a result of calling <a href="immutant.transactions.html#var-set-rollback-only">immutant.transactions/set-rollback-only</a>, in which case no exception would be thrown. Hence, rollback would occur, but not redelivery.</p><p>See the <a href="guide-transactions.html">Transactions Guide</a> for more details.</p></div></div></div><script src="assets/jquery.syntax.min.js" type="text/javascript"></script><script src="assets/immutant.js" type="text/javascript"></script></body></html>