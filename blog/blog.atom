<?xml version="1.0" encoding="utf-8" ?>
<feed xml:lang="en-US" xmlns="http://www.w3.org/2005/Atom">
  <id>https://ceylon-lang.org/blog/</id>
  <title>Ceylon team blog</title>
  <updated>2017-08-21T00:00:00+00:00</updated>
  <link href="https://ceylon-lang.org/blog/blog.atom" rel="self" type="application/atom+xml" />
  <link href="https://ceylon-lang.org/" rel="alternate" type="text/html" />
  <entry>
    <id>https://ceylon-lang.org/blog/2017/08/21/ceylon-1-3-3</id>
    <title>Ceylon 1.3.3 is now available</title>
    <updated>2017-08-21T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2017/08/21/ceylon-1-3-3" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      Ceylon 1.3.3 is a significant minor release of
      the Ceylon language, with over 200 issues closed. This
      release introduces the restricted annotation, allowing more
      sophisticated access control, and else case in switch
      statements, features full support for npm scopes and
      Maven classifiers, allows static members of interfaces,
      and freely allows constructor and method overloading in
      Ceylon code marked native("jvm").
      
      A major goal of this release was to enable improvements to
      Vert.x's Ceylon language APIs.
      
      This is the last release of Ceylon 1.3. The next release of
      Ceylon will be 1.4.0, after migration of the project to
      the Eclipse Foundation.
      
      IDE Changes
      
      Ceylon IDE 1.3.3 for IntelliJ and
      Eclipse support the most recent
      releases of the Eclipse...
    </summary>
    <content type="html">
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;Ceylon 1.3.3&lt;/a&gt; is a significant minor release of
      the Ceylon language, with over &lt;a href=&quot;https://github.com/eclipse/ceylon/issues?q=is%3Aissue+milestone%3A1.3.3+is%3Aclosed&quot;&gt;200 issues&lt;/a&gt; closed. This
      release introduces the &lt;code&gt;restricted&lt;/code&gt; annotation, allowing more
      sophisticated access control, and &lt;code&gt;else case&lt;/code&gt; in &lt;code&gt;switch&lt;/code&gt;
      statements, features full support for &lt;a href=&quot;https://docs.npmjs.com/misc/scope&quot;&gt;npm scopes&lt;/a&gt; and
      &lt;a href=&quot;https://maven.apache.org/pom.html#Maven_Coordinates&quot;&gt;Maven classifiers&lt;/a&gt;, allows &lt;code&gt;static&lt;/code&gt; members of interfaces,
      and freely allows constructor and method overloading in
      Ceylon code marked &lt;code&gt;native(&quot;jvm&quot;)&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;A major goal of this release was to enable improvements to
      &lt;a href=&quot;http://vertx.io/&quot;&gt;Vert.x&lt;/a&gt;'s Ceylon language APIs.&lt;/p&gt;
      
      &lt;p&gt;This is the last release of Ceylon 1.3. The next release of
      Ceylon will be 1.4.0, after &lt;a href=&quot;https://ceylon-lang.org/blog/2017/08/21/eclipse-ceylon/&quot;&gt;migration&lt;/a&gt; of the project to
      the &lt;a href=&quot;https://projects.eclipse.org/projects/technology.ceylon&quot;&gt;Eclipse Foundation&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;IDE Changes&lt;/h3&gt;
      
      &lt;p&gt;Ceylon IDE 1.3.3 for &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/ide/intellij/features&quot;&gt;IntelliJ&lt;/a&gt; and
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/ide/eclipse/features&quot;&gt;Eclipse&lt;/a&gt; support the most recent
      releases of the Eclipse and IntelliJ platforms, and Ceylon IDE
      for Eclipse now features an upgraded icon set optimized for
      high-density displays.&lt;/p&gt;
      
      &lt;p&gt;Ceylon IDE for Eclipse now requires Eclipse Oxygen.&lt;/p&gt;
      
      &lt;h3&gt;SDK Changes&lt;/h3&gt;
      
      &lt;p&gt;The Ceylon SDK features the new module &lt;a href=&quot;https://herd.ceylon-lang.org/modules/ceylon.toml&quot;&gt;ceylon.toml&lt;/a&gt;,
      along with a number of bugfixes and improvements.&lt;/p&gt;
      
      &lt;h3&gt;Compatibility&lt;/h3&gt;
      
      &lt;p&gt;This release of Ceylon has been tested with a wide variety
      of Java libraries and frameworks, including:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://vertx.io/&quot;&gt;Vert.x&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://projects.spring.io/spring-boot/&quot;&gt;Spring Boot&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;WildFly and &lt;a href=&quot;http://wildfly-swarm.io/&quot;&gt;WildFly Swarm&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://hibernate.org&quot;&gt;Hibernate&lt;/a&gt; (JPA),&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://resteasy.jboss.org/&quot;&gt;RESTEasy&lt;/a&gt; (JAXB and JAX-RS),&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://weld.cdi-spec.org/&quot;&gt;Weld&lt;/a&gt; (CDI) and &lt;a href=&quot;https://github.com/google/guice&quot;&gt;Guice&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;Eclipse Equinox, Apache Karaf, and Apache Felix (OSGi),&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://sparkjava.com/&quot;&gt;Spark&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;JavaFX,&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxJava/&quot;&gt;RxJava&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://vaadin.com/home&quot;&gt;Vaadin&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.lwjgl.org/&quot;&gt;LWJGL&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://jogamp.org/&quot;&gt;JOGL&lt;/a&gt; (OpenGL), and&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://ceylon-lang.org/blog/2016/06/02/ceylon-on-android&quot;&gt;Android&lt;/a&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Example code demonstrating the use of these frameworks is
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/examples&quot;&gt;available&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Migration&lt;/h3&gt;
      
      &lt;ul&gt;
      &lt;li&gt;&lt;p&gt;For the JVM, this release is backwards-compatible with all
      previous releases of Ceylon since 1.2.0.&lt;/p&gt;&lt;/li&gt;
      &lt;li&gt;&lt;p&gt;For JavaScript, this release is backwards-compatible only
      with releases since 1.2.2.&lt;/p&gt;&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Ceylon 1.3.3 is backward-compatible with Ceylon 1.3.2, and
      so it's not necessary to recompile or change dependencies.
      However, upgrading to version 1.3.3 of any Ceylon platform
      module is recommended.&lt;/p&gt;
      
      &lt;h2&gt;About Ceylon&lt;/h2&gt;
      
      &lt;p&gt;Ceylon is a modern, modular, statically typed programming
      language for the Java and JavaScript virtual machines. The
      language features a flexible and very readable syntax, a
      unique and uncommonly elegant static type system, a powerful
      module architecture, and excellent tooling, including an
      awesome IDE supporting both IntelliJ IDEA and the Eclipse
      platform.&lt;/p&gt;
      
      &lt;p&gt;Ceylon enables the development of cross-platform modules
      that execute portably in both virtual machine environments.
      Alternatively, a Ceylon module may target one or the other
      platform, in which case it may interoperate with native code
      written for that platform.&lt;/p&gt;
      
      &lt;h3&gt;In the box&lt;/h3&gt;
      
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;This release&lt;/a&gt; includes:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;a complete &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/spec&quot;&gt;language specification&lt;/a&gt; that defines the
      syntax and semantics of Ceylon in language accessible to
      the professional developer,&lt;/li&gt;
      &lt;li&gt;a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/reference/tool/ceylon/subcommands/index.html&quot;&gt;command line toolset&lt;/a&gt; including compilers for
      Java and JavaScript, a documentation compiler, a test
      runner, a WAR archive packager, a &quot;fat&quot; JAR packager, and
      support for executing modular programs on the JVM and
      Node.js,&lt;/li&gt;
      &lt;li&gt;a powerful module architecture for code organization,
      dependency management, and module isolation at runtime,
      which also supports interoperation with OSGi, Jigsaw,
      Maven, and npm, and&lt;/li&gt;
      &lt;li&gt;the &lt;a href=&quot;https://herd.ceylon-lang.org/modules/ceylon.language&quot;&gt;language module&lt;/a&gt;, our minimal,
      cross-platform, foundation-level API.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Available separately:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;updated versions of the platform modules that comprise the
      &lt;a href=&quot;https://modules.ceylon-lang.org/categories/SDK&quot;&gt;Ceylon SDK&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;a plugin for the &lt;code&gt;ceylon&lt;/code&gt; command that supports
      &lt;a href=&quot;https://github.com/jvasileff/ceylon-dart&quot;&gt;compilation and execution for the Dart VM&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;a plugin &lt;a href=&quot;https://github.com/eclipse/ceylon.swarm&quot;&gt;packager&lt;/a&gt; for &lt;a href=&quot;http://wildfly-swarm.io/&quot;&gt;WildFly Swarm&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;a plugin code &lt;a href=&quot;https://github.com/eclipse/ceylon.formatter&quot;&gt;formatter&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;two full-featured integrated development environments: for
      Eclipse and IntelliJ IDEA, and&lt;/li&gt;
      &lt;li&gt;a plugin for &lt;a href=&quot;https://github.com/jvasileff/vscode-ceylon&quot;&gt;Visual Studio Code&lt;/a&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;h3&gt;Language&lt;/h3&gt;
      
      &lt;p&gt;Ceylon is a highly understandable object-oriented language
      with static typing. The language features:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;an emphasis upon &lt;strong&gt;readability&lt;/strong&gt; and a strong bias toward
      &lt;strong&gt;omission or elimination of potentially-harmful or
      potentially-ambiguous constructs&lt;/strong&gt; and toward highly
      &lt;strong&gt;disciplined use of static types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;an extremely powerful and uncommonly elegant type system
      combining subtype and parametric polymorphism with:
      
      &lt;ul&gt;
      &lt;li&gt;first-class &lt;strong&gt;union and intersection types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;both &lt;strong&gt;declaration-site and use-site variance&lt;/strong&gt;, and&lt;/li&gt;
      &lt;li&gt;the use of principal types for &lt;strong&gt;local type inference&lt;/strong&gt;
      and &lt;strong&gt;flow-sensitive typing&lt;/strong&gt;,&lt;/li&gt;
      &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;a unique treatment of &lt;strong&gt;function and tuple types&lt;/strong&gt;,
      enabling powerful abstractions, along with the most
      &lt;strong&gt;elegant approach to &lt;code&gt;null&lt;/code&gt;&lt;/strong&gt; of any modern language,&lt;/li&gt;
      &lt;li&gt;first-class constructs for defining &lt;strong&gt;modules and
      dependencies between modules&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;a very flexible syntax including &lt;strong&gt;comprehensions&lt;/strong&gt; and
      support for expressing &lt;strong&gt;tree-like structures&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;fully-reified generic types&lt;/strong&gt;, on both the JVM and
      JavaScript virtual machines, and a unique &lt;strong&gt;typesafe
      metamodel&lt;/strong&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;More information about these language features may be
      found in the &lt;a href=&quot;https://ceylon-lang.org/features&quot;&gt;feature list&lt;/a&gt; and
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/introduction/&quot;&gt;quick introduction&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Community&lt;/h3&gt;
      
      &lt;p&gt;The Ceylon community site, &lt;a href=&quot;https://ceylon-lang.org&quot;&gt;https://ceylon-lang.org&lt;/a&gt;, includes
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3&quot;&gt;documentation&lt;/a&gt;, and information about
      &lt;a href=&quot;https://ceylon-lang.org/community&quot;&gt;getting involved&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;You can follow &lt;a href=&quot;https://twitter.com/ceylonlang&quot;&gt;@ceylonlang&lt;/a&gt; on Twitter.&lt;/p&gt;
      
      &lt;h3&gt;Source code&lt;/h3&gt;
      
      &lt;p&gt;The source code for Ceylon, its specification, and its website,
      is freely available from &lt;a href=&quot;https://github.com/eclipse&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;Information about Ceylon's open source licenses is available
      &lt;a href=&quot;https://ceylon-lang.org/code/licenses/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Issues&lt;/h3&gt;
      
      &lt;p&gt;Bugs and suggestions may be reported in GitHub's
      &lt;a href=&quot;https://ceylon-lang.org/code/issues&quot;&gt;issue tracker&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Acknowledgement&lt;/h2&gt;
      
      &lt;p&gt;As always, we're deeply grateful to the community volunteers
      who contributed a substantial part of the current Ceylon
      codebase, working in their own spare time. The following
      people have contributed to Ceylon:&lt;/p&gt;
      
      &lt;p&gt;Gavin King,                Stéphane Épardaud,           Tako Schotanus,
      Tom Bentley,               David Festal,                Enrique Zamudio,
      Bastien Jansen,            Emmanuel Bernard,            Aleš Justin,
      Tomáš Hradec,              James Cobb,                  Ross Tate,
      Max Rydahl Andersen,       Mladen Turk,                 Lucas Werkmeister,
      Roland Tepp,               Diego Coronel,               Matej Lazar,
      John Vasileff,             Toby Crawley,                Julien Viet,
      Loic Rouchon,              Stephane Gallès,             Ivo Kasiuk,
      Corbin Uselton,            Paco Soberón,                Michael Musgrove,
      Daniel Rochetti,           Henning Burdack,             Luke deGruchy,
      Rohit Mohan,               Griffin DeJohn,              Casey Dahlin,
      Gilles Duboscq,            Tomasz Krakowiak,            Alexander Altman,
      Alexander Zolotko,         Alex Szczuczko,              Andrés G. Aragoneses,
      Anh Nhan Nguyen,           Brice Dutheil,               Carlos Augusto Mar,
      Charles Gould,             Chris Gregory,               klinger,
      Martin Voelkle,            Mr. Arkansas,                Paŭlo Ebermann,
      Vorlent,                   Akber Choudhry,              Renato Athaydes,
      Flavio Oliveri,            Michael Brackx,              Brent Douglas,
      Lukas Eder,                Markus Rydh,                 Julien Ponge,
      Pete Muir,                 Nicolas Leroux,              Brett Cannon,
      Geoffrey De Smet,          Guillaume Lours,             Gunnar Morling,
      Jeff Parsons,              Jesse Sightler,              Oleg Kulikov,
      Raimund Klein,             Sergej Koščejev,             Chris Marshall,
      Simon Thum,                Maia Kozheva,                Shelby,
      Aslak Knutsen,             Fabien Meurisse,             Sjur Bakka,
      Xavier Coulon,             Ari Kast,                    Dan Allen,
      Deniz Türkoglu,            F. Meurisse,                 Jean-Charles Roger,
      Johannes Lehmann,          allentc,                     Nikolay Tsankov,
      Chris Horne,               Gabriel Mirea,               Georg Ragaller,
      Harald Wellmann,           Oliver Gondža,               Stephen Crawley,
      Byron Clark,               Francisco Reverbel,          Jonas Berlin,
      Luke Hutchison,            Nikita Ostroumov,            Santiago Rodriguez,
      Sean Flanigan,             Schalk W. Cronjé,            Colin Bartolome,
      Arsenii A.,                Jordi Sola.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2017/08/21/eclipse-ceylon</id>
    <title>Ceylon to move to the Eclipse Foundation</title>
    <updated>2017-08-21T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2017/08/21/eclipse-ceylon" rel="alternate" type="text/html" />
    <author>
      <name>St&#233;phane &#201;pardaud &amp; Gavin King</name>
    </author>
    <summary>
      
      
      
      
      
      
      
      
      
      
      
      We're very excited to finally announce that Ceylon is moving to the Eclipse Foundation.
      
      As you surely know, Red Hat has been the main sponsor
      of Ceylon over the years, and we're all eternally grateful for this support. It would
      have been simply impossible to kick-start a project of this scope without the backing
      of Red Hat. (Full disclosure: we ourselves are employed by Red Hat.)
      
      The Red Hat brand is a synonym for open-source, quality, and community trust. But we've
      also had a growing fear that the strong association with just one company may have been
      holding back our community. We've always seen this project as...
    </summary>
    <content type="html">
      
      
      &lt;center&gt;
      &lt;p&gt;
      &lt;a href=&quot;https://projects.eclipse.org/proposals/eclipse-ceylon&quot; title=&quot;Eclipse Ceylon&quot;&gt;
      &lt;img src=&quot;https://ceylon-lang.org/images/ceylon-eclipse.png&quot;&gt;&lt;/a&gt;
      &lt;/p&gt;
      &lt;/center&gt;
      
      
      &lt;p&gt;We're very excited to finally announce that Ceylon is moving to the Eclipse Foundation.&lt;/p&gt;
      
      &lt;p&gt;As you surely know, &lt;a href=&quot;http://redhat.com&quot;&gt;Red Hat&lt;/a&gt; has been the &lt;a href=&quot;https://ceylon-lang.org/community/companies/&quot;&gt;main sponsor&lt;/a&gt;
      of Ceylon over the years, and we're all eternally grateful for this support. It would
      have been simply impossible to kick-start a project of this scope without the backing
      of Red Hat. (Full disclosure: we ourselves are employed by Red Hat.)&lt;/p&gt;
      
      &lt;p&gt;The Red Hat brand is a synonym for open-source, quality, and community trust. But we've
      also had a growing fear that the strong association with just one company may have been
      holding back our community. We've always seen this project as &quot;neutral ground&quot;, not as
      a vehicle for the business goals of one company, but we're not sure if the project is
      perceived that way from outside.&lt;/p&gt;
      
      &lt;p&gt;Joining an open source foundation allows us to dispel these doubts, allowing users and
      contributors to see Ceylon as a community project in which they can participate as
      equals and leave their mark.&lt;/p&gt;
      
      &lt;p&gt;Red Hat has had a very positive experience with the
      &lt;a href=&quot;https://eclipse.org/org/foundation/&quot;&gt;Eclipse Foundation&lt;/a&gt;, and we feel that Eclipse is
      the best place for Ceylon. We've already seen how membership of the Eclipse foundation
      has helped other projects which have recently joined. Naturally, Red Hat will continue
      to participate in Ceylon and help it to continue at the forefront of programming
      language innovation.&lt;/p&gt;
      
      &lt;p&gt;This move has now been in the works for several months, since it took time to get all
      the necessary legal approvals, and then the final approval from the Eclipse Foundation
      board. But at last we're ready to make the initial code contribution.&lt;/p&gt;
      
      &lt;p&gt;Head over to the &lt;a href=&quot;https://projects.eclipse.org/proposals/eclipse-ceylon&quot;&gt;Eclipse Ceylon project page&lt;/a&gt;
      and read more about Ceylon at Eclipse.&lt;/p&gt;
      
      &lt;p&gt;Note that we've decided to push out one last binary-compatible release of Ceylon 1.3
      before moving everything over to Eclipse. Due to the rules of the Eclipse Foundation,
      the first release of Eclipse Ceylon won't be binary compatible with Ceylon 1.3, and will
      take some time to prepare.&lt;/p&gt;
      
      &lt;p&gt;Eclipse Ceylon has a great future at the Eclipse Foundation!&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2017/03/03/ceylon-1-3-2</id>
    <title>Ceylon 1.3.2 is now available</title>
    <updated>2017-03-03T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2017/03/03/ceylon-1-3-2" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      
      
      
      
      
      
      
      
      
      
      
      Ceylon 1.3.2 is a significant minor release of
      the Ceylon language, with over 100 issues closed. This
      release introduces Ceylon assemblies, allows you to
      export Ceylon modules as Maven repositories, makes it
      even easier than before to have a mixed Java and Ceylon
      project in Maven, allows string interpolation in
      assertions, and introduces lazy initialization for
      attributes.
      
      This release of Ceylon has been tested with a wide variety
      of Java libraries and frameworks, including:
      
      
      Spring Boot,
      WildFly and WildFly Swarm,
      Hibernate (JPA),
      RESTEasy (JAXB and JAX-RS),
      Weld (CDI) and Guice,
      Eclipse Equinox, Apache Karaf, and Apache Felix (OSGi),
      Spark,
      RxJava
      JOGL (OpenGL), and
      Android.
      
      
      
      Example code demonstrating the use of these frameworks is
      available.
      
      Changes
      
      Enhancements to the language and command-line distribution
      include:
      
      
      Assemblies (.cas...
    </summary>
    <content type="html">
      
      
      &lt;center&gt;
      &lt;p&gt;
      &lt;a href=&quot;https://ceylon-lang.org/download&quot; title=&quot;Download Ceylon&quot;&gt;
      &lt;img src=&quot;https://ceylon-lang.org/images/ceylon-works-with-things@2x.png&quot; style=&quot;box-shadow: 0 0 10px #888&quot; width=&quot;80%&quot;&gt;&lt;/a&gt;
      &lt;/p&gt;
      &lt;/center&gt;
      
      
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;Ceylon 1.3.2&lt;/a&gt; is a significant minor release of
      the Ceylon language, with over &lt;a href=&quot;https://github.com/eclipse/ceylon/issues?q=is%3Aissue+milestone%3A1.3.2+is%3Aclosed&quot;&gt;100 issues&lt;/a&gt; closed. This
      release introduces Ceylon &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/tour/modules/#assembly_archives&quot;&gt;assemblies&lt;/a&gt;, allows you to
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/reference/tool/ceylon/subcommands/ceylon-maven-export.html&quot;&gt;export&lt;/a&gt; Ceylon modules as Maven repositories, makes it
      even easier than before to have a mixed Java and Ceylon
      project in &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/reference/interoperability/maven/&quot;&gt;Maven&lt;/a&gt;, allows string &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/tour/attributes-control-structures/#assertions&quot;&gt;interpolation&lt;/a&gt; in
      assertions, and introduces lazy initialization for
      attributes.&lt;/p&gt;
      
      &lt;p&gt;This release of Ceylon has been tested with a wide variety
      of Java libraries and frameworks, including:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://projects.spring.io/spring-boot/&quot;&gt;Spring Boot&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;WildFly and &lt;a href=&quot;http://wildfly-swarm.io/&quot;&gt;WildFly Swarm&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://hibernate.org&quot;&gt;Hibernate&lt;/a&gt; (JPA),&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://resteasy.jboss.org/&quot;&gt;RESTEasy&lt;/a&gt; (JAXB and JAX-RS),&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://weld.cdi-spec.org/&quot;&gt;Weld&lt;/a&gt; (CDI) and &lt;a href=&quot;https://github.com/google/guice&quot;&gt;Guice&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;Eclipse Equinox, Apache Karaf, and Apache Felix (OSGi),&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://sparkjava.com/&quot;&gt;Spark&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxJava/&quot;&gt;RxJava&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://jogamp.org/&quot;&gt;JOGL&lt;/a&gt; (OpenGL), and&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://ceylon-lang.org/blog/2016/06/02/ceylon-on-android&quot;&gt;Android&lt;/a&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Example code demonstrating the use of these frameworks is
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/examples&quot;&gt;available&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Changes&lt;/h3&gt;
      
      &lt;p&gt;Enhancements to the language and command-line distribution
      include:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Assemblies (&lt;code&gt;.cas&lt;/code&gt; archives)&lt;/li&gt;
      &lt;li&gt;Generate Maven repository&lt;/li&gt;
      &lt;li&gt;Support for mixed Java and Ceylon module projects in Maven&lt;/li&gt;
      &lt;li&gt;String interpolation in &lt;code&gt;assert&lt;/code&gt; messages&lt;/li&gt;
      &lt;li&gt;Lazy initialization for attributes marked &lt;code&gt;late&lt;/code&gt;
      &lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;The most notable issues representing those changes are:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/6712&quot;&gt;#6712&lt;/a&gt;,
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/6927&quot;&gt;#6927&lt;/a&gt;,
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/6929&quot;&gt;#6929&lt;/a&gt;
      assembly support — &lt;code&gt;ceylon assemble&lt;/code&gt; and &lt;code&gt;.cas&lt;/code&gt;
      archives&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/6856&quot;&gt;#6856&lt;/a&gt;,
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/6847&quot;&gt;#6847&lt;/a&gt;
      &lt;code&gt;ceylon maven-export&lt;/code&gt; to assemble a Maven repo from list
      of Ceylon modules&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/6872&quot;&gt;#6872&lt;/a&gt;,
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/6853&quot;&gt;#6853&lt;/a&gt;,
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/6875&quot;&gt;#6875&lt;/a&gt;
      syntax for specifying maven group/artifact ids and npm
      module names&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/3692&quot;&gt;#3692&lt;/a&gt;
      string interpolation in &lt;code&gt;assert&lt;/code&gt;ion failure messages&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/3544&quot;&gt;#3544&lt;/a&gt;
      attribute lazy initialization&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/6721&quot;&gt;#6721&lt;/a&gt;
      allow &lt;code&gt;late&lt;/code&gt; attributes in declaration section&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/6804&quot;&gt;#6804&lt;/a&gt;
      much better return type for &lt;code&gt;Iterable.sequence()&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/6797&quot;&gt;#6797&lt;/a&gt;
      named constructors to create Java arrays with streams
      of elements&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/6784&quot;&gt;#6784&lt;/a&gt;,
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/6778&quot;&gt;#6778&lt;/a&gt;
      static methods for &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, and &lt;code&gt;String&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/2324&quot;&gt;#2324&lt;/a&gt;
      add annotations to &lt;code&gt;java.lang&lt;/code&gt; for Java modifiers&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/eclipse/ceylon/issues/6735&quot;&gt;#6735&lt;/a&gt;
      add &lt;code&gt;--exclude-module&lt;/code&gt; option to &lt;code&gt;ceylon copy&lt;/code&gt;
      &lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Naturally, the release incorporates many more bugfixes and
      minor enhancements.&lt;/p&gt;
      
      &lt;h3&gt;IDE Changes&lt;/h3&gt;
      
      &lt;p&gt;Ceylon IDE 1.3.2 for &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/ide/intellij/features&quot;&gt;IntelliJ&lt;/a&gt; and
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/ide/eclipse/features&quot;&gt;Eclipse&lt;/a&gt; resolves more than
      60 issues, and adds several new features, including support
      for running as a &lt;code&gt;fat-jar&lt;/code&gt; and an improved formatter in IntelliJ.&lt;/p&gt;
      
      &lt;center&gt;
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download&quot; title=&quot;Download Ceylon&quot;&gt;
      &lt;img src=&quot;https://ceylon-lang.org/images/screenshots/1.3.1/intellij-swarm.png&quot; style=&quot;box-shadow: 0 0 10px #888&quot; width=&quot;60%&quot;&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/center&gt;
      
      
      &lt;h3&gt;SDK Changes&lt;/h3&gt;
      
      &lt;p&gt;Exactly &lt;a href=&quot;https://github.com/eclipse/ceylon-sdk/issues?q=is%3Aissue+milestone%3A1.3.2+is%3Aclosed&quot;&gt;6 issues&lt;/a&gt; affecting the Ceylon SDK have been
      fixed. New 1.3.2
      releases of the platform modules are available in &lt;a href=&quot;https://herd.ceylon-lang.org&quot;&gt;Herd&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Migration&lt;/h3&gt;
      
      &lt;ul&gt;
      &lt;li&gt;&lt;p&gt;For the JVM, this release is backwards-compatible with all
      previous releases of Ceylon since 1.2.0.&lt;/p&gt;&lt;/li&gt;
      &lt;li&gt;&lt;p&gt;For JavaScript, this release is backwards-compatible only
      with the previous two releases (1.2.2 and 1.3.0).&lt;/p&gt;&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Ceylon 1.3.2 is backward-compatible with Ceylon 1.3.0, and
      so it's not necessary to recompile or change dependencies.
      However, upgrading to version 1.3.2 of any Ceylon platform
      module is recommended.&lt;/p&gt;
      
      &lt;h2&gt;About Ceylon&lt;/h2&gt;
      
      &lt;p&gt;Ceylon is a modern, modular, statically typed programming
      language for the Java and JavaScript virtual machines. The
      language features a flexible and very readable syntax, a
      unique and uncommonly elegant static type system, a powerful
      module architecture, and excellent tooling, including an
      awesome IDE supporting both IntelliJ IDEA and the Eclipse
      platform.&lt;/p&gt;
      
      &lt;p&gt;Ceylon enables the development of cross-platform modules
      that execute portably in both virtual machine environments.
      Alternatively, a Ceylon module may target one or the other
      platform, in which case it may interoperate with native code
      written for that platform.&lt;/p&gt;
      
      &lt;h3&gt;In the box&lt;/h3&gt;
      
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;This release&lt;/a&gt; includes:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;a complete &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/spec&quot;&gt;language specification&lt;/a&gt; that defines the
      syntax and semantics of Ceylon in language accessible to
      the professional developer,&lt;/li&gt;
      &lt;li&gt;a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/reference/tool/ceylon/subcommands/index.html&quot;&gt;command line toolset&lt;/a&gt; including compilers for
      Java and JavaScript, a documentation compiler, a test
      runner, a WAR archive packager, a &quot;fat&quot; JAR packager, and
      support for executing modular programs on the JVM and
      Node.js,&lt;/li&gt;
      &lt;li&gt;a powerful module architecture for code organization,
      dependency management, and module isolation at runtime,
      which also supports interoperation with OSGi, Jigsaw,
      Maven, and npm, and&lt;/li&gt;
      &lt;li&gt;the &lt;a href=&quot;https://herd.ceylon-lang.org/modules/ceylon.language&quot;&gt;language module&lt;/a&gt;, our minimal,
      cross-platform, foundation-level API.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Available separately:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;updated versions of the platform modules that comprise the
      &lt;a href=&quot;https://modules.ceylon-lang.org/categories/SDK&quot;&gt;Ceylon SDK&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;a plugin for the &lt;code&gt;ceylon&lt;/code&gt; command that supports
      &lt;a href=&quot;https://github.com/jvasileff/ceylon-dart&quot;&gt;compilation and execution for the Dart VM&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;a plugin &lt;a href=&quot;https://github.com/eclipse/ceylon.swarm&quot;&gt;packager&lt;/a&gt; for &lt;a href=&quot;http://wildfly-swarm.io/&quot;&gt;WildFly Swarm&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;a plugin code &lt;a href=&quot;https://github.com/eclipse/ceylon.formatter&quot;&gt;formatter&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;two full-featured integrated development environments: for
      Eclipse and IntelliJ IDEA, and&lt;/li&gt;
      &lt;li&gt;a plugin for &lt;a href=&quot;https://github.com/jvasileff/vscode-ceylon&quot;&gt;Visual Studio Code&lt;/a&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;h3&gt;Language&lt;/h3&gt;
      
      &lt;p&gt;Ceylon is a highly understandable object-oriented language
      with static typing. The language features:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;an emphasis upon &lt;strong&gt;readability&lt;/strong&gt; and a strong bias toward
      &lt;strong&gt;omission or elimination of potentially-harmful or
      potentially-ambiguous constructs&lt;/strong&gt; and toward highly
      &lt;strong&gt;disciplined use of static types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;an extremely powerful and uncommonly elegant type system
      combining subtype and parametric polymorphism with:
      
      &lt;ul&gt;
      &lt;li&gt;first-class &lt;strong&gt;union and intersection types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;both &lt;strong&gt;declaration-site and use-site variance&lt;/strong&gt;, and&lt;/li&gt;
      &lt;li&gt;the use of principal types for &lt;strong&gt;local type inference&lt;/strong&gt;
      and &lt;strong&gt;flow-sensitive typing&lt;/strong&gt;,&lt;/li&gt;
      &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;a unique treatment of &lt;strong&gt;function and tuple types&lt;/strong&gt;,
      enabling powerful abstractions, along with the most
      &lt;strong&gt;elegant approach to &lt;code&gt;null&lt;/code&gt;&lt;/strong&gt; of any modern language,&lt;/li&gt;
      &lt;li&gt;first-class constructs for defining &lt;strong&gt;modules and
      dependencies between modules&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;a very flexible syntax including &lt;strong&gt;comprehensions&lt;/strong&gt; and
      support for expressing &lt;strong&gt;tree-like structures&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;fully-reified generic types&lt;/strong&gt;, on both the JVM and
      JavaScript virtual machines, and a unique &lt;strong&gt;typesafe
      metamodel&lt;/strong&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;More information about these language features may be
      found in the &lt;a href=&quot;https://ceylon-lang.org/features&quot;&gt;feature list&lt;/a&gt; and
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/introduction/&quot;&gt;quick introduction&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Community&lt;/h3&gt;
      
      &lt;p&gt;The Ceylon community site, &lt;a href=&quot;https://ceylon-lang.org&quot;&gt;https://ceylon-lang.org&lt;/a&gt;, includes
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3&quot;&gt;documentation&lt;/a&gt;, and information about
      &lt;a href=&quot;https://ceylon-lang.org/community&quot;&gt;getting involved&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;You can follow &lt;a href=&quot;https://twitter.com/ceylonlang&quot;&gt;@ceylonlang&lt;/a&gt; on Twitter.&lt;/p&gt;
      
      &lt;h3&gt;Source code&lt;/h3&gt;
      
      &lt;p&gt;The source code for Ceylon, its specification, and its website,
      is freely available from &lt;a href=&quot;https://github.com/eclipse&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;Information about Ceylon's open source licenses is available
      &lt;a href=&quot;https://ceylon-lang.org/code/licenses/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Issues&lt;/h3&gt;
      
      &lt;p&gt;Bugs and suggestions may be reported in GitHub's
      &lt;a href=&quot;https://ceylon-lang.org/code/issues&quot;&gt;issue tracker&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Acknowledgement&lt;/h2&gt;
      
      &lt;p&gt;As always, we're deeply grateful to the community volunteers
      who contributed a substantial part of the current Ceylon
      codebase, working in their own spare time. The following
      people have contributed to Ceylon:&lt;/p&gt;
      
      &lt;p&gt;Gavin King,                Stéphane Épardaud,           Tako Schotanus,
      Tom Bentley,               David Festal,                Enrique Zamudio,
      Bastien Jansen,            Emmanuel Bernard,            Aleš Justin,
      Tomáš Hradec,              James Cobb,                  Ross Tate,
      Max Rydahl Andersen,       Mladen Turk,                 Lucas Werkmeister,
      Roland Tepp,               Diego Coronel,               Matej Lazar,
      John Vasileff,             Toby Crawley,                Julien Viet,
      Loic Rouchon,              Stephane Gallès,             Ivo Kasiuk,
      Corbin Uselton,            Paco Soberón,                Michael Musgrove,
      Daniel Rochetti,           Henning Burdack,             Luke deGruchy,
      Rohit Mohan,               Griffin DeJohn,              Casey Dahlin,
      Gilles Duboscq,            Tomasz Krakowiak,            Alexander Altman,
      Alexander Zolotko,         Alex Szczuczko,              Andrés G. Aragoneses,
      Anh Nhan Nguyen,           Brice Dutheil,               Carlos Augusto Mar,
      Charles Gould,             Chris Gregory,               klinger,
      Martin Voelkle,            Mr. Arkansas,                Paŭlo Ebermann,
      Vorlent,                   Akber Choudhry,              Renato Athaydes,
      Flavio Oliveri,            Michael Brackx,              Brent Douglas,
      Lukas Eder,                Markus Rydh,                 Julien Ponge,
      Pete Muir,                 Nicolas Leroux,              Brett Cannon,
      Geoffrey De Smet,          Guillaume Lours,             Gunnar Morling,
      Jeff Parsons,              Jesse Sightler,              Oleg Kulikov,
      Raimund Klein,             Sergej Koščejev,             Chris Marshall,
      Simon Thum,                Maia Kozheva,                Shelby,
      Aslak Knutsen,             Fabien Meurisse,             Sjur Bakka,
      Xavier Coulon,             Ari Kast,                    Dan Allen,
      Deniz Türkoglu,            F. Meurisse,                 Jean-Charles Roger,
      Johannes Lehmann,          allentc,                     Nikolay Tsankov,
      Chris Horne,               Gabriel Mirea,               Georg Ragaller,
      Harald Wellmann,           Oliver Gondža,               Stephen Crawley,
      Byron Clark,               Francisco Reverbel,          Jonas Berlin,
      Luke Hutchison,            Nikita Ostroumov,            Santiago Rodriguez,
      Sean Flanigan,             Schalk W. Cronjé.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2016/11/22/ceylon-1-3-1</id>
    <title>Ceylon 1.3.1 is now available</title>
    <updated>2016-11-22T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2016/11/22/ceylon-1-3-1" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      
      
      
      
      
      
      
      
      
      
      
      Ceylon 1.3.1 is a significant minor release of
      the Ceylon language, with over 140 issues closed. This
      is the first release of Ceylon which supports interoperation
      with Java 8 lambdas and streams, with RxJava, and
      with Spring Boot. This release also introduces support
      for static members.
      
      This release of Ceylon has been tested with a wide variety
      of Java libraries and frameworks, including:
      
      
      Spring Boot,
      WildFly and WildFly Swarm,
      Hibernate (JPA),
      RESTEasy (JAXB and JAX-RS),
      Weld (CDI) and Guice,
      Eclipse Equinox, Apache Karaf, and Apache Felix (OSGi),
      Spark,
      RxJava
      JOGL (OpenGL), and
      Android.
      
      
      
      Example code demonstrating the use of these frameworks is
      available.
      
      Compared to previous releases of Ceylon, the use of Java
      frameworks based on reflection is now much more...
    </summary>
    <content type="html">
      
      
      &lt;center&gt;
      &lt;p&gt;
      &lt;a href=&quot;https://ceylon-lang.org/download&quot; title=&quot;Download Ceylon&quot;&gt;
      &lt;img src=&quot;https://ceylon-lang.org/images/ceylon-works-with-things@2x.png&quot; style=&quot;box-shadow: 0 0 10px #888&quot; width=&quot;80%&quot;&gt;&lt;/a&gt;
      &lt;/p&gt;
      &lt;/center&gt;
      
      
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;Ceylon 1.3.1&lt;/a&gt; is a significant minor release of
      the Ceylon language, with over &lt;a href=&quot;https://github.com/eclipse/ceylon/issues?q=is%3Aissue+milestone%3A1.3.1+is%3Aclosed&quot;&gt;140 issues&lt;/a&gt; closed. This
      is the first release of Ceylon which supports interoperation
      with Java 8 lambdas and &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html&quot;&gt;streams&lt;/a&gt;, with &lt;a href=&quot;https://github.com/ReactiveX/RxJava/&quot;&gt;RxJava&lt;/a&gt;, and
      with &lt;a href=&quot;https://projects.spring.io/spring-boot/&quot;&gt;Spring Boot&lt;/a&gt;. This release also introduces support
      for &lt;a href=&quot;https://ceylon-lang.org/documentation/tour/initialization/#static_members&quot;&gt;&lt;code&gt;static&lt;/code&gt; members&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;This release of Ceylon has been tested with a wide variety
      of Java libraries and frameworks, including:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://projects.spring.io/spring-boot/&quot;&gt;Spring Boot&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;WildFly and &lt;a href=&quot;http://wildfly-swarm.io/&quot;&gt;WildFly Swarm&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://hibernate.org&quot;&gt;Hibernate&lt;/a&gt; (JPA),&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://resteasy.jboss.org/&quot;&gt;RESTEasy&lt;/a&gt; (JAXB and JAX-RS),&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://weld.cdi-spec.org/&quot;&gt;Weld&lt;/a&gt; (CDI) and &lt;a href=&quot;https://github.com/google/guice&quot;&gt;Guice&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;Eclipse Equinox, Apache Karaf, and Apache Felix (OSGi),&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://sparkjava.com/&quot;&gt;Spark&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxJava/&quot;&gt;RxJava&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://jogamp.org/&quot;&gt;JOGL&lt;/a&gt; (OpenGL), and&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://ceylon-lang.org/blog/2016/06/02/ceylon-on-android&quot;&gt;Android&lt;/a&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Example code demonstrating the use of these frameworks is
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/examples&quot;&gt;available&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;Compared to previous releases of Ceylon, the use of Java
      frameworks based on reflection is now much more transparent,
      and integration with multi-module Maven-based platforms and
      frameworks is now much easier to configure.&lt;/p&gt;
      
      &lt;p&gt;The Ceylon &lt;a href=&quot;https://ceylon-lang.org/documentation/tour&quot;&gt;tour&lt;/a&gt; has been extensively updated, especially
      the sections addressing interoperation with native
      &lt;a href=&quot;https://ceylon-lang.org/documentation/tour/interop/&quot;&gt;Java&lt;/a&gt; and &lt;a href=&quot;https://ceylon-lang.org/documentation/tour/dynamic/&quot;&gt;JavaScript&lt;/a&gt;,
      and with the &lt;a href=&quot;https://ceylon-lang.org/documentation/tour/modules/&quot;&gt;module system&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Changes&lt;/h3&gt;
      
      &lt;p&gt;Enhancements to the language and command-line distribution
      include:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://ceylon-lang.org/documentation/tour/initialization/#static_members&quot;&gt;&lt;code&gt;static&lt;/code&gt; members&lt;/a&gt; in Ceylon classes&lt;/li&gt;
      &lt;li&gt;interoperation with Java 8 lambdas—ability to pass
      &lt;a href=&quot;https://ceylon-lang.org/documentation/tour/interop/#methods_accepting_a_sam_interface&quot;&gt;Ceylon functions to Java SAM types&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://ceylon-lang.org/documentation/tour/modules/#tip_local_import_statements&quot;&gt;local &lt;code&gt;import&lt;/code&gt;&lt;/a&gt; statements&lt;/li&gt;
      &lt;li&gt;support for spread operators &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;*.&lt;/code&gt; with
      &lt;code&gt;java.lang.Iterable&lt;/code&gt; and Java arrays&lt;/li&gt;
      &lt;li&gt;literal &lt;a href=&quot;https://ceylon-lang.org/documentation/reference/statement/switch/#_case_with_tuples&quot;&gt;tuples in &lt;code&gt;case&lt;/code&gt;s&lt;/a&gt; of a &lt;code&gt;switch&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://ceylon-lang.org/documentation/tour/interop/#tip_using_the_small_annotation&quot;&gt;&lt;code&gt;small Character&lt;/code&gt;s&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;new Maven interop mode &lt;code&gt;--fully-export-maven-dependencies&lt;/code&gt;
      for projects depending on multi-module platforms like
      Spring Boot&lt;/li&gt;
      &lt;li&gt;support for POM-only Maven artifacts&lt;/li&gt;
      &lt;li&gt;new &lt;a href=&quot;https://ceylon-lang.org/documentation/tour/interop/#java_ee_and_other_annotation_driven_frameworks&quot;&gt;Java EE-friendly compiler mode&lt;/a&gt;, making it
      easy to use Java frameworks that depend on reflective
      direct access to fields&lt;/li&gt;
      &lt;li&gt;ability to pass Ceylon metamodel to Java methods accepting
      &lt;code&gt;java.lang.Class&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;ability to pass Ceylon strings to Java methods accepting
      &lt;code&gt;java.lang.CharSequence&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://ceylon-lang.org/documentation/tour/interop/#null_return_values_are_checked_at_runtime&quot;&gt;improved treatment of &lt;code&gt;null&lt;/code&gt; values&lt;/a&gt;
      originating in calls to native Java&lt;/li&gt;
      &lt;li&gt;several bugfixes to relating to interop with overloaded
      Java methods&lt;/li&gt;
      &lt;li&gt;new command line options: &lt;code&gt;--java&lt;/code&gt;, &lt;code&gt;--incremental&lt;/code&gt;, and
      &lt;code&gt;--include-dependencies&lt;/code&gt;
      &lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Naturally, the release incorporates many more bugfixes and
      minor enhancements.&lt;/p&gt;
      
      &lt;h3&gt;IDE Changes&lt;/h3&gt;
      
      &lt;p&gt;Ceylon IDE 1.3.1 for &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/ide/intellij/features&quot;&gt;IntelliJ&lt;/a&gt; and
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/ide/eclipse/features&quot;&gt;Eclipse&lt;/a&gt; resolves more than
      &lt;a href=&quot;https://github.com/eclipse/ceylon-ide-eclipse/issues?q=is%3Aissue+milestone%3A1.3.1+is%3Aclosed&quot;&gt;110 issues&lt;/a&gt;, and adds support for running and debugging
      Ceylon programs on &lt;a href=&quot;http://wildfly-swarm.io/&quot;&gt;WildFly Swarm&lt;/a&gt;.&lt;/p&gt;
      
      &lt;center&gt;
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download&quot; title=&quot;Download Ceylon&quot;&gt;
      &lt;img src=&quot;https://ceylon-lang.org/images/screenshots/1.3.1/intellij-swarm.png&quot; style=&quot;box-shadow: 0 0 10px #888&quot; width=&quot;60%&quot;&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/center&gt;
      
      
      &lt;h3&gt;SDK Changes&lt;/h3&gt;
      
      &lt;p&gt;Exactly &lt;a href=&quot;https://github.com/eclipse/ceylon-sdk/issues?q=is%3Aissue+milestone%3A1.3.1+is%3Aclosed&quot;&gt;15 issues&lt;/a&gt; affecting the Ceylon SDK have been
      fixed, and the new platform modules &lt;code&gt;ceylon.interop.spring&lt;/code&gt;
      and &lt;code&gt;ceylon.interop.persistence&lt;/code&gt; were introduced. New 1.3.1
      releases of the platform modules are available in &lt;a href=&quot;https://herd.ceylon-lang.org&quot;&gt;Herd&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Migration&lt;/h3&gt;
      
      &lt;ul&gt;
      &lt;li&gt;&lt;p&gt;For the JVM, this release is backwards-compatible with all
      previous releases of Ceylon since 1.2.0.&lt;/p&gt;&lt;/li&gt;
      &lt;li&gt;&lt;p&gt;For JavaScript, this release is backwards-compatible only
      with the previous two releases (1.2.2 and 1.3.0).&lt;/p&gt;&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Ceylon 1.3.1 is backward-compatible with Ceylon 1.3.0, and
      so it's not necessary to recompile or change dependencies.
      However, upgrading to version 1.3.1 of any Ceylon platform
      module is recommended.&lt;/p&gt;
      
      &lt;h2&gt;About Ceylon&lt;/h2&gt;
      
      &lt;p&gt;Ceylon is a modern, modular, statically typed programming
      language for the Java and JavaScript virtual machines. The
      language features a flexible and very readable syntax, a
      unique and uncommonly elegant static type system, a powerful
      module architecture, and excellent tooling, including an
      awesome IDE supporting both IntelliJ IDEA and the Eclipse
      platform.&lt;/p&gt;
      
      &lt;p&gt;Ceylon enables the development of cross-platform modules
      that execute portably in both virtual machine environments.
      Alternatively, a Ceylon module may target one or the other
      platform, in which case it may interoperate with native code
      written for that platform.&lt;/p&gt;
      
      &lt;h3&gt;In the box&lt;/h3&gt;
      
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;This release&lt;/a&gt; includes:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;a complete &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/spec&quot;&gt;language specification&lt;/a&gt; that defines the
      syntax and semantics of Ceylon in language accessible to
      the professional developer,&lt;/li&gt;
      &lt;li&gt;a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/reference/tool/ceylon/subcommands/index.html&quot;&gt;command line toolset&lt;/a&gt; including compilers for
      Java and JavaScript, a documentation compiler, a test
      runner, a WAR archive packager, a &quot;fat&quot; JAR packager, and
      support for executing modular programs on the JVM and
      Node.js,&lt;/li&gt;
      &lt;li&gt;a powerful module architecture for code organization,
      dependency management, and module isolation at runtime,
      which also supports interoperation with OSGi, Jigsaw,
      Maven, and npm, and&lt;/li&gt;
      &lt;li&gt;the &lt;a href=&quot;https://herd.ceylon-lang.org/modules/ceylon.language&quot;&gt;language module&lt;/a&gt;, our minimal,
      cross-platform, foundation-level API.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Available separately:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;updated versions of the platform modules that comprise the
      &lt;a href=&quot;https://modules.ceylon-lang.org/categories/SDK&quot;&gt;Ceylon SDK&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;a plugin for the &lt;code&gt;ceylon&lt;/code&gt; command that supports
      &lt;a href=&quot;https://github.com/jvasileff/ceylon-dart&quot;&gt;compilation and execution for the Dart VM&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;a plugin &lt;a href=&quot;https://github.com/eclipse/ceylon.swarm&quot;&gt;packager&lt;/a&gt; for &lt;a href=&quot;http://wildfly-swarm.io/&quot;&gt;WildFly Swarm&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;a plugin code &lt;a href=&quot;https://github.com/eclipse/ceylon.formatter&quot;&gt;formatter&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;two full-featured integrated development environments: for
      Eclipse and IntelliJ IDEA, and&lt;/li&gt;
      &lt;li&gt;a plugin for &lt;a href=&quot;https://github.com/jvasileff/vscode-ceylon&quot;&gt;Visual Studio Code&lt;/a&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;h3&gt;Language&lt;/h3&gt;
      
      &lt;p&gt;Ceylon is a highly understandable object-oriented language
      with static typing. The language features:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;an emphasis upon &lt;strong&gt;readability&lt;/strong&gt; and a strong bias toward
      &lt;strong&gt;omission or elimination of potentially-harmful or
      potentially-ambiguous constructs&lt;/strong&gt; and toward highly
      &lt;strong&gt;disciplined use of static types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;an extremely powerful and uncommonly elegant type system
      combining subtype and parametric polymorphism with:
      
      &lt;ul&gt;
      &lt;li&gt;first-class &lt;strong&gt;union and intersection types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;both &lt;strong&gt;declaration-site and use-site variance&lt;/strong&gt;, and&lt;/li&gt;
      &lt;li&gt;the use of principal types for &lt;strong&gt;local type inference&lt;/strong&gt;
      and &lt;strong&gt;flow-sensitive typing&lt;/strong&gt;,&lt;/li&gt;
      &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;a unique treatment of &lt;strong&gt;function and tuple types&lt;/strong&gt;,
      enabling powerful abstractions, along with the most
      &lt;strong&gt;elegant approach to &lt;code&gt;null&lt;/code&gt;&lt;/strong&gt; of any modern language,&lt;/li&gt;
      &lt;li&gt;first-class constructs for defining &lt;strong&gt;modules and
      dependencies between modules&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;a very flexible syntax including &lt;strong&gt;comprehensions&lt;/strong&gt; and
      support for expressing &lt;strong&gt;tree-like structures&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;fully-reified generic types&lt;/strong&gt;, on both the JVM and
      JavaScript virtual machines, and a unique &lt;strong&gt;typesafe
      metamodel&lt;/strong&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;More information about these language features may be
      found in the &lt;a href=&quot;https://ceylon-lang.org/features&quot;&gt;feature list&lt;/a&gt; and
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/introduction/&quot;&gt;quick introduction&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Community&lt;/h3&gt;
      
      &lt;p&gt;The Ceylon community site, &lt;a href=&quot;https://ceylon-lang.org&quot;&gt;https://ceylon-lang.org&lt;/a&gt;, includes
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3&quot;&gt;documentation&lt;/a&gt;, and information about
      &lt;a href=&quot;https://ceylon-lang.org/community&quot;&gt;getting involved&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;You can follow &lt;a href=&quot;https://twitter.com/ceylonlang&quot;&gt;@ceylonlang&lt;/a&gt; on Twitter.&lt;/p&gt;
      
      &lt;h3&gt;Source code&lt;/h3&gt;
      
      &lt;p&gt;The source code for Ceylon, its specification, and its website,
      is freely available from &lt;a href=&quot;https://github.com/eclipse&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;Information about Ceylon's open source licenses is available
      &lt;a href=&quot;https://ceylon-lang.org/code/licenses/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Issues&lt;/h3&gt;
      
      &lt;p&gt;Bugs and suggestions may be reported in GitHub's
      &lt;a href=&quot;https://ceylon-lang.org/code/issues&quot;&gt;issue tracker&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Acknowledgement&lt;/h2&gt;
      
      &lt;p&gt;As always, we're deeply grateful to the community volunteers
      who contributed a substantial part of the current Ceylon
      codebase, working in their own spare time. The following
      people have contributed to Ceylon:&lt;/p&gt;
      
      &lt;p&gt;Gavin King,                Stéphane Épardaud,           Tako Schotanus,
      Tom Bentley,               David Festal,                Enrique Zamudio,
      Bastien Jansen,            Emmanuel Bernard,            Aleš Justin,
      Tomáš Hradec,              James Cobb,                  Ross Tate,
      Max Rydahl Andersen,       Mladen Turk,                 Lucas Werkmeister,
      Roland Tepp,               Diego Coronel,               Matej Lazar,
      John Vasileff,             Toby Crawley,                Julien Viet,
      Loic Rouchon,              Stephane Gallès,             Ivo Kasiuk,
      Corbin Uselton,            Paco Soberón,                Michael Musgrove,
      Daniel Rochetti,           Henning Burdack,             Luke deGruchy,
      Rohit Mohan,               Griffin DeJohn,              Casey Dahlin,
      Gilles Duboscq,            Tomasz Krakowiak,            Alexander Altman,
      Alexander Zolotko,         Alex Szczuczko,              Andrés G. Aragoneses,
      Anh Nhan Nguyen,           Brice Dutheil,               Carlos Augusto Mar,
      Charles Gould,             Chris Gregory,               klinger,
      Martin Voelkle,            Mr. Arkansas,                Paŭlo Ebermann,
      Vorlent,                   Akber Choudhry,              Renato Athaydes,
      Flavio Oliveri,            Michael Brackx,              Brent Douglas,
      Lukas Eder,                Markus Rydh,                 Julien Ponge,
      Pete Muir,                 Nicolas Leroux,              Brett Cannon,
      Geoffrey De Smet,          Guillaume Lours,             Gunnar Morling,
      Jeff Parsons,              Jesse Sightler,              Oleg Kulikov,
      Raimund Klein,             Sergej Koščejev,             Chris Marshall,
      Simon Thum,                Maia Kozheva,                Shelby,
      Aslak Knutsen,             Fabien Meurisse,             Sjur Bakka,
      Xavier Coulon,             Ari Kast,                    Dan Allen,
      Deniz Türkoglu,            F. Meurisse,                 Jean-Charles Roger,
      Johannes Lehmann,          allentc,                     Nikolay Tsankov,
      Chris Horne,               Gabriel Mirea,               Georg Ragaller,
      Harald Wellmann,           Oliver Gondža,               Stephen Crawley,
      Byron Clark,               Francisco Reverbel,          Jonas Berlin,
      Luke Hutchison,            Nikita Ostroumov,            Santiago Rodriguez,
      Sean Flanigan,             Schalk W. Cronjé.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2016/09/19/ceylon-1-3-0</id>
    <title>Ceylon 1.3.0 is now available</title>
    <updated>2016-09-19T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2016/09/19/ceylon-1-3-0" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      
      
      
      
      
      
      
      
      
      
      
      Ceylon 1.3.0 is a major release of the Ceylon
      language, with over 330 issues closed. This is the first
      release of Ceylon which supports Android development,
      the Node Package Manager (npm), and Wildfly Swarm.
      
      
      For the JVM, this release is backwards-compatible with all
      releases of Ceylon 1.2 (1.2.0 to 1.2.2).
      For JavaScript, this release is backwards-compatible only
      with the previous release (1.2.2).
      
      
      
      Ceylon IDE 1.3.0 is now available for the two leading Java
      development environments:
      
      
      for the very first time, as a plugin
      for IntelliJ IDEA and Android Studio, alongside
      existing support for the
      Eclipse platform.
      
      
      
      
      
      
      
      
      
      
      Ceylon IDE for IntelliJ was designed for high performance
      in large projects with many Java dependencies, and is currently
      the...
    </summary>
    <content type="html">
      
      
      &lt;center&gt;
      &lt;p&gt;
      &lt;a href=&quot;https://ceylon-lang.org/download&quot; title=&quot;Download Ceylon&quot;&gt;
      &lt;img src=&quot;https://ceylon-lang.org/images/ceylon13-android-intellij@2x.png&quot; style=&quot;box-shadow: 0 0 10px #888&quot; width=&quot;80%&quot;&gt;&lt;/a&gt;
      &lt;/p&gt;
      &lt;/center&gt;
      
      
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;Ceylon 1.3.0&lt;/a&gt; is a major release of the Ceylon
      language, with over &lt;a href=&quot;https://github.com/eclipse/ceylon/issues?q=is%3Aissue+milestone%3A1.3.0+is%3Aclosed&quot;&gt;330 issues&lt;/a&gt; closed. This is the first
      release of Ceylon which supports &lt;a href=&quot;https://ceylon-lang.org/blog/2016/06/02/ceylon-on-android&quot;&gt;Android&lt;/a&gt; development,
      the Node Package Manager (&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;), and &lt;a href=&quot;https://github.com/eclipse/ceylon.swarm&quot;&gt;Wildfly Swarm&lt;/a&gt;.&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;&lt;p&gt;For the JVM, this release is backwards-compatible with all
      releases of Ceylon 1.2 (1.2.0 to 1.2.2).&lt;/p&gt;&lt;/li&gt;
      &lt;li&gt;&lt;p&gt;For JavaScript, this release is backwards-compatible only
      with the previous release (1.2.2).&lt;/p&gt;&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Ceylon IDE 1.3.0 is now available for the two leading Java
      development environments:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;for the very first time, as a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/ide/intellij/features&quot;&gt;plugin&lt;/a&gt;
      for &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt; and &lt;a href=&quot;https://developer.android.com/studio/index.html&quot;&gt;Android Studio&lt;/a&gt;, alongside&lt;/li&gt;
      &lt;li&gt;existing &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/ide/eclipse/features&quot;&gt;support&lt;/a&gt; for the
      &lt;a href=&quot;https://www.eclipse.org/&quot;&gt;Eclipse&lt;/a&gt; platform.&lt;/li&gt;
      &lt;/ul&gt;&lt;center&gt;
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download&quot; title=&quot;Download Ceylon&quot;&gt;
      &lt;img src=&quot;https://ceylon-lang.org/images/screenshots/1.3.0/intellij/intellij-darcula.png&quot; style=&quot;box-shadow: 0 0 10px #888&quot; width=&quot;80%&quot;&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/center&gt;
      
      
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/ide/intellij/features&quot;&gt;Ceylon IDE for IntelliJ&lt;/a&gt; was designed for high performance
      in large projects with many Java dependencies, and is currently
      the best-performing IDE for Ceylon.&lt;/p&gt;
      
      &lt;h3&gt;Changes&lt;/h3&gt;
      
      &lt;p&gt;Enhancements to the language and command-line distribution
      include:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;support for developing &lt;a href=&quot;https://ceylon-lang.org/blog/2016/06/02/ceylon-on-android&quot;&gt;Android&lt;/a&gt; applications&lt;/li&gt;
      &lt;li&gt;support for importing modules from &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; and for
      publishing Ceylon modules to npm&lt;/li&gt;
      &lt;li&gt;support for developing microservices with
      &lt;a href=&quot;https://github.com/eclipse/ceylon.swarm&quot;&gt;WildFly Swarm&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;cross-platform &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/tour/interop/#interoperation_with_javas_serviceloader&quot;&gt;services&lt;/a&gt;,
      abstracting the Java service loader&lt;/li&gt;
      &lt;li&gt;addition of the
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/reference/tool/ceylon/subcommands/ceylon-fat-jar.html&quot;&gt;&lt;code&gt;fat-jar&lt;/code&gt;&lt;/a&gt;
      tool for packaging a Ceylon program and its dependencies
      into a single assembly&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://ceylon-lang.org/blog/2016/07/04/modularity-changes&quot;&gt;&lt;em&gt;much&lt;/em&gt; slimmer runtime&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/tour/functions/#destructuring_anonymous_function_parameters&quot;&gt;destructuring for parameters of anonymous functions&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;destructuring in &lt;code&gt;case&lt;/code&gt;s of a &lt;code&gt;switch&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;addition of the &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/reference/operator/lookup-assign/&quot;&gt;&lt;code&gt;CorrespondenceMutator&lt;/code&gt;&lt;/a&gt; interface&lt;/li&gt;
      &lt;li&gt;addition of &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/language/1.3.0/module-doc/api/Collection.type.html#combinations&quot;&gt;&lt;code&gt;Collection.combinations()&lt;/code&gt;&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/language/1.3.0/module-doc/api/index.html#small&quot;&gt;&lt;code&gt;small&lt;/code&gt;&lt;/a&gt;
      and &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/language/1.3.0/module-doc/api/index.html#since&quot;&gt;&lt;code&gt;since&lt;/code&gt;&lt;/a&gt;
      annotations&lt;/li&gt;
      &lt;li&gt;many minor improvements to interoperation with Java&lt;/li&gt;
      &lt;li&gt;experimental support for &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/package-summary.html&quot;&gt;Java APT processors&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;improved behavior for &lt;code&gt;is&lt;/code&gt; tests with generic Java types&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/tour/interop/#java_types_annotated_nullable_are_exposed_as_optional_types&quot;&gt;correct typing&lt;/a&gt;
      for things annotated &lt;code&gt;@Nullable&lt;/code&gt;/&lt;code&gt;@NotNull&lt;/code&gt; in Java&lt;/li&gt;
      &lt;li&gt;full support for Java 8&lt;/li&gt;
      &lt;li&gt;reduced typechecker memory footprint&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Naturally, the release incorporates many more bugfixes,
      minor enhancements, and performance improvements.&lt;/p&gt;
      
      &lt;h3&gt;Support for Docker&lt;/h3&gt;
      
      &lt;p&gt;&lt;a href=&quot;https://hub.docker.com/u/ceylon/&quot;&gt;Docker images for Ceylon&lt;/a&gt;
      are now available, making it very easy to run Ceylon programs
      in a Docker container.&lt;/p&gt;
      
      &lt;h3&gt;IDE Changes&lt;/h3&gt;
      
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/ide/intellij/features&quot;&gt;Ceylon IDE for IntelliJ&lt;/a&gt; is a brand-new development tool for
      IntelliJ IDEA and Android Studio, featuring incremental error
      reporting, code completion, basic refactoring,
      many intention actions, sophisticated navigation, searching,
      type hierarchy and file structure, online documentation,
      full integration with &lt;a href=&quot;https://herd.ceylon-lang.org&quot;&gt;Ceylon Herd&lt;/a&gt; and much, much more.&lt;/p&gt;
      
      &lt;p&gt;Ceylon IDE for IntelliJ is written mostly in Ceylon, and
      reuses the &lt;a href=&quot;https://github.com/eclipse/ceylon-ide-common&quot;&gt;Ceylon IDE Common&lt;/a&gt; project, the core of
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/ide/eclipse/features&quot;&gt;Ceylon IDE for Eclipse&lt;/a&gt;, which was completely rewritten
      in Ceylon.&lt;/p&gt;
      
      &lt;p&gt;Almost &lt;a href=&quot;https://github.com/eclipse/ceylon-ide-eclipse/issues?q=is%3Aissue+milestone%3A1.3.0+is%3Aclosed&quot;&gt;60 issues&lt;/a&gt; were fixed in &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/ide/eclipse/features&quot;&gt;Ceylon IDE for Eclipse&lt;/a&gt;,
      and code completion was redesigned around a non-blocking
      approach which is &lt;em&gt;much&lt;/em&gt; more responsive in large projects.
      In addition, improvements to the typechecker have resulted
      in significantly lower memory usage.&lt;/p&gt;
      
      &lt;h3&gt;SDK Changes&lt;/h3&gt;
      
      &lt;p&gt;Exactly &lt;a href=&quot;https://github.com/eclipse/ceylon-sdk/issues?q=is%3Aissue+milestone%3A1.3.0+is%3Aclosed&quot;&gt;40 issues&lt;/a&gt; affecting the Ceylon SDK have been fixed.&lt;/p&gt;
      
      &lt;h3&gt;Migration from Ceylon 1.2.2&lt;/h3&gt;
      
      &lt;p&gt;Ceylon 1.3.0 is backward-compatible with Ceylon 1.2.2, and
      so it's not necessary to recompile or change dependencies.
      However, upgrading to version 1.3.0 of any Ceylon platform
      module is recommended.&lt;/p&gt;
      
      &lt;h2&gt;About Ceylon&lt;/h2&gt;
      
      &lt;p&gt;Ceylon is a modern, modular, statically typed programming
      language for the Java and JavaScript virtual machines. The
      language features a flexible and very readable syntax, a
      unique and uncommonly elegant static type system, a powerful
      module architecture, and excellent tooling, including an
      awesome IDE supporting both IntelliJ IDEA and the Eclipse
      platform.&lt;/p&gt;
      
      &lt;p&gt;Ceylon enables the development of cross-platform modules
      that execute portably in both virtual machine environments.
      Alternatively, a Ceylon module may target one or the other
      platform, in which case it may interoperate with native code
      written for that platform.&lt;/p&gt;
      
      &lt;h3&gt;In the box&lt;/h3&gt;
      
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;This release&lt;/a&gt; includes:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;a complete &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/spec&quot;&gt;language specification&lt;/a&gt; that defines the
      syntax and semantics of Ceylon in language accessible to
      the professional developer,&lt;/li&gt;
      &lt;li&gt;a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/reference/tool/ceylon/subcommands/index.html&quot;&gt;command line toolset&lt;/a&gt; including compilers for
      Java and JavaScript, a documentation compiler, a test
      runner, a WAR archive packager, a &quot;fat&quot; JAR packager, and
      support for executing modular programs on the JVM and
      Node.js,&lt;/li&gt;
      &lt;li&gt;a powerful module architecture for code organization,
      dependency management, and module isolation at runtime,
      which also supports interoperation with OSGi, Jigsaw,
      Maven, and npm, and&lt;/li&gt;
      &lt;li&gt;the &lt;a href=&quot;https://herd.ceylon-lang.org/modules/ceylon.language&quot;&gt;language module&lt;/a&gt;, our minimal,
      cross-platform, foundation-level API.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Available separately:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;updated versions of the platform modules that comprise the
      &lt;a href=&quot;https://modules.ceylon-lang.org/categories/SDK&quot;&gt;Ceylon SDK&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;a code &lt;a href=&quot;https://github.com/eclipse/ceylon.formatter&quot;&gt;formatter&lt;/a&gt; as a plugin for the &lt;code&gt;ceylon&lt;/code&gt; command,&lt;/li&gt;
      &lt;li&gt;a plugin for the &lt;code&gt;ceylon&lt;/code&gt; command that supports
      &lt;a href=&quot;https://github.com/jvasileff/ceylon-dart&quot;&gt;compilation and execution for the Dart VM&lt;/a&gt;, and&lt;/li&gt;
      &lt;li&gt;two full-featured integrated development environments: for
      Eclipse and IntelliJ IDEA.&lt;/li&gt;
      &lt;/ul&gt;&lt;h3&gt;Language&lt;/h3&gt;
      
      &lt;p&gt;Ceylon is a highly understandable object-oriented language
      with static typing. The language features:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;an emphasis upon &lt;strong&gt;readability&lt;/strong&gt; and a strong bias toward
      &lt;strong&gt;omission or elimination of potentially-harmful or
      potentially-ambiguous constructs&lt;/strong&gt; and toward highly
      &lt;strong&gt;disciplined use of static types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;an extremely powerful and uncommonly elegant type system
      combining subtype and parametric polymorphism with:
      
      &lt;ul&gt;
      &lt;li&gt;first-class &lt;strong&gt;union and intersection types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;both &lt;strong&gt;declaration-site and use-site variance&lt;/strong&gt;, and&lt;/li&gt;
      &lt;li&gt;the use of principal types for &lt;strong&gt;local type inference&lt;/strong&gt;
      and &lt;strong&gt;flow-sensitive typing&lt;/strong&gt;,&lt;/li&gt;
      &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;a unique treatment of &lt;strong&gt;function and tuple types&lt;/strong&gt;,
      enabling powerful abstractions, along with the most
      &lt;strong&gt;elegant approach to &lt;code&gt;null&lt;/code&gt;&lt;/strong&gt; of any modern language,&lt;/li&gt;
      &lt;li&gt;first-class constructs for defining &lt;strong&gt;modules and
      dependencies between modules&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;a very flexible syntax including &lt;strong&gt;comprehensions&lt;/strong&gt; and
      support for expressing &lt;strong&gt;tree-like structures&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;fully-reified generic types&lt;/strong&gt;, on both the JVM and
      JavaScript virtual machines, and a unique &lt;strong&gt;typesafe
      metamodel&lt;/strong&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;More information about these language features may be
      found in the &lt;a href=&quot;https://ceylon-lang.org/features&quot;&gt;feature list&lt;/a&gt; and
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/introduction/&quot;&gt;quick introduction&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Community&lt;/h3&gt;
      
      &lt;p&gt;The Ceylon community site, &lt;a href=&quot;https://ceylon-lang.org&quot;&gt;https://ceylon-lang.org&lt;/a&gt;, includes
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.3&quot;&gt;documentation&lt;/a&gt;, and information about
      &lt;a href=&quot;https://ceylon-lang.org/community&quot;&gt;getting involved&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Source code&lt;/h3&gt;
      
      &lt;p&gt;The source code for Ceylon, its specification, and its website,
      is freely available from &lt;a href=&quot;https://github.com/eclipse&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;Information about Ceylon's open source licenses is available
      &lt;a href=&quot;https://ceylon-lang.org/code/licenses/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Issues&lt;/h3&gt;
      
      &lt;p&gt;Bugs and suggestions may be reported in GitHub's
      &lt;a href=&quot;https://ceylon-lang.org/code/issues&quot;&gt;issue tracker&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Acknowledgement&lt;/h2&gt;
      
      &lt;p&gt;As always, we're deeply grateful to the community volunteers
      who contributed a substantial part of the current Ceylon
      codebase, working in their own spare time. The following
      people have contributed to Ceylon:&lt;/p&gt;
      
      &lt;p&gt;Gavin King,                Stéphane Épardaud,           Tako Schotanus,
      Tom Bentley,               David Festal,                Enrique Zamudio,
      Bastien Jansen,            Emmanuel Bernard,            Aleš Justin,
      Tomáš Hradec,              James Cobb,                  Ross Tate,
      Max Rydahl Andersen,       Mladen Turk,                 Lucas Werkmeister,
      Roland Tepp,               Diego Coronel,               Matej Lazar,
      John Vasileff,             Toby Crawley,                Julien Viet,
      Loic Rouchon,              Stephane Gallès,             Ivo Kasiuk,
      Corbin Uselton,            Paco Soberón,                Michael Musgrove,
      Daniel Rochetti,           Henning Burdack,             Luke deGruchy,
      Rohit Mohan,               Griffin DeJohn,              Casey Dahlin,
      Gilles Duboscq,            Tomasz Krakowiak,            Alexander Altman,
      Alexander Zolotko,         Alex Szczuczko,              Andrés G. Aragoneses,
      Anh Nhan Nguyen,           Brice Dutheil,               Carlos Augusto Mar,
      Charles Gould,             Chris Gregory,               klinger,
      Martin Voelkle,            Mr. Arkansas,                Paŭlo Ebermann,
      Vorlent,                   Akber Choudhry,              Renato Athaydes,
      Flavio Oliveri,            Michael Brackx,              Brent Douglas,
      Lukas Eder,                Markus Rydh,                 Julien Ponge,
      Pete Muir,                 Nicolas Leroux,              Brett Cannon,
      Geoffrey De Smet,          Guillaume Lours,             Gunnar Morling,
      Jeff Parsons,              Jesse Sightler,              Oleg Kulikov,
      Raimund Klein,             Sergej Koščejev,             Chris Marshall,
      Simon Thum,                Maia Kozheva,                Shelby,
      Aslak Knutsen,             Fabien Meurisse,             Sjur Bakka,
      Xavier Coulon,             Ari Kast,                    Dan Allen,
      Deniz Türkoglu,            F. Meurisse,                 Jean-Charles Roger,
      Johannes Lehmann,          allentc,                     Nikolay Tsankov,
      Chris Horne,               Gabriel Mirea,               Georg Ragaller,
      Harald Wellmann,           Oliver Gondža,               Stephen Crawley,
      Byron Clark,               Francisco Reverbel,          Jonas Berlin,
      Luke Hutchison,            Nikita Ostroumov,            Santiago Rodriguez,
      Sean Flanigan,             Schalk W. Cronjé.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2016/08/02/ceylon-bootstrap</id>
    <title>Ceylon Bootstrap</title>
    <updated>2016-08-02T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2016/08/02/ceylon-bootstrap" rel="alternate" type="text/html" />
    <author>
      <name>St&#233;phane &#201;pardaud</name>
    </author>
    <summary>
      Ceylon 1.2.2 was released back in March, and at the time
      it shipped with a new feature that
      did not make a lot of noise, but I think it's worth explaining it a bit more in this blog.
      
      In general Ceylon developers have to download the Ceylon distribution in order to compile
      Ceylon code, and so do Ceylon users. When you check out a Ceylon project you have to make
      sure you're using the right version of the Ceylon distribution to compile it, and
      switching Ceylon distribution can be a bit too involved on some Operating Systems.
      
      To solve that issue, Tako has implemented the
      ceylon bootstrap tool,...
    </summary>
    <content type="html">
      &lt;p&gt;&lt;a href=&quot;blog/2016/03/11/ceylon-1-2-2/&quot;&gt;Ceylon 1.2.2&lt;/a&gt; was released back in March, and at the time
      it shipped with a new feature that
      did not make a lot of noise, but I think it's worth explaining it a bit more in this blog.&lt;/p&gt;
      
      &lt;p&gt;In general Ceylon developers have to &lt;a href=&quot;https://ceylon-lang.org/download&quot;&gt;download the Ceylon distribution&lt;/a&gt; in order to compile
      Ceylon code, and so do Ceylon users. When you check out a Ceylon project you have to make
      sure you're using the right version of the Ceylon distribution to compile it, and
      switching Ceylon distribution can be a bit too involved on some Operating Systems.&lt;/p&gt;
      
      &lt;p&gt;To solve that issue, Tako has implemented the
      &lt;a href=&quot;http://ceylon-lang.org/documentation/1.2/reference/tool/bootstrap/&quot;&gt;&lt;code&gt;ceylon bootstrap&lt;/code&gt; tool&lt;/a&gt;, very heavily inspired
      by the &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle Wrapper&lt;/a&gt;,
      which allows you to generate a small script in your Ceylon project
      which your users and developpers can use to automatically download the right Ceylon distribution
      and cache it for future use.&lt;/p&gt;
      
      &lt;p&gt;Let's try it out by generating a new Ceylon project (on a machine with a Ceylon 1.2.2 distribution,
      this is a chicken and egg problem and we have to start somewhere):&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ ceylon new hello-world --ant=no --eclipse=no myproject
      Enter module name [com.example.helloworld]: 
      Enter module version [1.0.0]:
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now let's check that it compiles and runs:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ cd myproject
      $ ceylon compile,run com.example.helloworld
      Note: Created module com.example.helloworld/1.0.0
      Hello, World!
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Excellent! Now let's add the Ceylon bootstrap tool:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ ceylon bootstrap
      $ ls ceylonb*
      ceylonb  ceylonb.bat
      $ ls .ceylon/bootstrap/
      ceylon-bootstrap.jar  ceylon-bootstrap.properties
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;As you can see, we've created two &lt;code&gt;ceylonb&lt;/code&gt; scripts (one for Unix, one for Windows), and
      a new configuration folder for those scripts containing a tiny jar (24k) and a settings file
      which points to the distribution to use:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ cat .ceylon/bootstrap/ceylon-bootstrap.properties 
      #Generated by 'ceylon bootstrap'
      #Tue Aug 02 17:29:39 CEST 2016
      distribution=https\://downloads.ceylon-lang.org/cli/ceylon-1.2.2.zip
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;These scripts and folders should be committed to your project code, so they can be used by
      others.&lt;/p&gt;
      
      &lt;p&gt;Now, whenever someone checks your project out, they can just use the provided &lt;code&gt;ceylonb&lt;/code&gt;
      script to work rather than pre-install the Ceylon distribution:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ ./ceylonb compile,run com.example.helloworld
      Downloading Ceylon... 100%
      Note: Created module com.example.helloworld/1.0.0
      Hello, World!
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;The first time you run this, it will download the desired Ceylon distribution to &lt;code&gt;~/.ceylon/dists&lt;/code&gt;,
      but from then on, whenever you invoke &lt;code&gt;ceylonb&lt;/code&gt; it will reuse that distribution without downloading
      anything. Even other projects using the same distribution will be able to use it.&lt;/p&gt;
      
      &lt;p&gt;As I said, Gradle Wrapper users are used to this, but still, it's a really good idea and there's no
      reason why programming languages couldn't do the same!&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2016/07/18/typescript-status-report</id>
    <title>Status Report: Ceylon TypeScript Loader GSoC project</title>
    <updated>2016-07-18T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2016/07/18/typescript-status-report" rel="alternate" type="text/html" />
    <author>
      <name>Lucas Werkmeister</name>
    </author>
    <summary>
      TL;DR: coming along, won’t be done in time for official GSoC deadline, I’ll just keep working.
      
      (Note: this is a GSoC status report.
      The entire project is work in progress, and if you’re looking for a something finished, you’ll have to wait until the project is released, at which point there will be a proper announcement.)
      
      For this year’s Google Summer of Code, I am working on adding TypeScript support to the Ceylon JavaScript backend.
      The goal is to have a tool that, given a TypeScript module (one or more files), produces a Ceylon module for the JavaScript backend.
      The JS code of that module...
    </summary>
    <content type="html">
      &lt;p&gt;TL;DR: coming along, won’t be done in time for official GSoC deadline, I’ll just keep working.&lt;/p&gt;
      
      &lt;p&gt;(Note: this is a GSoC status report.
      The entire project is work in progress, and if you’re looking for a something finished, you’ll have to wait until the project is released, at which point there will be a proper announcement.)&lt;/p&gt;
      
      &lt;p&gt;For this year’s Google Summer of Code, I am working on adding TypeScript support to the Ceylon JavaScript backend.
      The goal is to have a tool that, given a TypeScript module (one or more files), produces a Ceylon module for the JavaScript backend.
      The JS code of that module will just be the TypeScript compiler’s output (plus possibly some metamodel stuff),
      but the tool will also add model information that will allow you to use the TypeScript module from Ceylon like any other Ceylon module,
      without needing to use &lt;code&gt;dynamic&lt;/code&gt; blocks or having to declare your own dynamic interfaces.&lt;/p&gt;
      
      &lt;p&gt;I actually started work on this tool a few months before GSoC, in January this year.
      I wrote the first iteration of the program in TypeScript in order to be able to interact with the TypeScript compiler
      (which is also written in TypeScript).
      The goal of that first iteration is just to be able to load the TypeScript compiler itself,
      so that I can then use that module (&lt;code&gt;tsc&lt;/code&gt;) from Ceylon
      and write the second (and probably final) iteration of the program in Ceylon.&lt;/p&gt;
      
      &lt;p&gt;This first iteration of the program was mostly finished,
      at least good enough that I could start writing the second iteration,
      shortly after the GSoC work period officially started.
      I had hoped to start with the second iteration exactly at the start of GSoC,
      but while there had been good progress with my own simple test module,
      &lt;code&gt;tsc&lt;/code&gt; held a couple of nasty surprises that I hadn’t anticipated and that I had to work around.
      It also turned out that I had made a couple of very bad decisions early on:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;I chose to operate on the parsed syntax tree instead of the typechecker model.
      How I ever expected this to work, I have no idea, but problems quickly became obvious:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;When I see a type reference, like &lt;code&gt;Element&lt;/code&gt;, I have to know if this refers to a type parameter,
      a type from the same module, or perhaps one from another module.
      The type I store in the model must be fully qualified.&lt;/li&gt;
      &lt;li&gt;To represent a type with type arguments, the JS model lists the type arguments along with their type parameter name.
      So to transform a type like &lt;code&gt;Array&amp;lt;string&amp;gt;&lt;/code&gt;, I have to know that &lt;code&gt;Array&lt;/code&gt;’s first type parameter is called &lt;code&gt;Element&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;TypeScript features type inference.
      Of course, I have to know the inferred type so that I can put it into the model.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;p&gt;To get a first version out quickly, I just wrote directly to the &lt;code&gt;-model.js&lt;/code&gt; file.
      The model is mostly JSON, so this meant some ugly manual comma management
      when it turned out there are some declarations where I don’t emit anything
      (such as index signatures).&lt;/p&gt;&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;There are some lovely commit messages in the &lt;a href=&quot;https://github.com/lucaswerkmeister/ctsl/commits&quot;&gt;git log&lt;/a&gt;,
      with phrases like “totally hacky”, “should be enough for now”,
      “this is where it all falls apart”, “add fake support”, “horrible hack”, and
      “How could I possibly ever think that it’s possible to write this loader without access to tsc’s model, purely based on the AST?”
      I am very glad that I get to learn from these mistakes in the second iteration :)&lt;/p&gt;
      
      &lt;p&gt;Now, writing the second iteration also turned out to be trickier than I’d thought.
      I had (still have) a Ceylon version of the TypeScript compiler, the &lt;code&gt;tsc&lt;/code&gt; module,
      but it’s difficult to work with from Ceylon.
      Two problems mainly held me up:&lt;/p&gt;
      
      &lt;ol&gt;
      &lt;li&gt;TypeScript supports optional members: &lt;code&gt;{ name?: string }&lt;/code&gt; is the type of a value that might have a member &lt;code&gt;name&lt;/code&gt; (containing a &lt;code&gt;string&lt;/code&gt;),
      but might also have no such member (&lt;code&gt;undefined&lt;/code&gt;).
      The Ceylon runtime doesn’t like this at all and breaks in many different and difficult-to-debug ways;
      the only solution I found was to not emit such members at all.
      To access them without “attribute does not exist” typechecker errors,
      I use &lt;code&gt;eval&lt;/code&gt; inside &lt;code&gt;dynamic&lt;/code&gt; blocks, which leads us to the second problem.&lt;/li&gt;
      &lt;li&gt;Whenever a dynamic value (such as the return value of an &lt;code&gt;eval&lt;/code&gt; call) is assigned to a Ceylon type,
      the runtime “dresses” the value with the type that it’s being assigned to (adds RTTI).
      If this is not the most precise type of the value
      (say, you dressed the value with &lt;code&gt;Node&lt;/code&gt; and later want to use it as a &lt;code&gt;VariableDeclaration&lt;/code&gt;),
      you have to jump through some hoops to fix this – a simple &lt;code&gt;assert (is VariableDeclaration node)&lt;/code&gt; won’t work,
      since Ceylon doesn’t like to narrow these dressed types.&lt;/li&gt;
      &lt;/ol&gt;&lt;p&gt;I now have workarounds for both problems, but they took a while to find,
      and of course I shouldn’t have to work around them in the first place,
      so I’ll have to teach the Ceylon JS backend to “do the right thing” eventually.
      (I also have to do that in many other cases, since the Ceylon JS “ABI” differs significantly from plain JS –
      Ceylon classes aren’t instantiated with &lt;code&gt;new&lt;/code&gt;, toplevel values compile to functions, arrays aren’t arrays, etc. etc.)&lt;/p&gt;
      
      &lt;p&gt;Right now, the second iteration supports:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;toplevel values,&lt;/li&gt;
      &lt;li&gt;toplevel functions (no parameters), and&lt;/li&gt;
      &lt;li&gt;the &lt;code&gt;string&lt;/code&gt; type.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;That’s it. &lt;em&gt;But&lt;/em&gt;, unlike the first iteration, it supports this without needing to add any JS code
      (I’ve already taught the compiler to access the toplevel values as values and not functions).
      Currently, some JS code is added (metamodel stuff), but I’m not sure if I’ll actually keep that.
      We could say that what, are you crazy, why would TypeScript modules support the metamodel?,
      and then the JS file would just be the unaltered &lt;code&gt;tsc&lt;/code&gt; output, and the tool would only add the &lt;code&gt;-model.js&lt;/code&gt; file.
      This would probably make working with declaration files easier
      (where the JS isn’t generated by &lt;code&gt;tsc&lt;/code&gt; – one of many problems I haven’t even begun to think about yet).&lt;/p&gt;
      
      &lt;p&gt;I’m fairly confident that I’ll be able to add support for most “basic” features –
      type references and other primitive types, type parameters and arguments, parameters,
      classes, interfaces, methods, attributes – without too much trouble.
      After that, all bets are off.
      TypeScript supports some crazy features, like string types (&lt;code&gt;&quot;foo&quot; | &quot;bar&quot; | &quot;baz&quot;&lt;/code&gt; is a valid type)
      and type guards (&lt;code&gt;pet is Fish&lt;/code&gt; is a valid return type, a weird inversion of Ceylon’s &lt;code&gt;is Fish pet&lt;/code&gt; conditions),
      and I have no idea how well we can support them.
      I will also need to make more changes to the JS backend and runtime,
      and I don’t know how difficult those will be.&lt;/p&gt;
      
      &lt;p&gt;There are about four weeks left before the official GSoC deadline, and I’ll be on vacation for one of them.
      I hope that the “basic” support will be done until then, but there’s zero chance that the project will be in shippable state.
      I’m not too worried about that – I’ve worked on the project before GSoC started, I’ll continue to work on it after GSoC ends,
      just like I did with &lt;code&gt;ceylon.ast&lt;/code&gt; two years ago.
      And, just like two years ago, I should have more time after GSoC ends,
      because GSoC is actually scheduled pretty weirdly for me,
      where I still have lectures for most of it and it barely overlaps with my semester break.
      I should be free to work on this project for most of August, September, and the first half of October,
      and hope to arrive at something that can actually be released somewhere before the end of that period.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2016/07/04/modularity-changes</id>
    <title>Modularity Changes</title>
    <updated>2016-07-04T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2016/07/04/modularity-changes" rel="alternate" type="text/html" />
    <author>
      <name>St&#233;phane &#201;pardaud</name>
    </author>
    <summary>
      TL;DR: This article describes the modularity changes in the Ceylon run-time and distribution, in order
      to make them lighter at run-time. Skip to the Final runtime dependencies
      section if you just want the outcome.
      
      Ceylon has featured a modular architecture from the start.
      Not just for Ceylon users who write
      modules, but also within the Ceylon distribution. Historically we used to have very few modules,
      that were directly related to separate Git projects. Adding a new module meant a new repository
      and lots of changes in the build. Naturally, as the project grew, each of those modules also
      grew, and got new third-party dependencies, and occasionally adding a...
    </summary>
    <content type="html">
      &lt;p&gt;TL;DR: This article describes the modularity changes in the Ceylon run-time and distribution, in order
      to make them lighter at run-time. Skip to the &lt;a href=&quot;#final_runtime_dependencies&quot;&gt;Final runtime dependencies&lt;/a&gt;
      section if you just want the outcome.&lt;/p&gt;
      
      &lt;p&gt;Ceylon has featured a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/tour/modules/#modularity&quot;&gt;modular architecture&lt;/a&gt; from the start.
      Not just for Ceylon users who write
      modules, but also within the Ceylon distribution. Historically we used to have very few modules,
      that were directly related to separate Git projects. Adding a new module meant a new repository
      and lots of changes in the build. Naturally, as the project grew, each of those modules also
      grew, and got new third-party dependencies, and occasionally adding a feature in one module
      was made tremendously easier by just adding that &quot;one more&quot; dependency between distribution modules,
      resulting in a big spaghetti graph of distribution modules that is common in older/evolved systems.&lt;/p&gt;
      
      &lt;p&gt;As we initially expected most Ceylon users to run their code using the
      &lt;a href=&quot;https://ceylon-lang.org/documentation/current/reference/tool/ceylon/subcommands/ceylon-run.html&quot;&gt;&lt;code&gt;ceylon run&lt;/code&gt; command&lt;/a&gt;, we
      figured that since they have the Ceylon distribution installed, it does not matter if they depend
      on more modules from that distribution than strictly necessary. Those modules had to be there
      anyway, so it would not save any bandwidth to reduce those dependencies.&lt;/p&gt;
      
      &lt;p&gt;Naturally, we were wrong, and between the Ceylon Eclipse or IntelliJ IDEs, running Ceylon on
      OpenShift, WildFly, Vert.x or on Android, people started running Ceylon without the distribution
      installed, using just the standard &lt;code&gt;java&lt;/code&gt; runner. It became soon apparent that we had to untangle
      those dependencies to make the runtime requirements lighter.&lt;/p&gt;
      
      &lt;p&gt;Historically we had the following modules:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;common module used by other modules&lt;/li&gt;
      &lt;li&gt;typechecker (the shared compiler front-end)&lt;/li&gt;
      &lt;li&gt;Java compiler back-end&lt;/li&gt;
      &lt;li&gt;JavaScript compiler back-end&lt;/li&gt;
      &lt;li&gt;module repository system&lt;/li&gt;
      &lt;li&gt;JBoss modules runtime&lt;/li&gt;
      &lt;/ul&gt;&lt;h1&gt;The model module&lt;/h1&gt;
      
      &lt;p&gt;When we implemented &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/tour/generics/#fully_reified_generic_types&quot;&gt;reified generics&lt;/a&gt;,
      we had to add subtyping to the runtime, so that we'd be able
      to figure out if &lt;code&gt;is T bar&lt;/code&gt; was true or not. The easiest thing at the time was to &quot;just&quot; depend
      on the typechecker (compiler front-end) which dealt with the language model and subtyping, and the Java
      compiler back-end, which had infrastructure to load a language model from JVM information such as
      class files, or in this case reflection.&lt;/p&gt;
      
      &lt;p&gt;This essentially made the runtime depend on the compiler front-end and back-end, which we realised
      was not ideal, so during the Ceylon 1.2 development, we extracted all model description, loading
      and subtyping to a new &lt;code&gt;ceylon-model&lt;/code&gt; module, but we did not have enough time to do more and so
      these dependencies remained due to other causes.&lt;/p&gt;
      
      &lt;h1&gt;Supporting Java 9&lt;/h1&gt;
      
      &lt;p&gt;During our work on &lt;a href=&quot;https://ceylon-lang.org/blog/2015/12/17/java9-jigsaw/&quot;&gt;supporting Java 9 / Jigsaw modules in Ceylon&lt;/a&gt;,
      it became clear that having kept
      our &quot;fork&quot; of &lt;code&gt;javalang&lt;/code&gt; tools (that we use for &lt;code&gt;javac&lt;/code&gt;) under its original package name would not
      work anymore, we renamed its package and used the opportunity to prune away parts of the java tools
      we did not use. We also extracted the class-file reader part to its own module so we could use it
      outside of the compiler to remove our dependency to &lt;code&gt;jandex&lt;/code&gt; (a class-file scanner).&lt;/p&gt;
      
      &lt;p&gt;Finally, when we created the &lt;code&gt;ceylon jigsaw&lt;/code&gt; tool (which populates a folder with the jar files required
      by a Ceylon module, to run it on a Java 9 VM) it became evident that the runtime still depended not
      just on the compiler front-end and Java back-end, but even on the JavaScript back-end, which frankly
      made little sense in most JVM executions.&lt;/p&gt;
      
      &lt;p&gt;These dependencies were due to the
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/reference/interoperability/ceylon-on-jvm/#using_the_ceylontoolprovider_api&quot;&gt;Ceylon Tool Provider API&lt;/a&gt;
      having snuck into the &lt;code&gt;ceylon.language&lt;/code&gt; module
      as a convenience (at the time). Since that allowed you to compile and run Ceylon programmatically
      for both Java and JavaScript back-ends, it had to depend on the tools.&lt;/p&gt;
      
      &lt;p&gt;We decided to split the Ceylon Tool Provider into its own module and got rid of the final dependencies from
      the language module to the compilers and typechecker, but had no more time to get rid of further
      dependencies such as JBoss Modules and Aether in time for Ceylon 1.2.2.&lt;/p&gt;
      
      &lt;h1&gt;Supporting Android&lt;/h1&gt;
      
      &lt;p&gt;Initial &lt;a href=&quot;https://ceylon-lang.org/blog/2016/06/02/ceylon-on-android/&quot;&gt;work on running Ceylon on Android&lt;/a&gt; revealed that what passes for
      small dependencies on ordinary
      JVM executions, or even on Java EE deployments, was not an option on Android where every method counts.&lt;/p&gt;
      
      &lt;p&gt;At this point we had to bite the bullet and make every non-required transitive dependency go.&lt;/p&gt;
      
      &lt;p&gt;We noticed that the old &lt;code&gt;common&lt;/code&gt; module had grew to include the
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/reference/tool/#the_ceylon_command&quot;&gt;Command-Line Tooling API&lt;/a&gt; that makes the &lt;code&gt;ceylon&lt;/code&gt;
      command and its subcommands and plugins work. That in turn depended on a Markdown renderer used by
      &lt;code&gt;ceylon doc&lt;/code&gt;. It was pretty trivial to extract it to its own module because this was never used
      in Ceylon user programs.&lt;/p&gt;
      
      &lt;p&gt;Next in line was our Shrinkwrap Resolver dependency, which our module repository system uses to
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/reference/repository/maven/#maven_repositories&quot;&gt;interoperate with Maven repositories&lt;/a&gt;.
      This was a fat-jar with all its dependencies included, including some Apache
      Commons modules, and an outdated version of Eclipse Aether. That fat-jar had already been problematic
      in our Maven module, which already had its version of Aether, so getting rid of the fat-jar was a good
      idea. We also realised that some of its Apache Commons dependencies were already included outside the
      fat-jar in our distribution repository, so there was that duplication to fix too.&lt;/p&gt;
      
      &lt;p&gt;So what we did was remove the Shrinkwrap Resolver dependency and use Aether directly, by incorporating
      all its subcomponents into our distribution. It turns out that because the latest version of Aether
      requires Google Guava, our distribution grew in size rather than shrink (that jar is huge). But to offset
      that, we made the Aether dependency optional, and made sure it was possible to run Ceylon without it
      as long as there was some compilation step beforehand that provided all the Maven dependencies that
      you may use in interop. &lt;a href=&quot;https://ceylon-lang.org/blog/2016/06/29/ceylon-fat-jars/&quot;&gt;&lt;code&gt;ceylon fat-jar&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;ceylon jigsaw&lt;/code&gt;
      would do that for you, for example.&lt;/p&gt;
      
      &lt;p&gt;Our module repository system also provided support for
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/reference/repository/#supported_repository_types&quot;&gt;writing to WebDAV or Herd repositories&lt;/a&gt;, which
      required some dependencies on Apache Http Client or Sardine, and we made these dependencies optional
      as well, because at runtime your Ceylon program is very unlikely to write to HTTP repositories. This
      is something only the compiler and other tools do.&lt;/p&gt;
      
      &lt;p&gt;We also removed a dependency to JBoss Modules from the language module using abstraction, since that
      platform was optional and never used on Android or other flat-classpath runtimes.&lt;/p&gt;
      
      &lt;p&gt;Finally, the language module only had one dependency left on the (much slimmer) module repository system
      via the presence of the
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/reference/interoperability/ceylon-on-jvm/#using_the_main_api&quot;&gt;&lt;code&gt;Main API&lt;/code&gt;&lt;/a&gt; in there,
      and we moved that class to its own module.&lt;/p&gt;
      
      &lt;h1&gt;Final runtime dependencies&lt;/h1&gt;
      
      &lt;p&gt;After all this pruning, the language module on the JVM is back down to requiring the following set
      of transitive dependencies:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;common (small and free of tooling and dependencies)&lt;/li&gt;
      &lt;li&gt;model (which depends only on the class-file reader)&lt;/li&gt;
      &lt;li&gt;class-file reader&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;So your Ceylon module will only depend on four jars (these three and the language module), the sum
      size of which is 2.4 Mb, which is much smaller than initially, and has dramatically less methods,
      at around 17148 methods. This is still too much, but can be brought down by tooling such as ProGuard
      to remove unused classes. Remember this includes a runtime for an entire language, so it's not
      &lt;em&gt;that&lt;/em&gt; big, all things considered.&lt;/p&gt;
      
      &lt;h1&gt;SDK changes&lt;/h1&gt;
      
      &lt;p&gt;In order to be able to use Ceylon's HTTP client on Android, we also split up the &lt;code&gt;ceylon.net&lt;/code&gt; module from the
      Ceylon SDK into client and server modules. Otherwise the HTTP server and its dependencies were
      too much drag for Android's method count.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2016/06/29/ceylon-fat-jars</id>
    <title>Ceylon Fat Jars</title>
    <updated>2016-06-29T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2016/06/29/ceylon-fat-jars" rel="alternate" type="text/html" />
    <author>
      <name>St&#233;phane &#201;pardaud</name>
    </author>
    <summary>
      Ceylon 1.2.3 is looming closer, and so we should start talking about some of the new features that
      it will contain. One of those new features is the new ceylon fat-jar command.
      
      ceylon fat-jar my.module/1 lets you generate a jar which contains the my.module/1 module and
      every required dependency. Once you have that jar, you can execute it with java -jar my.module-1.jar
      and it will execute the module.
      
      Naturally, you can customise the function or class to execute with the --run option, but the default
      is the run method in your module (my.module::run in our case).
      
      The modules are executed in a "flat classpath" mode, without JBoss...
    </summary>
    <content type="html">
      &lt;p&gt;Ceylon 1.2.3 is looming closer, and so we should start talking about some of the new features that
      it will contain. One of those new features is the new &lt;code&gt;ceylon fat-jar&lt;/code&gt; command.&lt;/p&gt;
      
      &lt;p&gt;&lt;code&gt;ceylon fat-jar my.module/1&lt;/code&gt; lets you generate a jar which contains the &lt;code&gt;my.module/1&lt;/code&gt; module and
      every required dependency. Once you have that jar, you can execute it with &lt;code&gt;java -jar my.module-1.jar&lt;/code&gt;
      and it will execute the module.&lt;/p&gt;
      
      &lt;p&gt;Naturally, you can customise the function or class to execute with the &lt;code&gt;--run&lt;/code&gt; option, but the default
      is the &lt;code&gt;run&lt;/code&gt; method in your module (&lt;code&gt;my.module::run&lt;/code&gt; in our case).&lt;/p&gt;
      
      &lt;p&gt;The modules are executed in a &quot;flat classpath&quot; mode, without JBoss Modules or any sort of module isolation,
      and with the metamodel already set up statically when the fat jar was created, so it's a little bit different
      to the older alternative of running Ceylon modules using the
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/reference/interoperability/ceylon-on-jvm/#using_the_main_api&quot;&gt;Main API&lt;/a&gt;
      and &lt;code&gt;ceylon classpath&lt;/code&gt; tool, which did not deal
      with packing all the dependencies. It is also different to the &lt;code&gt;ceylon run --flat-classpath&lt;/code&gt; in that it does
      not require a module repository at run-time, since &lt;code&gt;ceylon fat-jar&lt;/code&gt; packs it all together.&lt;/p&gt;
      
      &lt;p&gt;Try it out, it's pretty useful to distribute Ceylon programs and run them in places without having to
      install the Ceylon distribution.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2016/06/02/ceylon-on-android</id>
    <title>Ceylon on Android</title>
    <updated>2016-06-02T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2016/06/02/ceylon-on-android" rel="alternate" type="text/html" />
    <author>
      <name>St&#233;phane &#201;pardaud</name>
    </author>
    <summary>
      In my last post, I explained how you can use Ceylon in Apache Cordova to write applications for
      every mobile platform, including iOS and Android. This time, with many apologies for writing it
      late (“next week” turned into next month), I will explain how to use the Ceylon IntelliJ plugin
      to write native Android applications in Ceylon in Android Studio.
      
      Getting started with Ceylon on Android Studio
      
      To start writing Ceylon applications in Android Studio, follow these steps:
      
      
      Download Android Studio
      Start it
      Create a new application by clicking on Start a new Android Studio Project
      You can use these values for Application name: CeylonDemo
      And for Company domain: android.example.com
      Next,...
    </summary>
    <content type="html">
      &lt;p&gt;In &lt;a href=&quot;https://ceylon-lang.org/blog/2016/04/20/ceylon-on-mobile/&quot;&gt;my last post&lt;/a&gt;, I explained how you can use Ceylon in Apache Cordova to write applications for
      every mobile platform, including iOS and Android. This time, with many apologies for writing it
      late (“next week” turned into next month), I will explain how to use the Ceylon IntelliJ plugin
      to write native Android applications in Ceylon in Android Studio.&lt;/p&gt;
      
      &lt;h1&gt;Getting started with Ceylon on Android Studio&lt;/h1&gt;
      
      &lt;p&gt;To start writing Ceylon applications in Android Studio, follow these steps:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.android.com/studio/index.html&quot;&gt;Download Android Studio&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Start it&lt;/li&gt;
      &lt;li&gt;Create a new application by clicking on &lt;code&gt;Start a new Android Studio Project&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;You can use these values for &lt;code&gt;Application name&lt;/code&gt;: &lt;code&gt;CeylonDemo&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;And for &lt;code&gt;Company domain&lt;/code&gt;: &lt;code&gt;android.example.com&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;Next, select an &lt;code&gt;Empty activity&lt;/code&gt;, with &lt;code&gt;Activity Name&lt;/code&gt;: &lt;code&gt;MainActivity&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;Click &lt;code&gt;Finish&lt;/code&gt; and wait for the project to be created&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;At this point you have an Android project open, but we still haven't had time to install the Ceylon
      plugin, so let's do this right now:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Click on &lt;code&gt;File &amp;gt; Settings &amp;gt; Plugins &amp;gt; Browse Repositories&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;Then on &lt;code&gt;Manage Repositories &amp;gt; +&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;Add this repository: &lt;code&gt;https://downloads.ceylon-lang.org/ide/intellij/development/updatePlugins.xml&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;Now click on &lt;code&gt;Install Ceylon IDE&lt;/code&gt;
      &lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;You will likely need to restart Android Studio, so do that.&lt;/p&gt;
      
      &lt;p&gt;Next we're going to convert our Android project to a Ceylon Android project:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;In the &lt;code&gt;Android&lt;/code&gt; view, Right-click on &lt;code&gt;app &amp;gt; Configure Ceylon in this Module&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;Click &lt;code&gt;OK&lt;/code&gt; on the resulting configuration dialog&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;This will set up the Ceylon plugin, and will add most of what you need in your Gradle build to build
      Ceylon Android applications. You now have your Ceylon sources in &lt;code&gt;app/src/main/ceylon&lt;/code&gt; and it includes
      a module descriptor and an empty activity:&lt;/p&gt;
      
      &lt;div style=&quot;text-align:center;&quot;&gt;
      &lt;img src=&quot;https://ceylon-lang.org/images/screenshots/blog/2016-06-02-ceylon-on-android/ide.png&quot; style=&quot;box-shadow: 0 0 10px #888;margin-left:5px;&quot; width=&quot;700px&quot; height=&quot;auto&quot;&gt;
      &lt;/div&gt;
      
      
      &lt;p&gt;At the moment, this requires a Ceylon &lt;code&gt;1.2.3&lt;/code&gt; distribution to build, and since it's not released yet
      you're going to have to either &lt;a href=&quot;https://ceylon-lang.org/code/contribute/#contributing_to_the_compiler_backend&quot;&gt;build one yourself&lt;/a&gt;
      (just the &lt;code&gt;Getting the source&lt;/code&gt; part), or
      &lt;a href=&quot;https://ci-ceylon.rhcloud.com/job/ceylon-distribution/&quot;&gt;download a nightly build&lt;/a&gt;.
      Once you have it, edit
      &lt;code&gt;app/build.gradle&lt;/code&gt; near then end to add &lt;code&gt;ceylon &amp;gt; ceylonLocation&lt;/code&gt; and make it point to where you
      installed your distribution (it needs to point to the Ceylon binary, not just the distribution
      root):&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: groovy --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;ceylon {
          // ...
          ceylonLocation &quot;.../ceylon/dist/dist/bin/ceylon&quot;
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Make sure you click on &lt;code&gt;Sync now&lt;/code&gt; to sync your Gradle build.&lt;/p&gt;
      
      &lt;p&gt;Now, there's a bug we're in the process of fixing which fails to detect the exact version of the Android
      SDK tooling and modules, and so depending on which version of the Android Tools you're using you may have
      to sync the imports of &lt;code&gt;com.android.support:appcompat-v7:23.1.1&lt;/code&gt; in &lt;code&gt;app/build.gradle&lt;/code&gt; (in &lt;code&gt;dependencies&lt;/code&gt;)
      and in the Ceylon module descriptor in &lt;code&gt;module.ceylon&lt;/code&gt;. Make sure the Ceylon import version is the same
      as the Gradle import version, because the Gradle build is what makes it available to Ceylon, due to Android's
      peculiarities.&lt;/p&gt;
      
      &lt;p&gt;In order to finish the conversion, make sure you delete the Java activity (since we're going to keep the
      Ceylon one), in &lt;code&gt;Project Files&lt;/code&gt;, delete &lt;code&gt;app/src/main/java&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Due to another pending plugin fix, you may have to click on &lt;code&gt;Tools &amp;gt; Ceylon &amp;gt; Reset Ceylon Model&lt;/code&gt; at this
      point so that the Ceylon plugin gets synchronised with all these past changes (don't worry we're fixing
      this at the moment).&lt;/p&gt;
      
      &lt;p&gt;The good news is we're already able to click on &lt;code&gt;Run app&lt;/code&gt; and try this in the emulator, but we're going to
      make it a little more interesting.&lt;/p&gt;
      
      &lt;h1&gt;Customising your Ceylon Android activity&lt;/h1&gt;
      
      &lt;p&gt;We're going to be displaying a list of Ceylon modules published on &lt;a href=&quot;https://herd.ceylon-lang.org&quot;&gt;Ceylon Herd&lt;/a&gt;,
      so we will make use of the Ceylon SDK, and in particular you will have to edit &lt;code&gt;module.ceylon&lt;/code&gt; to add the following
      imports:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import ceylon.http.client &quot;1.2.3&quot;;
      import ceylon.uri &quot;1.2.3&quot;;
      import ceylon.json &quot;1.2.3&quot;;
      import ceylon.collection &quot;1.2.3&quot;;
      import ceylon.interop.java &quot;1.2.3&quot;;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Next, we're going to turn our &lt;code&gt;MainActivity&lt;/code&gt; into a &lt;code&gt;ListActivity&lt;/code&gt; and run an asynchronous task to connect to
      the Herd REST endpoint, so edit &lt;code&gt;MainActivity.ceylon&lt;/code&gt; with this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import android.os { Bundle, AsyncTask }
      import android.app { ListActivity }
      import android.widget { ArrayAdapter, ListAdapter }
      import android.support.v7.app { AppCompatActivity }
      import ceylon.interop.java { createJavaStringArray }
      import java.lang { JString = String }
      import android { AndroidR = R }
      import ceylon.language.meta { modules }
      import ceylon.uri { parseUri = parse }
      import ceylon.http.client { httpGet = get }
      import ceylon.json { parseJson = parse, JsonObject = Object, JsonArray = Array }
      import ceylon.collection { MutableList, LinkedList }
      
      shared class MainActivity() extends ListActivity() {
      
          class LoadModules() extends AsyncTask&amp;lt;String, Nothing, List&amp;lt;String&amp;gt;&amp;gt;() {
              shared actual List&amp;lt;String&amp;gt; doInBackground(String?* uris){
                  assert(exists uri = uris.first);
                  value response = httpGet(parseUri(uri)).execute();
                  value modules = LinkedList&amp;lt;String&amp;gt;();
                  assert(is JsonObject json = parseJson(response.contents),
                          is JsonArray results = json[&quot;results&quot;]);
                  // Iterate modules
                  for(res in results) {
                      assert (is JsonObject res); // Get the list of versions
                      assert (is String name = res[&quot;module&quot;],
                              is JsonArray versions = res[&quot;versions&quot;]);
                      modules.add(name);
                      print(name);
                  }
                  return modules;
              }
              shared actual void onPostExecute(List&amp;lt;String&amp;gt; result){
                  print(&quot;Got result: ``result``&quot;);
      
                  ListAdapter adapter = ArrayAdapter&amp;lt;JString&amp;gt;(outer, AndroidR.Layout.simple_list_item_1,
                      createJavaStringArray(result));
                  listAdapter = adapter;
              }
          }
      
          shared actual void onCreate(Bundle savedInstanceState) {
              super.onCreate(savedInstanceState);
              setContentView(R.Layout.activity_main);
      
              LoadModules().execute(&quot;https://modules.ceylon-lang.org/api/1/complete-modules?module=ceylon.&quot;);
          }
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now edit &lt;code&gt;app/src/main/res/layout/activity_main.xml&lt;/code&gt; to change the activity type to a list activity:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: xml --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;ListView
          android:layout_width=&quot;match_parent&quot;
          android:layout_height=&quot;match_parent&quot;
          android:id=&quot;@android:id/list&quot;/&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And lastly request the &lt;code&gt;network&lt;/code&gt; permission for your app, since we're hitting a web service, by adding
      this to &lt;code&gt;app/src/main/res/AndroidManifest.xml&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: xml --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;That's all you need, now just click on &lt;code&gt;Run &amp;gt; Run app&lt;/code&gt; and watch your Ceylon application display the
      list of modules in the emulator:&lt;/p&gt;
      
      &lt;div style=&quot;text-align:center;&quot;&gt;
      &lt;img src=&quot;https://ceylon-lang.org/images/screenshots/blog/2016-06-02-ceylon-on-android/application.png&quot; style=&quot;box-shadow: 0 0 10px #888;margin-left:5px;&quot; height=&quot;auto&quot;&gt;
      &lt;/div&gt;
      
      
      &lt;h1&gt;Some technical info&lt;/h1&gt;
      
      &lt;p&gt;The Ceylon IntelliJ plugin has not been released yet, but a preview is forthcoming really soon. You will
      see it's already quite advanced when you try this out. Don't hesitate to
      &lt;a href=&quot;https://github.com/ceylon/ceylon-ide-intellij/issues/new&quot;&gt;report any bugs&lt;/a&gt;, or better yet, contribute
      fixes :)&lt;/p&gt;
      
      &lt;p&gt;Most of it works well enough for Android, except the caveats noted above, and the fact that Android Studio
      does not yet recognize Ceylon classes, so they will be marked as errors in the &lt;code&gt;.xml&lt;/code&gt; files that refer to
      them, and when you run your application it will report an error:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: text --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Could not identify launch activity: Default Activity not found. Error while Launching activity
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;It only means it could not start your application, you will have to click on it to start it in the emulator.
      But the deployment worked. We're fixing this at the moment, so it will only improve.&lt;/p&gt;
      
      &lt;p&gt;If you want to revert to the Ceylon Eclipse IDE to edit your Ceylon Android application, you can, it will
      work once you have your project set up with Android Studio. It's much easier to use it to set it up so all
      the Gradle config is just right. Once that is done, you can use Eclipse if you want, and use
      &lt;code&gt;$ ./gradlew assembleDebug&lt;/code&gt; to build your APK.&lt;/p&gt;
      
      &lt;p&gt;This work depends on changes we've made in Ceylon 1.2.3 (to be released soon) which adds support for jars
      which provide alternate smaller JDKs (such as the Android jar), improvements in modularity so that the
      created applications depend on much fewer runtime Ceylon jars than before, fixes in the runtime metamodel
      to support Android runtimes, and several other tweaks. I will probably write an account of all that in
      a future blog entry.&lt;/p&gt;
      
      &lt;p&gt;This work also depends on the &lt;a href=&quot;https://github.com/renatoathaydes/ceylon-gradle-plugin&quot;&gt;Ceylon Gradle plugin&lt;/a&gt;
      written by Renato Athaydes, and on a new &lt;a href=&quot;https://github.com/ceylon/ceylon-gradle-android&quot;&gt;Ceylon Gradle Android plugin&lt;/a&gt;
      which adds support for Ceylon in Android applications. This plugin is by no means finished, and in particular
      does not yet support incremental compilation (even though the Ceylon IDE and compiler do). It also does not
      yet support the latest Android &lt;code&gt;Instant Run&lt;/code&gt; feature. Again, please
      &lt;a href=&quot;https://github.com/ceylon/ceylon-gradle-android/issues/new&quot;&gt;report issues&lt;/a&gt; or better, contribute pull-requests :)&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2016/04/20/ceylon-on-mobile</id>
    <title>Ceylon on mobile devices</title>
    <updated>2016-04-20T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2016/04/20/ceylon-on-mobile" rel="alternate" type="text/html" />
    <author>
      <name>St&#233;phane &#201;pardaud</name>
    </author>
    <summary>
      Ceylon already runs on the JVM, whether bare-bones, via JBoss Modules, Vert.x, Java EE Servlet
      containers such as WildFly, or OSGi containers, as well as on JavaScript VMs such as Node.js
      and the browser. But today we're going to explain how to run Ceylon on mobile devices, not just
      in the browser (though it does play a part in it), but as applications, via Apache Cordova.
      
      Apache Cordova allows you to write applications for every mobile
      platform, including Android and iOS, using nothing but HTML, CSS and JavaScript. Since Ceylon
      compiles to JavaScript this is perfect as it allows us to run our Ceylon applications on...
    </summary>
    <content type="html">
      &lt;p&gt;Ceylon already runs on the JVM, whether bare-bones, via JBoss Modules, Vert.x, Java EE Servlet
      containers such as WildFly, or OSGi containers, as well as on JavaScript VMs such as Node.js
      and the browser. But today we're going to explain how to run Ceylon on mobile devices, not just
      in the browser (though it does play a part in it), but as applications, via Apache Cordova.&lt;/p&gt;
      
      &lt;p&gt;&lt;a href=&quot;https://cordova.apache.org&quot;&gt;Apache Cordova&lt;/a&gt; allows you to write applications for every mobile
      platform, including Android and iOS, using nothing but HTML, CSS and JavaScript. Since Ceylon
      compiles to JavaScript this is perfect as it allows us to run our Ceylon applications on iOS,
      via the JavaScript compiler backend.&lt;/p&gt;
      
      &lt;p&gt;Note that this article is using Ceylon 1.2.3 which is not yet released, because the JavaScript
      runtime in Cordova on Android had one peculiarity we had to work around in the language module
      JavaScript implementation. Luckily you can get nightly builds of
      &lt;a href=&quot;https://ci-ceylon.rhcloud.com/job/ceylon-distribution/&quot;&gt;Ceylon 1.2.3&lt;/a&gt; and the
      &lt;a href=&quot;https://ci-ceylon.rhcloud.com/job/ceylon-sdk/lastSuccessfulBuild/artifact/&quot;&gt;Ceylon 1.2.3 SDK&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h1&gt;Writing your Ceylon Cordova application&lt;/h1&gt;
      
      &lt;h2&gt;Installing Apache Cordova&lt;/h2&gt;
      
      &lt;p&gt;First, &lt;a href=&quot;https://cordova.apache.org/#getstarted&quot;&gt;install Apache Cordova&lt;/a&gt; and add two platforms.
      I haven't been able to test the iOS platform since it requires an OSX platform to build and
      an iOS device to test, and I lack both, so I will explain how to package for Android and the
      browser, and let you guys try it out for iOS, but I have enough faith in Apache Cordova that
      it will Just Work™.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;# Install npm, the Node.js package manager
      $ sudo apt-get install npm
      # Then install Apache Cordova
      $ npm install cordova
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Small note: for me this installed things in &lt;code&gt;./node_modules/cordova&lt;/code&gt; and the Apache Cordova
      command in &lt;code&gt;./node_modules/cordova/bin/cordova&lt;/code&gt;, so adapt your path as you must.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;# Create your application
      $ cordova create ceylon-cordova-demo
      $ cd ceylon-cordova-demo
      # Now add the browser and Android platforms
      $ cordova platform add browser
      $ cordova platform add android
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;At this point you have your application ready to be checked in your browser:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ cordova platform run browser
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or in an Android emulator, provided you have downloaded the Android SDK already:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ ANDROID_HOME=.../Android/Sdk cordova platform build android
      $ ANDROID_HOME=.../Android/Sdk cordova platform run android
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h2&gt;Getting a little side-tracked about styling&lt;/h2&gt;
      
      &lt;p&gt;Writing an application using just HTML and CSS means you have to make some effort for
      it to look good, and instead I decided to delegate to use &lt;a href=&quot;https://www.polymer-project.org&quot;&gt;Polymer&lt;/a&gt;
      so that my application would have the look and feel of
      &lt;a href=&quot;https://www.google.com/design/spec/material-design/introduction.html&quot;&gt;Android Material Design&lt;/a&gt; applications
      to feel even more like a native application on Android. No doubt a similar look and feel exists for iOS.&lt;/p&gt;
      
      &lt;p&gt;So let's download &lt;a href=&quot;https://www.polymer-project.org/1.0/docs/start/getting-the-code.html&quot;&gt;Polymer&lt;/a&gt; in our
      application's HTML sources:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ npm install bower
      $ cd www
      $ bower init
      # At this point just hit enter/Yes/No until it's set up 
      $ bower install --save Polymer/polymer
      $ bower install --save Polymerelements/paper-item
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And now edit &lt;code&gt;www/index.html&lt;/code&gt; to use Polymer:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: html --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;bower_components/webcomponentsjs/webcomponents.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;link rel=&quot;import&quot; href=&quot;bower_components/paper-item/paper-item.html&quot;&amp;gt;
      &amp;lt;link rel=&quot;import&quot; href=&quot;bower_components/paper-item/paper-item-body.html&quot;&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;You should also remove the default CSS:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: html --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/index.css&quot;&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h2&gt;Getting require.js and jQuery&lt;/h2&gt;
      
      &lt;p&gt;Ceylon compiles to JavaScript modules by way of &lt;a href=&quot;http://requirejs.org&quot;&gt;require.js&lt;/a&gt;, so we're going to
      have to download it too:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ cd www/js
      $ wget http://requirejs.org/docs/release/2.2.0/minified/require.js
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Our Ceylon demo will use &lt;code&gt;jQuery&lt;/code&gt; to add elements to the HTML page, so we also need it:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ cd www
      $ bower install --save jquery
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now edit &lt;code&gt;www/index.html&lt;/code&gt; to use both:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: html --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/require.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;script src=&quot;bower_components/jquery/dist/jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h2&gt;Writing the Ceylon application&lt;/h2&gt;
      
      &lt;p&gt;We're going to write a trivial application that queries Ceylon Herd for the list of modules, to display them
      in a list.&lt;/p&gt;
      
      &lt;p&gt;Let's start by creating a Ceylon module in &lt;code&gt;source/cordova/demo/module.ceylon&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;module cordova.demo &quot;1.0.0&quot; {
          import ceylon.json &quot;1.2.3&quot;;
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And our application's main method in &lt;code&gt;source/cordova/demo/run.ceylon&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import ceylon.json { parseJson = parse, JsonObject = Object, JsonArray = Array }
      
      shared void run() {
          dynamic {
              // The HTML element where we'll add our items
              dynamic target = jQuery(&quot;#target&quot;);
              // The function called when we get data from the server
              void success(dynamic data){
                  // Parse the JSON
                  assert(is JsonObject json = parseJson(data),
                         is JsonArray results = json[&quot;results&quot;]);
                  // Iterate modules
                  for(res in results){
                    assert(is JsonObject res);
                    // Get the list of versions
                    assert(is String name = res[&quot;module&quot;],
                           is JsonArray versions = res[&quot;versions&quot;]);
                    // Join them
                    value versionText = &quot;, &quot;.join(versions.narrow&amp;lt;String&amp;gt;());
                    // Now add the HTML items
                    dynamic item = jQuery(&quot;&amp;lt;paper-item/&amp;gt;&quot;);
                    dynamic body = jQuery(&quot;&amp;lt;paper-item-body two-line/&amp;gt;&quot;).appendTo(item);
                    jQuery(&quot;&amp;lt;div/&amp;gt;&quot;).text(name).appendTo(body);
                    jQuery(&quot;&amp;lt;div secondary/&amp;gt;&quot;).text(versionText).appendTo(body);
                    target.append(item);
                  }
              }
              // Query Herd for the list of modules
              jQuery.get(&quot;https://modules.ceylon-lang.org/api/1/complete-modules?module=ceylon.&quot;, null, success, &quot;text&quot;);
          }
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now, obviously using &lt;code&gt;jQuery&lt;/code&gt; to add HTML is far from ideal, so I can't wait for someone to
      extend &lt;a href=&quot;https://herd.ceylon-lang.org/modules/ceylon.html&quot;&gt;ceylon.html&lt;/a&gt; to allow Polymer web
      components!&lt;/p&gt;
      
      &lt;p&gt;We can now compile our application for JavaScript:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ ceylon compile-js
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And copy our compiled module and all its dependencies to where the Apache Cordova application
      will find them in &lt;code&gt;www/modules&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ ceylon copy --with-dependencies --js --out www/modules cordova.demo/1.0.0
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h2&gt;Invoking the Ceylon module from the Cordova application&lt;/h2&gt;
      
      &lt;p&gt;Because we're going to use &lt;code&gt;require.js&lt;/code&gt; inline and connect to Ceylon Herd, we have to adjust the Apache
      Cordova permissions in &lt;code&gt;www/index.html&lt;/code&gt;, so find that line and edit it as such:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: html --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&quot;Content-Security-Policy&quot; 
            content=&quot;default-src 'self' 'unsafe-inline' 
                     https://fonts.googleapis.com
                     https://fonts.gstatic.com;
                     connect-src *&quot;&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;We're left with just invoking our Ceylon function in &lt;code&gt;www/index.html&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: html --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        // tell require.js where our Ceylon modules are 
        require.config({
          baseUrl:'modules',
        });
        // when the document is ready
        jQuery(function(){
          // load our Ceylon module
          require(['cordova/demo/1.0.0/cordova.demo-1.0.0'], function(client) {
            // and call our run method
            client.run();
          });
      });
      &amp;lt;/script&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And setting up the target HTML elements where we're going to add every loaded module (in
      the same file):&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: html --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;body id=&quot;app&quot; unresolved&amp;gt;
        &amp;lt;app-shell class=&quot;fit&quot;&amp;gt;
          &amp;lt;div id=&quot;target&quot; role=&quot;listbox&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;/app-shell&amp;gt;
      &amp;lt;/body&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h2&gt;Trying it&lt;/h2&gt;
      
      &lt;p&gt;And that's it, try it out in your browser:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ cordova platform run browser
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or in an Android emulator:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ ANDROID_HOME=.../Android/Sdk cordova platform build android
      $ ANDROID_HOME=.../Android/Sdk cordova platform run android
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;If you have OSX and iOS dev tools, please try this with the iOS Cordova platform and let
      me know how it works :)&lt;/p&gt;
      
      &lt;p&gt;In the future, we would benefit from having a type-safe API in front of the Cordova JavaScript
      API that lets you access native mobile APIs such as the camera, GPS, contacts, but even without
      it you can already use them using &lt;code&gt;dynamic&lt;/code&gt; blocks.&lt;/p&gt;
      
      &lt;p&gt;And now for the teaser… this is only one method to run Ceylon on Android, because obviously it
      may be more desirable to use the JVM compiler backend and integrate with the Android Tools to
      run Ceylon on Android using only type-safe APIs. Don't worry, it's coming, and next week I will
      show you how :)&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2016/04/05/object-validation</id>
    <title>Object construction and validation</title>
    <updated>2016-04-05T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2016/04/05/object-validation" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      When porting Java code to Ceylon, I sometimes run into
      Java classes where the constructor mixes validation with
      initialization. Let's illustrate what I mean with a simple
      but very contrived example.
      
      Some bad code
      
      Consider this Java class. (Try not to write code like this
      at home, kiddies!)
      
      
      
      
      
      
      
      public class Period {
      
          private final Date startDate;
          private final Date endDate;
      
          //returns null if the given String
          //does not represent a valid Date
          private Date parseDate(String date) {
             ...
          }
      
          public...
    </summary>
    <content type="html">
      &lt;p&gt;When porting Java code to Ceylon, I sometimes run into
      Java classes where the constructor mixes &lt;em&gt;validation&lt;/em&gt; with
      &lt;em&gt;initialization&lt;/em&gt;. Let's illustrate what I mean with a simple
      but very contrived example.&lt;/p&gt;
      
      &lt;h2&gt;Some bad code&lt;/h2&gt;
      
      &lt;p&gt;Consider this Java class. (Try not to write code like this
      at home, kiddies!)&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: java --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;public class Period {
      
          private final Date startDate;
          private final Date endDate;
      
          //returns null if the given String
          //does not represent a valid Date
          private Date parseDate(String date) {
             ...
          }
      
          public Period(String start, String end) {
              startDate = parseDate(start);
              endDate = parseDate(end);
          }
      
          public boolean isValid() {
              return startDate!=null &amp;amp;&amp;amp; endDate!=null;
          }
      
          public Date getStartDate() {
              if (startDate==null) 
                  throw new IllegalStateException();
              return startDate;
          }
      
          public Date getEndDate() {
              if (endDate==null)
                  throw new IllegalStateException();
              return endDate;
          }
      } 
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Hey, I warned you it was going to be contrived. But it's
      really not uncommon to find stuff like this in real Java
      code.&lt;/p&gt;
      
      &lt;p&gt;The problem here is that even if validation of the input
      parameters (in the elided &lt;code&gt;parseDate()&lt;/code&gt; method) fails, we
      still receive an instance of &lt;code&gt;Period&lt;/code&gt;. But the &lt;code&gt;Period&lt;/code&gt; we
      get isn't actually in a &quot;valid&quot; state. What do I mean by
      that, precisely?&lt;/p&gt;
      
      &lt;p&gt;Well, I would say that an object is in an invalid state if
      it can't respond meaningfully to its public operations. In
      this case, &lt;code&gt;getStartDate()&lt;/code&gt; and &lt;code&gt;getEndDate()&lt;/code&gt; can throw an
      &lt;code&gt;IllegalStateException&lt;/code&gt;, which is a condition I would
      consider not &quot;meaningful&quot;.&lt;/p&gt;
      
      &lt;p&gt;Another way to look at this is that what we have here is a
      failure of type safety in the design of &lt;code&gt;Period&lt;/code&gt;. Unchecked
      exceptions represent a &quot;hole&quot; in the type system. So a more
      typesafe design for &lt;code&gt;Period&lt;/code&gt; would be one which never uses
      unchecked exceptions—that doesn't throw
      &lt;code&gt;IllegalStateException&lt;/code&gt;, in this case.&lt;/p&gt;
      
      &lt;p&gt;(Actually, in practice, in real code, I'm more likely to
      encounter a &lt;code&gt;getStartDate()&lt;/code&gt; which &lt;em&gt;doesn't&lt;/em&gt; check for
      &lt;code&gt;null&lt;/code&gt;, and actually results in a &lt;code&gt;NullPointerException&lt;/code&gt;
      further down the line, which is even worse.)&lt;/p&gt;
      
      &lt;p&gt;We can easily translate the above &lt;code&gt;Period&lt;/code&gt; class to Ceylon:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;shared class Period(String start, String end) {
      
          //returns null if the given String
          //does not represent a valid Date
          Date? parseDate(String date) =&amp;gt; ... ;
      
          value maybeStartDate = parseDate(start);
          value maybeEndDate = parseDate(end);
      
          shared Boolean valid
              =&amp;gt; maybeStartDate exists 
              &amp;amp;&amp;amp; maybeEndDate exists;
      
          shared Date startDate {
              assert (exists maybeStartDate);
              return maybeStartDate;
          }
      
          shared Date endDate {
              assert (exists maybeEndDate);
              return maybeEndDate;
          }
      } 
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And, of course, this code suffers from the same problem as
      the original Java code. The two &lt;code&gt;assert&lt;/code&gt;ions are screaming
      at us that there is a problem with the typesafety of the
      code.&lt;/p&gt;
      
      &lt;h2&gt;Making the Java code better&lt;/h2&gt;
      
      &lt;p&gt;How could we improve this code in Java. Well, here's a case
      where Java's much-maligned checked exceptions would be a
      really reasonable solution! We could slightly change &lt;code&gt;Period&lt;/code&gt;
      to throw a checked exception from its constructor:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: java --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;public class Period {
      
          private final Date startDate;
          private final Date endDate;
      
          //throws if the given String
          //does not represent a valid Date
          private Date parseDate(String date)
                  throws DateFormatException {
             ...
          }
      
          public Period(String start, String end) 
                  throws DateFormatException {
              startDate = parseDate(start);
              endDate = parseDate(end);
          }
      
          public Date getStartDate() {
              return startDate;
          }
      
          public Date getEndDate() {
              return endDate;
          }
      } 
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now, with this solution, we can never get a &lt;code&gt;Period&lt;/code&gt; in an
      invalid state, and the code which instantiates &lt;code&gt;Period&lt;/code&gt; is
      obligated by the compiler to handle the case of invalid
      input by &lt;code&gt;catch&lt;/code&gt;ing the &lt;code&gt;DateFormatException&lt;/code&gt; somewhere.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: java --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;try {
          Period p = new Period(start, end);
          ...
      }
      catch (DateFormatException dfe) {
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This is a good and excellent and righteous use of checked
      exceptions, and it's unfortunate that I only rarely find
      Java code which uses checked exceptions like this.&lt;/p&gt;
      
      &lt;h3&gt;Making the Ceylon code better&lt;/h3&gt;
      
      &lt;p&gt;What about Ceylon? Ceylon doesn't have checked exceptions,
      so we'll have to look for a different solution. Typically,
      in cases where Java would call for use of a function that
      throws a checked exception, Ceylon would call for the use
      of a function that returns a union type. Since the
      initializer of a class can't return any type other than the
      class itself, we'll need to extract some of the mixed
      initialization/validation logic into a factory function.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;//returns DateFormatError if the given 
      //String does not represent a valid Date
      Date|DateFormatError parseDate(String date) =&amp;gt; ... ;
      
      shared Period|DateFormatError parsePeriod
              (String start, String end) {
          value startDate = parseDate(start);
          if (is DateFormatError startDate) {
              return startDate;
          }
          value endDate = parseDate(end);
          if (is DateFormatError endDate)  {
              return endDate;
          }
          return Period(startDate, endDate);
      }
      
      shared class Period(startDate, endDate) {
          shared Date startDate;
          shared Date endDate;
      } 
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;!--
          shared Period|DateFormatError parsePeriod
                  (String start, String end)
              =&gt; let (startDate = parseDate(start),
                      endDate = parseDate(end))
                      if (is DateFormatError startDate) 
                          then startDate
                 else if (is DateFormatError endDate) 
                          then endDate
                 else Period(startDate, endDate);
      --&gt;
      
      
      &lt;p&gt;The caller is forced by the type system to deal with
      &lt;code&gt;DateFormatError&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;value p = parsePeriod(start, end);
      if (is DateFormatError p) {
          ...
      }
      else {
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or, if we didn't care about the actual problem with the
      given date format (probable, given that the initial code we
      were working from lost that information), we could just use
      &lt;code&gt;Null&lt;/code&gt; instead of &lt;code&gt;DateFormatError&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;//returns null if the given String 
      //does not represent a valid Date
      Date? parseDate(String date) =&amp;gt; ... ;
      
      shared Period? parsePeriod(String start, String end)
          =&amp;gt; if (exists startDate = parseDate(start), 
                 exists endDate = parseDate(end))
             then Period(startDate, endDate)
             else null;
      
      shared class Period(startDate, endDate) {
          shared Date startDate;
          shared Date endDate;
      } 
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;At least arguably, the approach of using a factory function
      is superior, since in general it obtains better separation
      between validation logic and object initialization. This is
      especially useful in Ceylon, where the compiler enforces
      some quite heavy-handed restrictions on object
      initialization logic in order to guarantee that all fields
      of the object are assigned exactly once.&lt;/p&gt;
      
      &lt;h2&gt;Summary&lt;/h2&gt;
      
      &lt;p&gt;In conclusion:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Try to separate validation from initialization, wherever
      reasonable.&lt;/li&gt;
      &lt;li&gt;Validation logic doesn't usually belong in constructors
      (especially not in Ceylon).&lt;/li&gt;
      &lt;li&gt;Don't create objects in &quot;invalid&quot; states.&lt;/li&gt;
      &lt;li&gt;An &quot;invalid&quot; state can sometimes be detected by looking
      for failures of typesafety.&lt;/li&gt;
      &lt;li&gt;In Java, a constructor or factory function that throws a
      checked exception is a reasonable alternative.&lt;/li&gt;
      &lt;li&gt;In Ceylon, a factory function that returns a union type is
      a reasonable alternative.&lt;/li&gt;
      &lt;/ul&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2016/03/11/ceylon-1-2-2</id>
    <title>Ceylon 1.2.2 is now available</title>
    <updated>2016-03-11T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2016/03/11/ceylon-1-2-2" rel="alternate" type="text/html" />
    <author>
      <name>Tako Schotanus</name>
    </author>
    <summary>
      Four months after the last major release, and exactly one month after the 1.2.1 update,
      Ceylon 1.2.2 is a new maintenance release, with over 70 issues closed,
      including new features, improvements and bug fixes such as:
      
      
      you can now use java.lang.Iterable and Java arrays in for statements and comprehensions,
      the [] lookup operator works on Java lists, maps, and arrays,
      the in operator works on java.util.Collection and, last but not least,
      a new ceylon bootstrap command to make it really easy to distribute
      code to people that don't have Ceylon installed.
      
      
      
      Note that for the JVM backend, this release is backwards-compatible
      with the previous releases (1.2.0 and 1.2.1), which...
    </summary>
    <content type="html">
      &lt;p&gt;Four months after the last major release, and exactly one month after the 1.2.1 update,
      &lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;Ceylon 1.2.2&lt;/a&gt; is a new maintenance release, with over &lt;a href=&quot;https://github.com/ceylon/ceylon/issues?q=is%3Aissue+milestone%3A1.2.2+is%3Aclosed&quot;&gt;70 issues&lt;/a&gt; closed,
      including new features, improvements and bug fixes such as:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;you can now use &lt;code&gt;java.lang.Iterable&lt;/code&gt; and Java arrays in &lt;code&gt;for&lt;/code&gt; statements and comprehensions,&lt;/li&gt;
      &lt;li&gt;the &lt;code&gt;[]&lt;/code&gt; lookup operator works on Java lists, maps, and arrays,&lt;/li&gt;
      &lt;li&gt;the &lt;code&gt;in&lt;/code&gt; operator works on &lt;code&gt;java.util.Collection&lt;/code&gt; and, last but not least,&lt;/li&gt;
      &lt;li&gt;a new &lt;code&gt;ceylon bootstrap&lt;/code&gt; &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/reference/tool/bootstrap&quot;&gt;command&lt;/a&gt; to make it really easy to distribute
      code to people that don't have Ceylon installed.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Note that for the JVM backend, this release is backwards-compatible
      with the previous releases (&lt;code&gt;1.2.0&lt;/code&gt; and &lt;code&gt;1.2.1&lt;/code&gt;), which means you can use
      modules compiled with &lt;code&gt;1.2.0&lt;/code&gt; on a &lt;code&gt;1.2.2&lt;/code&gt; distribution out of the box.
      This is not as easy the other way around, if you want to run modules
      compiled for &lt;code&gt;1.2.2&lt;/code&gt; on a &lt;code&gt;1.2.0&lt;/code&gt; distribution, which is why we
      recommend you upgrade to &lt;code&gt;1.2.2&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Sadly, on the JavaScript backend, we had to break binary compatibility
      to fix serious interoperation issues, and so modules compiled for &lt;code&gt;1.2.2&lt;/code&gt;
      and &lt;code&gt;1.2.0&lt;/code&gt; are not compatible. Versions &lt;code&gt;1.2.1&lt;/code&gt; and &lt;code&gt;1.2.2&lt;/code&gt; are binary
      compatible but can still give problems when used together. We recommend
      you upgrade your distribution to &lt;code&gt;1.2.2&lt;/code&gt; and recompile your modules.&lt;/p&gt;
      
      &lt;h2&gt;About Ceylon&lt;/h2&gt;
      
      &lt;p&gt;Ceylon is a modern, modular, statically typed programming
      language for the Java and JavaScript virtual machines. The
      language features a flexible and very readable syntax, a
      unique and uncommonly elegant static type system, a powerful
      module architecture, and excellent tooling, including an
      awesome Eclipse-based IDE.&lt;/p&gt;
      
      &lt;p&gt;Ceylon enables the development of cross-platform modules
      that execute portably in both virtual machine environments.
      Alternatively, a Ceylon module may target one or the other
      platform, in which case it may interoperate with native code
      written for that platform.&lt;/p&gt;
      
      &lt;h2&gt;In the box&lt;/h2&gt;
      
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;This release&lt;/a&gt; includes:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;a complete &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/spec&quot;&gt;language specification&lt;/a&gt; that defines the
      syntax and semantics of Ceylon in language accessible to
      the professional developer,&lt;/li&gt;
      &lt;li&gt;a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/reference/tool/ceylon/subcommands/index.html&quot;&gt;command line toolset&lt;/a&gt; including compilers for
      Java and JavaScript, a documentation compiler, a test
      runner, a WAR archive packager, and support for executing
      modular programs on the JVM and Node.js,&lt;/li&gt;
      &lt;li&gt;a powerful module architecture for code organization,
      dependency management, and module isolation at runtime,&lt;/li&gt;
      &lt;li&gt;the &lt;a href=&quot;https://herd.ceylon-lang.org/modules/ceylon.language&quot;&gt;language module&lt;/a&gt;, our minimal,
      cross-platform foundation of the &lt;a href=&quot;https://modules.ceylon-lang.org/categories/SDK&quot;&gt;Ceylon SDK&lt;/a&gt;, and&lt;/li&gt;
      &lt;li&gt;a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/ide/features/&quot;&gt;full-featured&lt;/a&gt; Eclipse-based integrated
      development environment.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Language&lt;/h2&gt;
      
      &lt;p&gt;Ceylon is a highly understandable object-oriented language
      with static typing. The language features:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;an emphasis upon &lt;strong&gt;readability&lt;/strong&gt; and a strong bias toward
      &lt;strong&gt;omission or elimination of potentially-harmful or
      potentially-ambiguous constructs&lt;/strong&gt; and toward highly
      &lt;strong&gt;disciplined use of static types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;an extremely powerful and uncommonly elegant type system
      combining subtype and parametric polymorphism with:
      
      &lt;ul&gt;
      &lt;li&gt;first-class &lt;strong&gt;union and intersection types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;both &lt;strong&gt;declaration-site and use-site variance&lt;/strong&gt;, and&lt;/li&gt;
      &lt;li&gt;the use of principal types for &lt;strong&gt;local type inference&lt;/strong&gt;
      and &lt;strong&gt;flow-sensitive typing&lt;/strong&gt;,&lt;/li&gt;
      &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;a unique treatment of &lt;strong&gt;function and tuple types&lt;/strong&gt;,
      enabling powerful abstractions, along with the most
      &lt;strong&gt;elegant approach to &lt;code&gt;null&lt;/code&gt;&lt;/strong&gt; of any modern language,&lt;/li&gt;
      &lt;li&gt;first-class constructs for defining &lt;strong&gt;modules and
      dependencies between modules&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;a very flexible syntax including &lt;strong&gt;comprehensions&lt;/strong&gt; and
      support for expressing &lt;strong&gt;tree-like structures&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;fully-reified generic types&lt;/strong&gt;, on both the JVM and
      JavaScript virtual machines, and a unique &lt;strong&gt;typesafe
      metamodel&lt;/strong&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;More information about these language features may be
      found in the &lt;a href=&quot;https://ceylon-lang.org/features&quot;&gt;feature list&lt;/a&gt; and
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/introduction/&quot;&gt;quick introduction&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;IDE&lt;/h2&gt;
      
      &lt;p&gt;Ceylon IDE now features the following improvement, along
      with bugfixes:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;support for the &lt;code&gt;ceylon bootstrap&lt;/code&gt; command&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;SDK&lt;/h2&gt;
      
      &lt;p&gt;The &lt;a href=&quot;https://modules.ceylon-lang.org/categories/SDK&quot;&gt;platform modules&lt;/a&gt;, recompiled for 1.2.2, are
      available in the shared community repository, &lt;a href=&quot;https://herd.ceylon-lang.org&quot;&gt;Ceylon Herd&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;This release introduces a single new platform module:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.buffer&lt;/code&gt; is a cross-platform module for converting between
      text and binary forms of data.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Along with some enhancements to existing modules:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.file&lt;/code&gt; now has functions for creating temporary files and directories,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.net&lt;/code&gt; now has support for template handlers,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.html&lt;/code&gt; was rewritten according to HTML5 specification and with support for lazy evaluation.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Web IDE&lt;/h2&gt;
      
      &lt;p&gt;You can try Ceylon using the &lt;a href=&quot;http://try.ceylon-lang.org&quot;&gt;Web IDE&lt;/a&gt;, featuring syntax highlighting,
      interactive error reporting, autocompletion, online
      documentation, and persistence and code sharing via Gist.&lt;/p&gt;
      
      &lt;p&gt;The Web IDE serves a dual purpose as a standard example
      demonstrating the use of Ceylon for web application
      development and deployment to the &lt;a href=&quot;http://openshift.com&quot;&gt;OpenShift&lt;/a&gt; cloud
      platform.&lt;/p&gt;
      
      &lt;h2&gt;Community&lt;/h2&gt;
      
      &lt;p&gt;The Ceylon community site, &lt;a href=&quot;http://ceylon-lang.org&quot;&gt;http://ceylon-lang.org&lt;/a&gt;, includes
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2&quot;&gt;documentation&lt;/a&gt;, and information about
      &lt;a href=&quot;https://ceylon-lang.org/community/&quot;&gt;getting involved&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Source code&lt;/h2&gt;
      
      &lt;p&gt;The source code for Ceylon, its specification, and its website,
      is freely available from &lt;a href=&quot;https://github.com/ceylon&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;Information about Ceylon's open source licenses is available
      &lt;a href=&quot;https://ceylon-lang.org/code/licenses/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Issues&lt;/h2&gt;
      
      &lt;p&gt;Bugs and suggestions may be reported in GitHub's
      &lt;a href=&quot;https://ceylon-lang.org/code/issues&quot;&gt;issue tracker&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Migrating from Ceylon 1.2.0&lt;/h2&gt;
      
      &lt;p&gt;Migration from Ceylon 1.2.0 is easy. To recompile a module for
      1.2.2:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;First ensure that its dependencies have also been
      recompiled.&lt;/li&gt;
      &lt;li&gt;If it imports a Ceylon SDK platform module, upgrade the
      version number specified by the module &lt;code&gt;import&lt;/code&gt; statement
      from &lt;code&gt;&quot;1.2.0&quot;&lt;/code&gt; to &lt;code&gt;&quot;1.2.2&quot;&lt;/code&gt; .&lt;/li&gt;
      &lt;li&gt;If it was compiled against Ceylon &lt;code&gt;1.2.0&lt;/code&gt; you should still
      be able to use it in &lt;code&gt;1.2.2&lt;/code&gt; for the JVM backend,
      as it is backwards-compatible. Sadly, this is not the case
      for the JavaScript backend, and so you will need to recompile
      your modules with &lt;code&gt;1.2.2&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Acknowledgement&lt;/h2&gt;
      
      &lt;p&gt;As always, we're deeply grateful to the community volunteers
      who contributed a substantial part of the current Ceylon
      codebase, working in their own spare time. The following
      people have contributed to Ceylon:&lt;/p&gt;
      
      &lt;p&gt;Gavin King,                Stéphane Épardaud,           Tako Schotanus,
      Tom Bentley,               David Festal,                Enrique Zamudio,
      Bastien Jansen,            Emmanuel Bernard,            Aleš Justin,
      Tomáš Hradec,              James Cobb,                  Ross Tate,
      Max Rydahl Andersen,       Mladen Turk,                 Lucas Werkmeister,
      Roland Tepp,               Diego Coronel,               Matej Lazar,
      John Vasileff,             Toby Crawley,                Julien Viet,
      Loic Rouchon,              Stephane Gallès,             Ivo Kasiuk,
      Corbin Uselton,            Paco Soberón,                Michael Musgrove,
      Daniel Rochetti,           Henning Burdack,             Luke deGruchy,
      Rohit Mohan,               Griffin DeJohn,              Casey Dahlin,
      Gilles Duboscq,            Tomasz Krakowiak,            Alexander Altman,
      Alexander Zolotko,         Alex Szczuczko,              Andrés G. Aragoneses,
      Anh Nhan Nguyen,           Brice Dutheil,               Carlos Augusto Mar,
      Charles Gould,             Chris Gregory,               klinger,
      Martin Voelkle,            Mr. Arkansas,                Paŭlo Ebermann,
      Vorlent,                   Akber Choudhry,              Renato Athaydes,
      Flavio Oliveri,            Michael Brackx,              Brent Douglas,
      Lukas Eder,                Markus Rydh,                 Julien Ponge,
      Pete Muir,                 Nicolas Leroux,              Brett Cannon,
      Geoffrey De Smet,          Guillaume Lours,             Gunnar Morling,
      Jeff Parsons,              Jesse Sightler,              Oleg Kulikov,
      Raimund Klein,             Sergej Koščejev,             Chris Marshall,
      Simon Thum,                Maia Kozheva,                Shelby,
      Aslak Knutsen,             Fabien Meurisse,             Sjur Bakka,
      Xavier Coulon,             Ari Kast,                    Dan Allen,
      Deniz Türkoglu,            F. Meurisse,                 Jean-Charles Roger,
      Johannes Lehmann,          allentc,                     Nikolay Tsankov,
      Chris Horne,               Gabriel Mirea,               Georg Ragaller,
      Harald Wellmann,           Oliver Gondža,               Stephen Crawley,
      Byron Clark,               Francisco Reverbel,          Jonas Berlin,
      Luke Hutchison,            Nikita Ostroumov,            Santiago Rodriguez,
      Sean Flanigan.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2016/02/22/ceylon-test-new-and-noteworthy</id>
    <title>ceylon.test new and noteworthy</title>
    <updated>2016-02-22T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2016/02/22/ceylon-test-new-and-noteworthy" rel="alternate" type="text/html" />
    <author>
      <name>Tom&#225;&#353; Hradec</name>
    </author>
    <summary>
      Module ceylon.test
      (simple framework for writing repeatable tests) is an integral part of
      Ceylon SDK since its first version and in the latest release 1.2.1
      brings several handy new features, namely:
      
      
      Parameterized tests
      Conditional execution
      Grouped assertions
      Tagging and filtering
      Extension points
      Reporting
      
      
      
      Let's look at them in more details.
      
      
      
      
      Parameterized tests
      
      Parameterized tests allow developers to run the same test over and over
      again using different values, where each invocation of a test function is
      reported individually. A classical example for usage of parameterized tests
      is with a function computing Fibonacci numbers.
      
      
      
      
      shared {[Integer, Integer]*} fibonnaciNumbers =&gt; 
          {[1, 1], [2, 1], [3, 2], [4, 3], [5, 5], [6, 8] ...};
      
      test
      parameters(`value fibonnaciNumbers`)
      shared...
    </summary>
    <content type="html">
      &lt;p&gt;Module &lt;a href=&quot;https://herd.ceylon-lang.org/modules/ceylon.test&quot;&gt;ceylon.test&lt;/a&gt;
      (simple framework for writing repeatable tests) is an integral part of
      Ceylon SDK since its first version and in the latest release 1.2.1
      brings several handy new features, namely:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#parameterized_tests&quot;&gt;Parameterized tests&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#conditional_execution&quot;&gt;Conditional execution&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#grouped_assertions&quot;&gt;Grouped assertions&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tagging_and_filtering&quot;&gt;Tagging and filtering&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#extension_points&quot;&gt;Extension points&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#reporting&quot;&gt;Reporting&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Let's look at them in more details.&lt;/p&gt;
      
      &lt;br&gt;&lt;h2&gt;Parameterized tests&lt;/h2&gt;
      
      &lt;p&gt;Parameterized tests allow developers to run the same test over and over
      again using different values, where each invocation of a test function is
      reported individually. A classical example for usage of parameterized tests
      is with a function computing Fibonacci numbers.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;shared {[Integer, Integer]*} fibonnaciNumbers =&amp;gt; 
          {[1, 1], [2, 1], [3, 2], [4, 3], [5, 5], [6, 8] ...};
      
      test
      parameters(`value fibonnaciNumbers`)
      shared void shouldCalculateFibonacciNumber(Integer input, Integer result) {
          assert(fibonacciNumber(input) == result);
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;In this example, we use annotation &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/test/1.2.1/module-doc/api/index.html#parameters&quot;&gt;&lt;code&gt;parameters&lt;/code&gt;&lt;/a&gt; to specify the source of argument
      values, which will be used during test execution. You can use any top level value
      or unary function with a compatible type as the source of argument values. The argument
      provider can be specified for the whole function, as in this example, or individually
      for each parameter, then the test framework will execute the test for each combination
      of provided values. For example, a function with one parameter whose argument provider
      yields two values and a second parameter whose argument provider yields three values,
      will be executed six times.&lt;/p&gt;
      
      &lt;p&gt;This functionality is based on a general mechanism, which can be easily extended,
      e.g. serving values from data file or randomized testing. For more information see
      documentation to &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/test/1.2.1/module-doc/api/engine/spi/ArgumentListProvider.type&quot;&gt;&lt;code&gt;ArgumentProvider&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/test/1.2.1/module-doc/api/engine/spi/ArgumentListProvider.type&quot;&gt;&lt;code&gt;ArgumentListProvider&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
      
      &lt;br&gt;&lt;h2&gt;Conditional execution&lt;/h2&gt;
      
      &lt;p&gt;In some scenarios, the condition if the test can be reliable executed is known only in
      runtime. For this purpose it is useful to be able explicitly declare those &lt;em&gt;assumption&lt;/em&gt;,
      as for example in following test. When the assumption is not met, verified with
      &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/test/1.2.1/module-doc/api/index.html#assumeTrue&quot;&gt;&lt;code&gt;assumeTrue()&lt;/code&gt;&lt;/a&gt; function, then the test execution is interupted and the test is
      marked as &lt;em&gt;aborted&lt;/em&gt;.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;test
      shared void shouldUseNetwork() {
          assumeTrue(isOnline);
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Alternatively, it is possible to specify test condition declaratively, via custom
      annotation which satisfy SPI interface &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/test/1.2.1/module-doc/api/engine/spi/TestCondition.type.html&quot;&gt;&lt;code&gt;TestCondition&lt;/code&gt;&lt;/a&gt;. In fact the &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/test/1.2.1/module-doc/api/index.html#ignore&quot;&gt;&lt;code&gt;ignore&lt;/code&gt;&lt;/a&gt;
      annotation is just simple implementation of this concept.&lt;/p&gt;
      
      &lt;br&gt;&lt;h2&gt;Grouped assertions&lt;/h2&gt;
      
      &lt;p&gt;Sometimes you don't want to interrupt your test after first failed assertions,
      because you are interested to know all possible failures. In that case you can
      use &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/test/1.2.1/module-doc/api/index.html#assertAll&quot;&gt;&lt;code&gt;assertAll()&lt;/code&gt;&lt;/a&gt; function, which will verify all given assertions and any
      failures will report together.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;assertAll([
          () =&amp;gt; assertEquals(agent.id, &quot;007&quot;),
          () =&amp;gt; assertEquals(agent.firstName, &quot;James&quot;),
          () =&amp;gt; assertEquals(agent.lastName, &quot;Bond&quot;)]);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;br&gt;&lt;h2&gt;Tagging and filtering&lt;/h2&gt;
      
      &lt;p&gt;Test functions/methods and their containers (classes, packages) can be tagged,
      via annotation &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/test/1.2.1/module-doc/api/index.html#tag&quot;&gt;&lt;code&gt;tag&lt;/code&gt;&lt;/a&gt;. For example, a test which is failing randomly for
      unknown reasons can be marked as &lt;em&gt;unstable&lt;/em&gt;.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;test
      tag(&quot;unstable&quot;)
      shared void shouldSucceedWithLittleLuck() { ... }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Those tags can later be used for filtering tests. Either in inclusive style
      (only tests &lt;em&gt;with&lt;/em&gt; specified tag will be executed).&lt;/p&gt;
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ceylon test --tag=unstable com.acme.mymodule
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or visa versa for exclusion (only tests &lt;em&gt;without&lt;/em&gt; specified tag will be executed).&lt;/p&gt;
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ceylon test --tag=!unstable com.acme.mymodule
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;br&gt;&lt;h2&gt;Extension points&lt;/h2&gt;
      
      &lt;p&gt;Extension points are general mechanisms which allow to extend or modify default
      framework behavior and better integration with 3rd party libraries (e.g. custom
      reporters, integration with DI frameworks). The easiest way to register extensions
      is with annotation &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/test/1.2.1/module-doc/api/index.html#testExtension&quot;&gt;&lt;code&gt;testExtension&lt;/code&gt;&lt;/a&gt;, which can be placed on test itself, or on any
      of its container. Currently the following extension points are available, and new
      ones can be added if needed:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;listening events during test run
      &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/test/1.2.1/module-doc/api/TestListener.type.html&quot;&gt;TestListener&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;creating test class instance
      &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/test/1.2.1/module-doc/api/engine/spi/TestInstanceProvider.type.html&quot;&gt;TestInstanceProvider&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;post processing of test class instance
      &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/test/1.2.1/module-doc/api/engine/spi/TestInstancePostProcessor.type.html&quot;&gt;TestInstancePostProcessor&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;describing parameterized test
      &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/test/1.2.1/module-doc/api/engine/spi/TestVariantProvider.type.html&quot;&gt;TestVariantProvider&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;resolving all possible argument lists combination for parameterized test
      &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/test/1.2.1/module-doc/api/engine/spi/ArgumentListResolver.type.html&quot;&gt;ArgumentListResolver&lt;/a&gt;
      &lt;/li&gt;
      &lt;/ul&gt;&lt;br&gt;&lt;h2&gt;Reporting&lt;/h2&gt;
      
      &lt;p&gt;These two last features have already been available for some time, but they could easily
      have slipped your attention. The first is nice html report with results of test execution,
      to enable it, run the test tool with &lt;code&gt;--report&lt;/code&gt; option, it will be generated
      under &lt;code&gt;report/test(-js)&lt;/code&gt; subdirectory.&lt;/p&gt;
      
      &lt;p&gt;&lt;img src=&quot;https://ceylon-lang.org/images/screenshots/ceylon-test-html-report.png&quot; style=&quot;max-width:600px;&quot;&gt;&lt;/p&gt;
      
      &lt;p&gt;The second is support for Test Anything Protocol (&lt;a href=&quot;https://en.wikipedia.org/wiki/Test_Anything_Protocol&quot;&gt;TAP&lt;/a&gt;), which allow integration
      with CI servers. To enable run the test tool with &lt;code&gt;--tap&lt;/code&gt; option.&lt;/p&gt;
      
      &lt;br&gt;&lt;p&gt;&lt;em&gt;And if you don't have enough, just look on excellent library, built on top
      of &lt;code&gt;ceylon.test&lt;/code&gt; which enables BDD style of test development and much more,
      called &lt;a href=&quot;https://github.com/renatoathaydes/specks&quot;&gt;specks&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2016/02/15/ceylon-browser-again</id>
    <title>Ceylon in the browser (again)</title>
    <updated>2016-02-15T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2016/02/15/ceylon-browser-again" rel="alternate" type="text/html" />
    <author>
      <name>Bastien Jansen</name>
    </author>
    <summary>
      As you might (or might not) know, Ceylon is more than a JVM language. It has been possible to compile Ceylon code
      to JavaScript for a long time, but other platforms
      such as Dart or LLVM
      are around the corner.
      
      Having a JS backend means that you can actually write Ceylon code that can be
      run in a web browser, giving the opportunity to share code
      between the server and the client. The web IDE is a very good example of this. Up until now,
      using Ceylon in a browser wasn't really straightforward though. The good news is, Ceylon 1.2.1 brought two major
      features that overcome this problem:
      
      
      a...
    </summary>
    <content type="html">
      &lt;p&gt;As you might (or might not) know, Ceylon is more than a JVM language. It has been possible to compile Ceylon code
      to JavaScript &lt;a href=&quot;https://ceylon-lang.org/blog/2011/12/31/compiling-ceylon-2-js/&quot;&gt;for a long time&lt;/a&gt;, but other platforms
      such as &lt;a href=&quot;https://github.com/jvasileff/ceylon-dart&quot;&gt;Dart&lt;/a&gt; or &lt;a href=&quot;https://github.com/sadmac7000/org.americanteeth.ceylon_llvm&quot;&gt;LLVM&lt;/a&gt;
      are around the corner.&lt;/p&gt;
      
      &lt;p&gt;Having a JS backend means that you can actually write Ceylon code that can be
      &lt;a href=&quot;https://ceylon-lang.org/blog/2013/02/26/ceylon-in-the-browser/&quot;&gt;run in a web browser&lt;/a&gt;, giving the opportunity to share code
      between the server and the client. The &lt;a href=&quot;https://try.ceylon-lang.org&quot;&gt;web IDE&lt;/a&gt; is a very good example of this. Up until now,
      using Ceylon in a browser wasn't really straightforward though. The good news is, Ceylon 1.2.1 brought two major
      features that overcome this problem:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;a &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/net/1.2.1/module-doc/api/http/server/endpoints/RepositoryEndpoint.type.html&quot;&gt;RepositoryEndpoint&lt;/a&gt; in &lt;code&gt;ceylon.net&lt;/code&gt; on the server side&lt;/li&gt;
      &lt;li&gt;a new JS module &lt;a href=&quot;https://herd.ceylon-lang.org/modules/ceylon.interop.browser&quot;&gt;ceylon.interop.browser&lt;/a&gt; on the client side&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Let's see how these fit together.&lt;/p&gt;
      
      &lt;h2&gt;Creating a new project&lt;/h2&gt;
      
      &lt;p&gt;First things first, we need an empty project that will hold two modules:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;com.acme.client&lt;/code&gt; is a &lt;code&gt;native(&quot;js&quot;)&lt;/code&gt; module that imports &lt;code&gt;ceylon.interop.browser&lt;/code&gt;:&lt;/p&gt;
      
      &lt;p&gt;  native(&quot;js&quot;)
        module com.acme.client &quot;1.0.0&quot; {
            import ceylon.interop.browser &quot;1.2.1-1&quot;;
        }&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;p&gt;&lt;code&gt;com.acme.server&lt;/code&gt; is a &lt;code&gt;native(&quot;jvm&quot;)&lt;/code&gt; module that imports &lt;code&gt;ceylon.net&lt;/code&gt;:&lt;/p&gt;
      
      &lt;p&gt;  native(&quot;jvm&quot;)
        module com.acme.server &quot;1.0.0&quot; {
            import ceylon.net &quot;1.2.1&quot;;
        }&lt;/p&gt;
      &lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Serving Ceylon modules&lt;/h2&gt;
      
      &lt;p&gt;In order to run &lt;code&gt;com.acme.client&lt;/code&gt; in a browser, we have to import it from an HTML file. The recommended way is to use
      &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;:&lt;/p&gt;
      
      &lt;!-- lang: html --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
      &amp;lt;html lang=&quot;en&quot;&amp;gt;
      &amp;lt;head&amp;gt;
          &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
          &amp;lt;title&amp;gt;Hello from Ceylon!&amp;lt;/title&amp;gt;
      &amp;lt;/head&amp;gt;
      &amp;lt;body&amp;gt;
          &amp;lt;div id=&quot;container&quot;&amp;gt;
          &amp;lt;/div&amp;gt;
          &amp;lt;script src=&quot;//requirejs.org/docs/release/2.1.22/minified/require.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
          &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
          require.config({
              baseUrl : 'modules'
          });
          require(
                  [ 'com/acme/client/1.0.0/com.acme.client-1.0.0' ],
                  function(app) {
                      app.run();
                  }
          );
          &amp;lt;/script&amp;gt;
      &amp;lt;/body&amp;gt;
      &amp;lt;/html&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Here, we tell RequireJS to use the prefix &lt;code&gt;modules&lt;/code&gt; when downloading artifacts from the server, which means
      we need something on a server that will listen on &lt;code&gt;/modules&lt;/code&gt;, parse module names and serve the correct artifact.&lt;/p&gt;
      
      &lt;h3&gt;Option 1: using a Ceylon server&lt;/h3&gt;
      
      &lt;p&gt;Ceylon SDK 1.2.1 introduced a new endpoint named &lt;code&gt;RepositoryEndpoint&lt;/code&gt;, that uses a &lt;code&gt;RepositoryManager&lt;/code&gt; to look
      up module artifacts in one or more Ceylon repositories, like the compiler or Ceylon IDE do:&lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;import ceylon.net.http.server.endpoints {
          RepositoryEndpoint
      }
      import ceylon.net.http.server {
          newServer
      }
      
      &quot;Run the module `com.acme.server`.&quot;
      shared void run() {
          value modulesEp = RepositoryEndpoint(&quot;/modules&quot;);
          value server = newServer { modulesEp };
      
          server.start();
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;By default, this endpoint will look for artifacts in your local Ceylon repository, but also in the compiler's output
      directory. This greatly simplifies our development workflow, because each time we modify files in &lt;code&gt;com.acme.client&lt;/code&gt;,
      Ceylon IDE will rebuild the JS artifacts, which can then be immediately refreshed in the browser.&lt;/p&gt;
      
      &lt;p&gt;Finally, to serve static files (HTML, CSS, images etc), we need a second endpoint that uses &lt;code&gt;serveStaticFile&lt;/code&gt;
      to look up files in the &lt;code&gt;www&lt;/code&gt; folder, and serve &lt;code&gt;index.html&lt;/code&gt; by default:&lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;function mapper(Request req) 
              =&amp;gt; req.path == &quot;/&quot; then &quot;/index.html&quot; else req.path;
      
      value staticEp = AsynchronousEndpoint(
          startsWith(&quot;/&quot;), 
          serveStaticFile(&quot;www&quot;, mapper),
          {get}
      );
      
      value server = newServer { modulesEp, staticEp };
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;If we start the server and open &lt;code&gt;http://localhost:8080/&lt;/code&gt;, we can see in the web inspector that the modules
      are correctly loaded:&lt;/p&gt;
      
      &lt;p&gt;&lt;img src=&quot;https://ceylon-lang.org/images/screenshots/ceylon-browser/network.png&quot; height=&quot;273&quot;&gt;&lt;/p&gt;
      
      &lt;h3&gt;Option 2: using static HTTP servers&lt;/h3&gt;
      
      &lt;p&gt;Option 1 is interesting if you already have a backend written in Ceylon. Otherwise, it might be a little
      too heavy because you're basically starting a Ceylon server just to serve static files. Luckily, there's
      a way to create a standard Ceylon repository containing a module and all its dependencies:
      &lt;a href=&quot;http://ceylon-lang.org/documentation/current/reference/tool/ceylon/subcommands/ceylon-copy.html&quot;&gt;&lt;code&gt;ceylon copy&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;ceylon copy --with-dependencies com.acme.client
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This command will copy the module &lt;code&gt;com.acme.client&lt;/code&gt; and all its dependencies to a given folder (by default
      &lt;code&gt;./modules&lt;/code&gt;), preserving a repository layout like the one RequireJs expects. This means we can start httpd
      or nginx and bind them directly on the project folder. Modules will be loaded from &lt;code&gt;./modules&lt;/code&gt;, we just have
      to configure the server to look for other files in the &lt;code&gt;www&lt;/code&gt; directory.&lt;/p&gt;
      
      &lt;p&gt;Attention though, each time we modify dependencies of &lt;code&gt;com.acme.client&lt;/code&gt;, we will have to run &lt;code&gt;ceylon copy&lt;/code&gt; again
      to update the local repository.&lt;/p&gt;
      
      &lt;p&gt;Option 2 is clearly the way to go for client apps that don't require a backend. Like option 1, it doesn't force
      you to publish artifacts in &lt;code&gt;~/.ceylon/repo&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Of course, if you are running a local Ceylon JS application, and your browser allows you to include files directly from
      the filesystem, you can also avoid the HTTP server and load everything for the filesystem.&lt;/p&gt;
      
      &lt;h2&gt;Using browser APIs&lt;/h2&gt;
      
      &lt;p&gt;Now that we have bootstrapped a Ceylon application running in a browser, it's time to do actual things
      that leverage browser APIs. To do this, we'll use the brand new &lt;code&gt;ceylon.interop.browser&lt;/code&gt; which was
      introduced in the Ceylon SDK 1.2.1 a few days ago. Basically, it's a set of
      &lt;a href=&quot;https://ceylon-lang.org/blog/2014/10/13/dynamic-interfaces/&quot;&gt;&lt;code&gt;dynamic&lt;/code&gt; interfaces&lt;/a&gt; that
      allow wrapping native JS objects returned by the browser in nice typed Ceylon instances. For example, this
      interface represents the browser's &lt;code&gt;Document&lt;/code&gt;:&lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;shared dynamic Document satisfies Node &amp;amp; GlobalEventHandlers {
          shared formal String \iURL;
          shared formal String documentURI;
          ...
          shared formal HTMLCollection getElementsByTagName(String localName);
          shared formal HTMLCollection getElementsByClassName(String classNames);
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;An instance of &lt;code&gt;Document&lt;/code&gt; can be retrieved via the toplevel object &lt;code&gt;document&lt;/code&gt;, just like in JavaScript:&lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;shared Document document =&amp;gt; window.document;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Note that &lt;code&gt;window&lt;/code&gt; is also a toplevel instance of the dynamic interface &lt;code&gt;Window&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;&lt;code&gt;ceylon.interop.browser&lt;/code&gt; contains lots of interfaces related to:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.w3.org/TR/dom/#nodes&quot;&gt;DOM nodes&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.w3.org/TR/dom/#events&quot;&gt;DOM events&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.w3.org/TR/dom/#traversal&quot;&gt;DOM traversal&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Making an AJAX call, retrieving the result and adding it to a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; is now super easy in Ceylon:&lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;import ceylon.interop.browser.dom {
          document,
          Event
      }
      import ceylon.interop.browser {
          newXMLHttpRequest
      }
      
      shared void run() {
          value req = newXMLHttpRequest();
      
          req.onload = void (Event evt) {
              if (exists container = document.getElementById(&quot;container&quot;)) {
                  value title = document.createElement(&quot;h1&quot;);
                  title.textContent = &quot;Hello from Ceylon&quot;;
                  container.appendChild(title);
      
                  value content = document.createElement(&quot;p&quot;);
                  content.innerHTML = req.responseText;
                  container.appendChild(content);
              }
          };
      
          req.open(&quot;GET&quot;, &quot;/msg.txt&quot;);
          req.send();
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h2&gt;Going further&lt;/h2&gt;
      
      &lt;p&gt;Dynamic interfaces are really nice when it comes to using JavaScript objects in Ceylon. They are somewhat
      similar to TypeScript's &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;type definitions&lt;/a&gt;, which means
      in theory, it is possible to use any JavaScript framework directly from Ceylon, provided that someone writes dynamic
      interfaces for its API.&lt;/p&gt;
      
      &lt;p&gt;The Ceylon team is currently looking for ways to &lt;a href=&quot;https://github.com/ceylon/ceylon/issues/3041&quot;&gt;load TypeScript definitions and make them available to Ceylon modules&lt;/a&gt;,
      which would greatly simplify the process of adding support for a new framework/API.&lt;/p&gt;
      
      &lt;p&gt;The &lt;a href=&quot;https://github.com/bjansen/ceylon-browser-demo&quot;&gt;complete source code&lt;/a&gt; for this article is available on GitHub.&lt;/p&gt;
      
      &lt;p&gt;A &lt;a href=&quot;http://try.ceylon-lang.org/?gist=c7e291bc337b5b260de4&quot;&gt;live example&lt;/a&gt; is available on the Web IDE.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2016/02/11/ceylon-1-2-1</id>
    <title>Ceylon 1.2.1 is now available</title>
    <updated>2016-02-11T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2016/02/11/ceylon-1-2-1" rel="alternate" type="text/html" />
    <author>
      <name>St&#233;phane &#201;pardaud</name>
    </author>
    <summary>
      Three months after the last major release,
      Ceylon 1.2.1 is a new maintenance release,
      with almost 100 issues closed, including new features,
      improvements and bug fixes such as:
      
      
      you can now iterate java.lang.Iterable values in for statements
      and use java.lang.AutoCloseable values in try statements,
      support for Java 9 and Jigsaw modules,
      experimental support for type functions on the JVM,
      reduced run-time dependencies for your Ceylon program,
      better interoperation with JavaScript arrays,
      better compatibility with previous and future Ceylon releases.
      
      
      
      Note that for the JVM backend, this release is backwards-compatible
      with the previous major release (1.2.0), which means you can use
      modules compiled with 1.2.0 on a 1.2.1 distribution out of the box.
      This is...
    </summary>
    <content type="html">
      &lt;p&gt;Three months after the last major release,
      &lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;Ceylon 1.2.1&lt;/a&gt; is a new maintenance release,
      with almost &lt;a href=&quot;https://github.com/ceylon/ceylon/issues?q=is%3Aissue+milestone%3A1.2.1+is%3Aclosed&quot;&gt;100 issues&lt;/a&gt; closed, including new features,
      improvements and bug fixes such as:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;you can now iterate &lt;code&gt;java.lang.Iterable&lt;/code&gt; values in &lt;code&gt;for&lt;/code&gt; statements
      and use &lt;code&gt;java.lang.AutoCloseable&lt;/code&gt; values in &lt;code&gt;try&lt;/code&gt; statements,&lt;/li&gt;
      &lt;li&gt;support for &lt;a href=&quot;https://ceylon-lang.org/blog/2015/12/17/java9-jigsaw&quot;&gt;Java 9 and Jigsaw modules&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;experimental support for &lt;a href=&quot;https://ceylon-lang.org/blog/2015/06/03/generic-function-refs/&quot;&gt;type functions&lt;/a&gt; on the JVM,&lt;/li&gt;
      &lt;li&gt;reduced run-time dependencies for your Ceylon program,&lt;/li&gt;
      &lt;li&gt;better interoperation with JavaScript arrays,&lt;/li&gt;
      &lt;li&gt;better compatibility with previous and future Ceylon releases.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Note that for the JVM backend, this release is backwards-compatible
      with the previous major release (&lt;code&gt;1.2.0&lt;/code&gt;), which means you can use
      modules compiled with &lt;code&gt;1.2.0&lt;/code&gt; on a &lt;code&gt;1.2.1&lt;/code&gt; distribution out of the box.
      This is not as easy the other way around, if you want to run modules
      compiled for &lt;code&gt;1.2.1&lt;/code&gt; on a &lt;code&gt;1.2.0&lt;/code&gt; distribution, which is why we
      recommend you upgrade to &lt;code&gt;1.2.1&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Sadly, on the JavaScript backend, we had to break binary compatibility
      to fix serious interoperation issues, and so modules compiled for &lt;code&gt;1.2.1&lt;/code&gt;
      and &lt;code&gt;1.2.0&lt;/code&gt; are not compatible. We recommend you upgrade your distribution
      to &lt;code&gt;1.2.1&lt;/code&gt; and recompile your modules.&lt;/p&gt;
      
      &lt;h2&gt;About Ceylon&lt;/h2&gt;
      
      &lt;p&gt;Ceylon is a modern, modular, statically typed programming
      language for the Java and JavaScript virtual machines. The
      language features a flexible and very readable syntax, a
      unique and uncommonly elegant static type system, a powerful
      module architecture, and excellent tooling, including an
      awesome Eclipse-based IDE.&lt;/p&gt;
      
      &lt;p&gt;Ceylon enables the development of cross-platform modules
      that execute portably in both virtual machine environments.
      Alternatively, a Ceylon module may target one or the other
      platform, in which case it may interoperate with native code
      written for that platform.&lt;/p&gt;
      
      &lt;h2&gt;In the box&lt;/h2&gt;
      
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;This release&lt;/a&gt; includes:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;a complete &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/spec&quot;&gt;language specification&lt;/a&gt; that defines the
      syntax and semantics of Ceylon in language accessible to
      the professional developer,&lt;/li&gt;
      &lt;li&gt;a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/reference/tool/ceylon/subcommands/index.html&quot;&gt;command line toolset&lt;/a&gt; including compilers for
      Java and JavaScript, a documentation compiler, a test
      runner, a WAR archive packager, and support for executing
      modular programs on the JVM and Node.js,&lt;/li&gt;
      &lt;li&gt;a powerful module architecture for code organization,
      dependency management, and module isolation at runtime,&lt;/li&gt;
      &lt;li&gt;the &lt;a href=&quot;https://herd.ceylon-lang.org/modules/ceylon.language&quot;&gt;language module&lt;/a&gt;, our minimal,
      cross-platform foundation of the &lt;a href=&quot;https://modules.ceylon-lang.org/categories/SDK&quot;&gt;Ceylon SDK&lt;/a&gt;, and&lt;/li&gt;
      &lt;li&gt;a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/ide/features/&quot;&gt;full-featured&lt;/a&gt; Eclipse-based integrated
      development environment.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Language&lt;/h2&gt;
      
      &lt;p&gt;Ceylon is a highly understandable object-oriented language
      with static typing. The language features:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;an emphasis upon &lt;strong&gt;readability&lt;/strong&gt; and a strong bias toward
      &lt;strong&gt;omission or elimination of potentially-harmful or
      potentially-ambiguous constructs&lt;/strong&gt; and toward highly
      &lt;strong&gt;disciplined use of static types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;an extremely powerful and uncommonly elegant type system
      combining subtype and parametric polymorphism with:
      
      &lt;ul&gt;
      &lt;li&gt;first-class &lt;strong&gt;union and intersection types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;both &lt;strong&gt;declaration-site and use-site variance&lt;/strong&gt;, and&lt;/li&gt;
      &lt;li&gt;the use of principal types for &lt;strong&gt;local type inference&lt;/strong&gt;
      and &lt;strong&gt;flow-sensitive typing&lt;/strong&gt;,&lt;/li&gt;
      &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;a unique treatment of &lt;strong&gt;function and tuple types&lt;/strong&gt;,
      enabling powerful abstractions, along with the most
      &lt;strong&gt;elegant approach to &lt;code&gt;null&lt;/code&gt;&lt;/strong&gt; of any modern language,&lt;/li&gt;
      &lt;li&gt;first-class constructs for defining &lt;strong&gt;modules and
      dependencies between modules&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;a very flexible syntax including &lt;strong&gt;comprehensions&lt;/strong&gt; and
      support for expressing &lt;strong&gt;tree-like structures&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;fully-reified generic types&lt;/strong&gt;, on both the JVM and
      JavaScript virtual machines, and a unique &lt;strong&gt;typesafe
      metamodel&lt;/strong&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;More information about these language features may be
      found in the &lt;a href=&quot;https://ceylon-lang.org/features&quot;&gt;feature list&lt;/a&gt; and
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/introduction/&quot;&gt;quick introduction&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;IDE&lt;/h2&gt;
      
      &lt;p&gt;Ceylon IDE now features the following improvements, along
      with many bugfixes and a number of performance enhancements:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;improved documentation hover,&lt;/li&gt;
      &lt;li&gt;better UI responsiveness,&lt;/li&gt;
      &lt;li&gt;support running on Java 9.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;A number of important subsystems have been abstracted and
      rewritten in Ceylon, to support the ongoing development of
      the new IntelliJ-based IDE for Ceylon.&lt;/p&gt;
      
      &lt;h2&gt;SDK&lt;/h2&gt;
      
      &lt;p&gt;The &lt;a href=&quot;https://modules.ceylon-lang.org/categories/SDK&quot;&gt;platform modules&lt;/a&gt;, recompiled for 1.2.1, are
      available in the shared community repository, &lt;a href=&quot;https://herd.ceylon-lang.org&quot;&gt;Ceylon Herd&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;This release introduces several new platform modules:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.numeric&lt;/code&gt; is a cross-platform module containing math
      operations for &lt;code&gt;Integer&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt;. In time it will replace parts of
      the JVM-only &lt;code&gt;ceylon.math&lt;/code&gt; module.&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.decimal&lt;/code&gt; is a JVM-only module (but soon to be cross-platform)
      containing arbitrary-length decimal support. In time it will replace parts of
      the JVM-only &lt;code&gt;ceylon.math&lt;/code&gt; module.&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.whole&lt;/code&gt; is a cross-platform module containing arbitrary-length
      integer support. In time it will replace parts of
      the JVM-only &lt;code&gt;ceylon.math&lt;/code&gt; module.&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.random&lt;/code&gt; is a cross-platform module containing random number
      generators. In time it will replace parts of
      the JVM-only &lt;code&gt;ceylon.math&lt;/code&gt; module.&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.interop.browser&lt;/code&gt; contains JavaScript-only interoperation
      functions and types for the DOM, HTML and &lt;code&gt;XMLHttpRequest&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Along with several API enhancements and bugfixes, including:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Many new features for &lt;code&gt;ceylon.test&lt;/code&gt;, the Ceylon Test Suite.&lt;/li&gt;
      &lt;li&gt;Performance improvement of the &lt;code&gt;ceylon.json&lt;/code&gt; parser.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Web IDE&lt;/h2&gt;
      
      &lt;p&gt;You can try Ceylon using the &lt;a href=&quot;http://try.ceylon-lang.org&quot;&gt;Web IDE&lt;/a&gt;, featuring syntax highlighting,
      interactive error reporting, autocompletion, online
      documentation, and persistence and code sharing via Gist.&lt;/p&gt;
      
      &lt;p&gt;The Web IDE serves a dual purpose as a standard example
      demonstrating the use of Ceylon for web application
      development and deployment to the &lt;a href=&quot;http://openshift.com&quot;&gt;OpenShift&lt;/a&gt; cloud
      platform.&lt;/p&gt;
      
      &lt;h2&gt;Community&lt;/h2&gt;
      
      &lt;p&gt;The Ceylon community site, &lt;a href=&quot;http://ceylon-lang.org&quot;&gt;http://ceylon-lang.org&lt;/a&gt;, includes
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2&quot;&gt;documentation&lt;/a&gt;, and information about
      &lt;a href=&quot;https://ceylon-lang.org/community/&quot;&gt;getting involved&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Source code&lt;/h2&gt;
      
      &lt;p&gt;The source code for Ceylon, its specification, and its website,
      is freely available from &lt;a href=&quot;https://github.com/ceylon&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;Information about Ceylon's open source licenses is available
      &lt;a href=&quot;https://ceylon-lang.org/code/licenses/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Issues&lt;/h2&gt;
      
      &lt;p&gt;Bugs and suggestions may be reported in GitHub's
      &lt;a href=&quot;https://ceylon-lang.org/code/issues&quot;&gt;issue tracker&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Migrating from Ceylon 1.2.0&lt;/h2&gt;
      
      &lt;p&gt;Migration from Ceylon 1.2.0 is easy. To recompile a module for
      1.2.1:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;First ensure that its dependencies have also been
      recompiled.&lt;/li&gt;
      &lt;li&gt;If it imports a Ceylon SDK platform module, upgrade the
      version number specified by the module &lt;code&gt;import&lt;/code&gt; statement
      from &lt;code&gt;&quot;1.2.0&quot;&lt;/code&gt; to &lt;code&gt;&quot;1.2.1&quot;&lt;/code&gt; .&lt;/li&gt;
      &lt;li&gt;If it was compiled against Ceylon &lt;code&gt;1.2.0&lt;/code&gt; you should still
      be able to use it in &lt;code&gt;1.2.1&lt;/code&gt; for the JVM backend,
      as it is backwards-compatible. Sadly, this is not the case
      for the JavaScript backend, and so you will need to recompile
      your modules with &lt;code&gt;1.2.1&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Acknowledgement&lt;/h2&gt;
      
      &lt;p&gt;As always, we're deeply grateful to the community volunteers
      who contributed a substantial part of the current Ceylon
      codebase, working in their own spare time. The following
      people have contributed to Ceylon:&lt;/p&gt;
      
      &lt;p&gt;Gavin King, Stéphane Épardaud, Tako Schotanus, Tom Bentley,
      David Festal, Enrique Zamudio, Bastien Jansen,
      Emmanuel Bernard, Aleš Justin, Tomáš Hradec, James Cobb,
      Ross Tate, Max Rydahl Andersen, Mladen Turk,
      Lucas Werkmeister, Roland Tepp, Diego Coronel, Matej Lazar,
      John Vasileff, Toby Crawley, Julien Viet, Loic Rouchon,
      Stephane Gallès, Ivo Kasiuk, Corbin Uselton, Paco Soberón,
      Michael Musgrove, Daniel Rochetti, Henning Burdack,
      Luke deGruchy, Rohit Mohan, Griffin DeJohn, Casey Dahlin,
      Alexander Altman, Alexander Zolotko, Alex Szczuczko,
      Andrés G. Aragoneses, Anh Nhan Nguyen, Brice Dutheil,
      Carlos Augusto Mar, Charles Gould, Chris Gregory, klinger,
      Martin Voelkle, Mr. Arkansas, Paŭlo Ebermann, Vorlent,
      Akber Choudhry, Renato Athaydes, Flavio Oliveri,
      Michael Brackx, Brent Douglas, Lukas Eder, Markus Rydh,
      Julien Ponge, Pete Muir, Nicolas Leroux, Brett Cannon,
      Geoffrey De Smet, Guillaume Lours, Gunnar Morling,
      Jeff Parsons, Jesse Sightler, Oleg Kulikov, Raimund Klein,
      Sergej Koščejev, Chris Marshall, Simon Thum, Maia Kozheva,
      Shelby, Aslak Knutsen, Fabien Meurisse, Sjur Bakka,
      Xavier Coulon, Ari Kast, Dan Allen, Deniz Türkoglu,
      F. Meurisse, Jean-Charles Roger, Johannes Lehmann, allentc,
      Nikolay Tsankov, Chris Horne, Gabriel Mirea, Georg Ragaller,
      Harald Wellmann, klinger, Oliver Gondža, Stephen Crawley,
      Byron Clark, Francisco Reverbel, Jonas Berlin, Luke Hutchison,
      Nikita Ostroumov, Santiago Rodriguez, Sean Flanigan.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/12/17/java9-jigsaw</id>
    <title>Ceylon on Java 9 + Jigsaw</title>
    <updated>2015-12-17T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/12/17/java9-jigsaw" rel="alternate" type="text/html" />
    <author>
      <name>St&#233;phane &#201;pardaud</name>
    </author>
    <summary>
      Everyone is talking about modules these days. New languages try to incorporate them,
      and older languages try to retrofit them in. Which is great news, because modules are
      essential. Java 9 is around the corner, because it's supposed to come out next year,
      and the really big new feature is modularity, which it calls the
      Jigsaw project.
      
      Ceylon is a language that featured modularity from the start, as part of the language
      and not as an afterthought requiring complex third-party tool integration. In fact,
      at the time we designed our Java JDK integration (at the time of Java 7), we went
      as far as using the Jigsaw modularity...
    </summary>
    <content type="html">
      &lt;p&gt;Everyone is talking about modules these days. New languages try to incorporate them,
      and older languages try to retrofit them in. Which is great news, because modules are
      essential. Java 9 is around the corner, because it's supposed to come out next year,
      and the really big new feature is modularity, which it calls the
      &lt;a href=&quot;http://openjdk.java.net/projects/jigsaw/&quot;&gt;Jigsaw project&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;Ceylon is a language that featured modularity from the start, as part of the language
      and not as an afterthought requiring complex third-party tool integration. In fact,
      at the time we designed our Java JDK integration (at the time of Java 7), we went
      as far as using the Jigsaw modularity plans for the JDK (yes Jigsaw got delayed a
      few times) from the start, requiring JDK users to
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/reference/interoperability/java-from-ceylon/#importing_jdk_modules&quot;&gt;import Jigsaw modules&lt;/a&gt;
      as they were
      planned at the time, rather than import the whole JDK in one go. So perhaps we were the
      first ones with a modular JDK, in some sense :)&lt;/p&gt;
      
      &lt;h2&gt;Java 9’s Jigsaw&lt;/h2&gt;
      
      &lt;p&gt;Jigsaw is a very large project, which includes the following changes:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://openjdk.java.net/jeps/200&quot;&gt;Modularisation of the JDK&lt;/a&gt; into smaller units,
      such as &lt;code&gt;java.base&lt;/code&gt;, &lt;code&gt;java.xml&lt;/code&gt; that Ceylon users of the JDK are already familiar with.&lt;/li&gt;
      &lt;li&gt;This modularisation means removal of &lt;code&gt;rt.jar&lt;/code&gt; that contained every JDK class. In fact
      it's been replaced by a &lt;code&gt;bootmodules.jimage&lt;/code&gt; file which is not a jar, but whose contents
      &lt;a href=&quot;http://openjdk.java.net/jeps/220&quot;&gt;can be accessed by a virtual NIO &lt;code&gt;FileSystem&lt;/code&gt; at &lt;code&gt;jrt:/&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
      &lt;li&gt;You can &lt;a href=&quot;http://openjdk.java.net/projects/jigsaw/spec/&quot;&gt;write your own modules&lt;/a&gt;.
      To turn your Java code into a Java 9 module, you simply
      add a module descriptor in a file called &lt;code&gt;module-info.java&lt;/code&gt; (much like Ceylon module
      descriptors, or Java package descriptors), which describes your module and the Java 9
      compiler and jar tools will then generate a jar with a &lt;code&gt;module-info.class&lt;/code&gt; descriptor
      at the root of the jar.&lt;/li&gt;
      &lt;li&gt;That &lt;a href=&quot;http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html&quot;&gt;module descriptor&lt;/a&gt;
      allows you to specify the module name, the packages it exports,
      the name of the modules it imports and a few other things. But not versions, unfortunately,
      which are currently &quot;out of scope&quot; in Java 9.&lt;/li&gt;
      &lt;li&gt;You can run your code as previously from the classpath, or as modules from the
      &lt;em&gt;module path&lt;/em&gt;. The module path is just a folder in which you can place your modules and
      the JRE will look them up for you based on module name alone.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Ceylon and Jigsaw&lt;/h2&gt;
      
      &lt;p&gt;Java 9 has two &lt;em&gt;early-access&lt;/em&gt; (EA) downloads for users to try the module system. Only
      &lt;a href=&quot;https://jdk9.java.net/jigsaw/&quot;&gt;one of them includes user modules&lt;/a&gt;.
      Make sure you use that one if you want to try out Ceylon running on Java 9.&lt;/p&gt;
      
      &lt;p&gt;Over the past weeks I've worked on getting Ceylon compiling and running on Java 9. This
      involved (among other details) the following things:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Generating &lt;code&gt;module-info.class&lt;/code&gt; files from Ceylon module descriptors.&lt;/li&gt;
      &lt;li&gt;Generating &lt;code&gt;module-info.class&lt;/code&gt; files for the Ceylon distribution modules which are not
      written in Ceylon (like the compilers or runtime system).&lt;/li&gt;
      &lt;li&gt;Making use of the Java 9 module descriptors for the &lt;code&gt;shared&lt;/code&gt; packages information it contains
      (something supported by Ceylon since the beginning, but which was lacking for plain Java jars).&lt;/li&gt;
      &lt;li&gt;Backporting Java 9 code that deals with modules to the &lt;code&gt;javac&lt;/code&gt; fork we use to compile Java
      files and generate bytecode.&lt;/li&gt;
      &lt;li&gt;Dealing with the removal of &lt;code&gt;rt.jar&lt;/code&gt; and the &lt;em&gt;boot classpath&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;Creating a new tool &lt;code&gt;ceylon jigsaw&lt;/code&gt; which allows for the creation of a Java 9 &lt;em&gt;module path&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;Making sure we can run Ceylon modules as Java 9 modules as an alternative to the four existing
      JVM runtimes which are the JBoss Modules, classpath, OSGi or Java EE.&lt;/li&gt;
      &lt;li&gt;Make sure we can build and run on any of Java 7,8,9. This means that by default we do not
      generate Java 9 module descriptors, because several tools have problems dealing with them
      at this time.&lt;/li&gt;
      &lt;li&gt;We have split some things out of the &lt;code&gt;ceylon.language&lt;/code&gt; module so that it no longer depends
      on the compilers and type-checker, which means a lighter minimal runtime, which will be even
      further improved in the next weeks with more dependency removals :)&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Just tell me how to try this!&lt;/h2&gt;
      
      &lt;p&gt;I will spare you the many details of this work, but with help from the Java 9 team, this is how
      you can run your Ceylon modules on a Java 9 runtime:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Download the &lt;a href=&quot;https://jdk9.java.net/jigsaw/&quot;&gt;Java 9 EA with Jigsaw&lt;/a&gt;.&lt;/li&gt;
      &lt;li&gt;Get the &lt;a href=&quot;https://github.com/ceylon/ceylon&quot;&gt;Ceylon distribution code&lt;/a&gt;,
      and compile it with &lt;code&gt;ant -Djigsaw=true clean dist&lt;/code&gt; to get the Java 9 module descriptors.&lt;/li&gt;
      &lt;li&gt;Write your Ceylon module normally, but compile it with
      &lt;code&gt;.../ceylon/dist/dist/bin/ceylon compile --generate-module-info&lt;/code&gt; to generate the Java 9 module
      descriptors.&lt;/li&gt;
      &lt;li&gt;Create your Java 9 module path in an &lt;code&gt;mlib&lt;/code&gt; folder with
      &lt;code&gt;.../ceylon/dist/dist/bin/ceylon jigsaw create-mlib my.module/1&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Run your Ceylon module on Java 9 with
      &lt;code&gt;.../jdk1.9.0-jigsaw/bin/java -mp mlib -m ceylon.language my.module/1&lt;/code&gt;. At the moment, the
      &lt;code&gt;ceylon.language&lt;/code&gt; module acts as main module and does the required setting up of the Ceylon
      runtime before loading and invoking your Ceylon module.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;That's all there is to it!&lt;/p&gt;
      
      &lt;h2&gt;Caveats&lt;/h2&gt;
      
      &lt;p&gt;Java 9 is not complete yet, and our support for Java 9 is also not complete. There will be issues
      and bugs, and in fact we already know of several limitations, such as the following:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;While you can import a &lt;em&gt;pure&lt;/em&gt; Java 9 module from Ceylon, we will respect its exported packages,
      but we will not respect its dependencies, because Java 9 modules do not include dependency versions.
      In fact, even the module's version is not stored in the source module descriptor, but added by
      an optional flag to the Java 9 &lt;code&gt;jar&lt;/code&gt; tool. Ceylon requires module dependencies to describe a
      version, so we have to combine the Java 9 module descriptor with another descriptor such as an
      OSGi descriptor or a Maven &lt;code&gt;pom.xml&lt;/code&gt; descriptor. This merging of information is not currently done.&lt;/li&gt;
      &lt;li&gt;Java 9 does not currently support optional modules or module cycles. It is not clear if they
      will support them at this time, unfortunately.&lt;/li&gt;
      &lt;li&gt;The &lt;code&gt;ceylon import-jar&lt;/code&gt; tool may complain about module visibility artifacts. We intend to fix this
      in time, but for now you can use &lt;code&gt;--force&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;The JDK module list we used in Ceylon has slightly changed in Java 9. This is what we get for
      being the first to support Jigsaw ;) For example, the &lt;code&gt;javax.xml&lt;/code&gt; module has been renamed to
      &lt;code&gt;java.xml&lt;/code&gt;. We have set up aliases so that it &quot;just&quot; works, but there are modules that have
      been merged, and packages that have changed module, so it will not always work.&lt;/li&gt;
      &lt;li&gt;The Java 9 runtime has been tested, but not as thoroughly as the existing JBoss Modules, classpath,
      OSGi or Java EE runtimes. We expect a few issues in the Ceylon metamodel.&lt;/li&gt;
      &lt;/ul&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/12/14/maintenance-update-for-1-2-0-IDE</id>
    <title>First maintenance update for the Ceylon IDE version 1.2.0</title>
    <updated>2015-12-14T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/12/14/maintenance-update-for-1-2-0-IDE" rel="alternate" type="text/html" />
    <author>
      <name>David Festal</name>
    </author>
    <summary>
      Introducing the first Ceylon IDE maintenance update
      
      Just after the release of Ceylon 1.2.0, we started managing a maintenance branch of the IDE-related
      code, that will always be fully compatible with the last release of the Ceylon (Command line distribution and SDK).
      
      This way we've already been able to very easily backport to this branch many bug fixes or enhancements
      implemented on the main development branch.
      
      As a result, the first maintenance update of the Ceylon IDE plugin for Eclipse, which fixes about 30 issues, has just been
      published onto the main Ceylon IDE update site.
      
      So if you currently use the version 1.2.0 of the Ceylon...
    </summary>
    <content type="html">
      &lt;h2&gt;Introducing the first Ceylon IDE maintenance update&lt;/h2&gt;
      
      &lt;p&gt;Just after the release of &lt;a href=&quot;https://ceylon-lang.org/blog/2015/10/29/ceylon-1-2-0/&quot;&gt;Ceylon 1.2.0&lt;/a&gt;, we started managing a &lt;strong&gt;maintenance branch&lt;/strong&gt; of the IDE-related
      code, that will always be &lt;strong&gt;fully compatible&lt;/strong&gt; with the last release of the Ceylon (Command line distribution and SDK).&lt;/p&gt;
      
      &lt;p&gt;This way we've already been able to very easily backport to this branch many bug fixes or enhancements
      implemented on the main development branch.&lt;/p&gt;
      
      &lt;p&gt;As a result, the first maintenance update of the &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/ide/&quot;&gt;Ceylon IDE plugin for Eclipse&lt;/a&gt;, which fixes about 30 issues, has just been
      published onto the main Ceylon IDE &lt;a href=&quot;https://ceylon-lang.org/eclipse/updatesite/&quot;&gt;update site&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;So if you currently use the version 1.2.0 of the Ceylon IDE Eclipse plugin, simply run the
      &lt;code&gt;Check For Updates&lt;/code&gt; command in the Eclipse &lt;code&gt;Help&lt;/code&gt; menu, and Eclipse should propose you to update the Ceylon IDE
      features.&lt;/p&gt;
      
      &lt;p&gt;And if you still don't use the Ceylon IDE Eclipse plugin, just &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/ide/install&quot;&gt;install&lt;/a&gt; it and give it a try now.&lt;/p&gt;
      
      &lt;h2&gt;Source tracking&lt;/h2&gt;
      
      &lt;p&gt;Of course each maintenance update will be tagged inside the GitHub source repositories.&lt;/p&gt;
      
      &lt;p&gt;So as soon as we know the version of the &lt;code&gt;Ceylon IDE&lt;/code&gt; feature, visible from the Eclipse &lt;code&gt;About&lt;/code&gt; dialog:&lt;/p&gt;
      
      &lt;div style=&quot;text-align:center;&quot;&gt;
      &lt;img src=&quot;https://ceylon-lang.org/images/screenshots/blog/2015-12-14-maintenance-update-for-1.2.0-IDE/about-ceylon-ide.png&quot; style=&quot;box-shadow: 0 0 10px #888;margin-left:5px;&quot; width=&quot;679px&quot; height=&quot;auto&quot;&gt;
      &lt;/div&gt;
      
      
      &lt;p&gt;we can immediately checkout the &lt;strong&gt;precise&lt;/strong&gt; source code corresponding to a Ceylon IDE installation.&lt;/p&gt;
      
      &lt;p&gt;This will help us &lt;strong&gt;reproducing more easily&lt;/strong&gt;, and &lt;strong&gt;fixing more quickly&lt;/strong&gt;, any issue encountered on the production Ceylon IDE.&lt;/p&gt;
      
      &lt;h2&gt;Maintenance update release notes&lt;/h2&gt;
      
      &lt;p&gt;Detailed release notes of this maintenance update can be found &lt;a href=&quot;https://github.com/ceylon/ceylon-ide-eclipse/releases/tag/com.redhat.ceylon.eclipse.feature_1.2.0.v20151214-1608-Final&quot;&gt;here&lt;/a&gt;,
      and related commits can be found &lt;a href=&quot;https://github.com/ceylon/ceylon-ide-eclipse/compare/1.2.0...com.redhat.ceylon.eclipse.feature_1.2.0.v20151214-1608-Final&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Issues&lt;/h2&gt;
      
      &lt;p&gt;Bugs and suggestions may be reported in GitHub's
      &lt;a href=&quot;https://github.com/ceylon/ceylon-ide-eclipse/issues&quot;&gt;issue tracker&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;About Ceylon&lt;/h2&gt;
      
      &lt;p&gt;Ceylon is a highly understandable object-oriented language
      with static typing. The language features:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;an emphasis upon &lt;strong&gt;readability&lt;/strong&gt; and a strong bias toward
      &lt;strong&gt;omission or elimination of potentially-harmful or
      potentially-ambiguous constructs&lt;/strong&gt; and toward highly
      &lt;strong&gt;disciplined use of static types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;an extremely powerful and uncommonly elegant type system
      combining subtype and parametric polymorphism with:
      
      &lt;ul&gt;
      &lt;li&gt;first-class &lt;strong&gt;union and intersection types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;both &lt;strong&gt;declaration-site and use-site variance&lt;/strong&gt;, and&lt;/li&gt;
      &lt;li&gt;the use of principal types for &lt;strong&gt;local type inference&lt;/strong&gt;
      and &lt;strong&gt;flow-sensitive typing&lt;/strong&gt;,&lt;/li&gt;
      &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;a unique treatment of &lt;strong&gt;function and tuple types&lt;/strong&gt;,
      enabling powerful abstractions, along with the most
      &lt;strong&gt;elegant approach to &lt;code&gt;null&lt;/code&gt;&lt;/strong&gt; of any modern language,&lt;/li&gt;
      &lt;li&gt;first-class constructs for defining &lt;strong&gt;modules and
      dependencies between modules&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;a very flexible syntax including &lt;strong&gt;comprehensions&lt;/strong&gt; and
      support for expressing &lt;strong&gt;tree-like structures&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;fully-reified generic types&lt;/strong&gt;, on both the JVM and
      JavaScript virtual machines, and a unique &lt;strong&gt;typesafe
      metamodel&lt;/strong&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;More information about these language features may be
      found in the &lt;a href=&quot;https://ceylon-lang.org/features&quot;&gt;feature list&lt;/a&gt; and
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/introduction/&quot;&gt;quick introduction&lt;/a&gt;.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/12/14/failure</id>
    <title>Modelling failure in Ceylon</title>
    <updated>2015-12-14T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/12/14/failure" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      In all programming languages, we need to deal with operations
      than can "fail":
      
      
      a pure function might fail to produce a result, or
      an impure function might fail to produce its desired
      side-effect (create a new file, or whatever).
      
      
      
      In neither case can we just blindly continue with the rest
      of the computation. In the first case, the result of the
      function might be the input to some other function. In the
      second case, subsequent operations might assume that the
      side-effect occurred (that the file now exists, or whatever).
      
      Thus, it's clear that there must be some way for an operation
      to signal failure to the calling code. There are two...
    </summary>
    <content type="html">
      &lt;p&gt;In all programming languages, we need to deal with operations
      than can &quot;fail&quot;:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;a pure function might fail to produce a result, or&lt;/li&gt;
      &lt;li&gt;an impure function might fail to produce its desired
      side-effect (create a new file, or whatever).&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;In neither case can we just blindly continue with the rest
      of the computation. In the first case, the result of the
      function might be the input to some other function. In the
      second case, subsequent operations might assume that the
      side-effect occurred (that the file now exists, or whatever).&lt;/p&gt;
      
      &lt;p&gt;Thus, it's clear that there must be some way for an operation
      to signal failure to the calling code. There are two broad
      mechanisms provided by programming languages for signalling
      failure:&lt;/p&gt;
      
      &lt;ol&gt;
      &lt;li&gt;Failure may be indicated via return values: an error code,
      &lt;code&gt;null&lt;/code&gt;, a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/tour/types/#union_types&quot;&gt;union type&lt;/a&gt;,
      or a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/tour/types/#enumerated_types&quot;&gt;sum (enumerated) type&lt;/a&gt;,
      for example, &lt;code&gt;Option&lt;/code&gt;/&lt;code&gt;Maybe&lt;/code&gt; or &lt;code&gt;Either&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Failures may be signalled and handled within some sort of
      exception or &quot;panic&quot; facility.&lt;/li&gt;
      &lt;/ol&gt;&lt;p&gt;Most modern programming languages support both of these
      mechanisms, though of course the details vary. In particular,
      languages offer varying degrees of typesafety.&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;In languages with proper support for sum types or union
      types, return values may be used to model failure in a very
      robust and typesafe way.&lt;/li&gt;
      &lt;li&gt;In languages with some sort of &lt;em&gt;effect typing&lt;/em&gt;, for example,
      Java-style checked exceptions, the exceptions are themselves
      typesafe.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;By &lt;em&gt;typesafe&lt;/em&gt; what I mean is that an operation that can fail
      declares the possibility of failure in its signature, and
      the immediately calling code is forced by the compiler to
      explicitly handle the failure.&lt;/p&gt;
      
      &lt;h2&gt;Types of failure&lt;/h2&gt;
      
      &lt;p&gt;So what facilities &lt;em&gt;should&lt;/em&gt; a language offer for modelling
      failure? Return codes or exceptions? Typesafe or not? To
      arrive at a partial answer to this question, let's start with
      the following classification of &quot;failures&quot;:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Some failures represent problems that the immediately
      calling code is very unlikely to be able to recover from.
      Examples include transaction rollbacks, network failures,
      low memory conditions, or stack overflows.&lt;/li&gt;
      &lt;li&gt;Some failures are typically the result of bugs in the
      program logic. Examples include assertion failures,
      division by zero, and use of null pointers. This is a
      class of failure that, as far as possible, we would like
      to detect at compile time, but no type system will ever be
      powerful enough to detect &lt;em&gt;all&lt;/em&gt; of these failures. After a
      few minutes of thought, you should be able to convince
      yourself this class of problems is actually a subclass of
      the first class: how can any computation possibly recover
      meaningfully from a bug in its own logic?&lt;/li&gt;
      &lt;li&gt;Finally, there are &quot;failures&quot; that often represent
      recoverable conditions. For example, one might recover
      from a nonexistent file by creating a file. Note that
      failures in this class need not &lt;em&gt;always&lt;/em&gt; be recoverable.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Given this classification, I arrive relatively quickly at
      the following conclusions.&lt;/p&gt;
      
      &lt;h3&gt;Handling recoverable failures&lt;/h3&gt;
      
      &lt;p&gt;For &quot;recoverable&quot; conditions, the failure should be typesafe.
      The compiler should be able to verify that the calling code
      has made an explicit decision on what to do about the failure:
      recovering from it, or transforming it into an unrecoverable
      failure. We want to prevent recoverable failures from going
      unnoticed by accident.&lt;/p&gt;
      
      &lt;p&gt;It's clear that unchecked exceptions—or other untypesafe
      solutions such as returning &lt;code&gt;null&lt;/code&gt; in a language like Java
      where &lt;code&gt;null&lt;/code&gt; is untypesafe—don't prevent this, and allow
      failure conditions to go unnoticed, leading to bugs.&lt;/p&gt;
      
      &lt;p&gt;The most convenient, elegant, and efficient way to represent
      a recoverable failure is a union-typed return value. For
      example, if I have a function for parsing JSON, and it can
      fail for illegal input, I could use a function with the
      following signature:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;JsonObject|ParseError parseJson() =&amp;gt; ... ;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or, if it seems that &lt;code&gt;ParseError&lt;/code&gt; carries no useful information,
      I could just use &lt;code&gt;Null&lt;/code&gt; instead:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;JsonObject? parseJson() =&amp;gt; ... ;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Alternatively, in some advanced cases, one could use a sum
      (enumerated) return type.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;interface ParseResult of ParseSuccessful | ParseError {}
      class ParseSuccessful(shared JsonObject result) satisfies ParseResult {}
      class ParseError(shared String message) satisfies ParseResult {}
      
      ParseResult parseJson() =&amp;gt; ... ;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This is not usually necessary in Ceylon, however.&lt;/p&gt;
      
      &lt;h3&gt;Handling unrecoverable failures&lt;/h3&gt;
      
      &lt;p&gt;Now, for &quot;unrecoverable&quot; conditions, the failure should be an
      untyped (unchecked) exception. For an unrecoverable failure,
      we shouldn't be polluting the calling code with concerns it
      can't possibly do anything useful with. We want the failure
      to propagate quickly and transparently to some centralized,
      generic, infrastructure-level error handling.&lt;/p&gt;
      
      &lt;p&gt;Note that, since unchecked exceptions don't appear in the
      signature of the operation, the caller doesn't receive any
      kind of &quot;fair warning&quot; that they can occur. They represent
      a sort of designed-in &quot;hole&quot; in the type system.&lt;/p&gt;
      
      &lt;h3&gt;When in doubt&lt;/h3&gt;
      
      &lt;p&gt;But wait, you're probably thinking, haven't I left a huge
      question begging here?&lt;/p&gt;
      
      &lt;blockquote&gt;&lt;p&gt;What about failure that doesn't fall cleanly into
      &quot;recoverable&quot; or &quot;unrecoverable&quot;?&lt;/p&gt;&lt;/blockquote&gt;
      
      &lt;p&gt;Isn't there a huge grey area there, filled with failures that
      are &lt;em&gt;sometimes&lt;/em&gt; recoverable by the immediately-calling code?&lt;/p&gt;
      
      &lt;p&gt;Indeed there is. And I would say that, as a rule of thumb,
      &lt;em&gt;treat these failures as recoverable&lt;/em&gt;.&lt;/p&gt;
      
      &lt;p&gt;Consider our &lt;code&gt;parseJson()&lt;/code&gt; function above. A syntax error in
      the given JSON text could easily be the result of a bug in
      our program, but, crucially, &lt;em&gt;it's not a bug in &lt;code&gt;parseJson()&lt;/code&gt;
      itself.&lt;/em&gt; The code that knows whether it's a program bug or
      something else is the calling code, not the &lt;code&gt;parseJson()&lt;/code&gt;
      function.&lt;/p&gt;
      
      &lt;p&gt;And it's always easy for the calling code to transform a
      recoverable failure into an unrecoverable failure. For
      example:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;assert (is JsonObject result = parseJson(json));
      //result must be a JsonObject here
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;value result = parseJson(json);
      if (is ParseError result) {
          throw AssertionError(result.message);
      }
      //result must be a JsonObject here
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;That is, when in doubt, we make the calling code explicitly
      document its assumptions.&lt;/p&gt;
      
      &lt;p&gt;Looking at this another way, we err on the side of typesafety,
      since having too many unchecked exceptions starts to undermine
      the whole value of the static type system.&lt;/p&gt;
      
      &lt;p&gt;Furthermore, it's quite likely that the calling code is better
      placed to produce an error with more meaningful information
      than the code it's calling (though I have not shown that in
      the snippets above).&lt;/p&gt;
      
      &lt;h2&gt;Three things to consider&lt;/h2&gt;
      
      &lt;p&gt;I promised a &quot;partial&quot; answer to my original question, because
      there are still a couple of questions that I'm not sure I have
      a completely bottled answer to, and there's debate over these
      issues in the Ceylon community.&lt;/p&gt;
      
      &lt;h3&gt;Is &lt;code&gt;AssertionError&lt;/code&gt; overused?&lt;/h3&gt;
      
      &lt;p&gt;First, what kind of failures are legitimate uses of
      &lt;code&gt;AssertionError&lt;/code&gt;? Should every &lt;code&gt;AssertionError&lt;/code&gt; represent a
      bug in the program? Is it ever reasonable for a library to
      throw an &lt;code&gt;AssertionError&lt;/code&gt; when it encounters a situation it
      considers misuse of its API? Is it acceptable for generic
      exception handling code to recover from an &lt;code&gt;AssertionError&lt;/code&gt;,
      or should &lt;code&gt;AssertionError&lt;/code&gt;s be considered fatal?&lt;/p&gt;
      
      &lt;p&gt;My answers would be yes, yes, and yes. But perhaps that
      implies that it was a mistake to follow Java in making
      &lt;code&gt;AssertionError&lt;/code&gt; an &lt;code&gt;Error&lt;/code&gt; instead of a plain &lt;code&gt;Exception&lt;/code&gt;.
      (This leads to a larger debate about the role of &lt;code&gt;Error&lt;/code&gt;.)&lt;/p&gt;
      
      &lt;h3&gt;Is &lt;code&gt;Null&lt;/code&gt; overused?&lt;/h3&gt;
      
      &lt;p&gt;Second, the class &lt;code&gt;Null&lt;/code&gt; is a seductively convenient way to
      represent failure of functions which return a value. But are
      we overusing it? Would it have been better to make the return
      type of &lt;code&gt;Map&amp;lt;Key,Item&amp;gt;.get()&lt;/code&gt; be &lt;code&gt;Item|NoItem&amp;lt;Key&amp;gt;&lt;/code&gt; instead
      of the much more generic type &lt;code&gt;Item?&lt;/code&gt;, that is, &lt;code&gt;Item|Null&lt;/code&gt;?&lt;/p&gt;
      
      &lt;p&gt;Perhaps. In a sense, returning &lt;code&gt;null&lt;/code&gt; is like throwing
      &lt;code&gt;Exception&lt;/code&gt;: a little too generic. But since a null return
      value must be handled by the immediately calling code, which
      is much better placed to know what this instance of &lt;code&gt;null&lt;/code&gt;
      represents, it's not as harmful as a generic &lt;code&gt;Exception&lt;/code&gt;
      which is handled far from its source.&lt;/p&gt;
      
      &lt;p&gt;Whether you agree with that or not, it still might be best
      to avoid operations where &lt;code&gt;null&lt;/code&gt; can result from multiple
      different failure conditions. I have broken this rule in the
      past, and I'm going to be more careful in future.&lt;/p&gt;
      
      &lt;h3&gt;Functions with no useful return value&lt;/h3&gt;
      
      &lt;p&gt;Third, for functions with no useful return value, that is,
      functions which are called only for their side-effect—where
      the calling code has the option of simply ignoring any return
      value representing failure—should we err on the side of
      throwing an exception?&lt;/p&gt;
      
      &lt;p&gt;Or, alternatively, should the language offer some way to
      force the caller to do &lt;em&gt;something&lt;/em&gt; with the return value of
      non-&lt;code&gt;void&lt;/code&gt; function?&lt;/p&gt;
      
      &lt;p&gt;Ceylon doesn't have (and won't have) checked exceptions, but
      one could argue that this is the one situation where they
      would be most useful.&lt;/p&gt;
      
      &lt;h2&gt;Conclusion&lt;/h2&gt;
      
      &lt;p&gt;So, ultimately, there are some unanswered questions, and grey
      areas, but it seems to me that at least we have a rather
      strong conceptual framework in which to investigate these
      problems. And it's clear that the combination of
      facilities—union types, together with unchecked
      exceptions—is a powerful foundation for robust failure
      handling.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/12/08/troll</id>
    <title>Troll alert</title>
    <updated>2015-12-08T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/12/08/troll" rel="alternate" type="text/html" />
    <author>
      <name>St&#233;phane &#201;pardaud</name>
    </author>
    <summary>
      This is a rather unusual blog entry, one I was not thinking we'd ever have to write, but after
      a long debate, we've decided to go public about certain events that have happened to the Ceylon
      community.
      
      We are being aggressively harassed by a Troll for a month now, which is taking the following
      forms:
      
      
      Logging on our Gitter channels, insulting and threatening users, then renaming his GitHub account
      so we cannot find/ban him.
      Using fake identities to ask us for help on Gitter for hours on end, only to reveal later
      he was the troll and resume insults/threats.
      Impersonating Gitter users to make them look bad.
      Spreading lies about...
    </summary>
    <content type="html">
      &lt;p&gt;This is a rather unusual blog entry, one I was not thinking we'd ever have to write, but after
      a long debate, we've decided to go public about certain events that have happened to the Ceylon
      community.&lt;/p&gt;
      
      &lt;p&gt;We are being aggressively harassed by a Troll for a month now, which is taking the following
      forms:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Logging on our Gitter channels, insulting and threatening users, then renaming his GitHub account
      so we cannot find/ban him.&lt;/li&gt;
      &lt;li&gt;Using fake identities to ask us for help on Gitter for hours on end, only to reveal later
      he was the troll and resume insults/threats.&lt;/li&gt;
      &lt;li&gt;Impersonating Gitter users to make them look bad.&lt;/li&gt;
      &lt;li&gt;Spreading lies about Ceylon on other JVM languages discussion channels.&lt;/li&gt;
      &lt;li&gt;Using sock puppet accounts on reddit to turn many threads into Ceylon bashing or ad-hominem
      attacks on Ceylon team members.&lt;/li&gt;
      &lt;li&gt;
      &lt;s&gt;Defacing the Ceylon Wikipedia page&lt;/s&gt; [Edit: it's not clear yet, it could be a honest mistake
      on both parts].&lt;/li&gt;
      &lt;li&gt;And other things I cannot reveal here.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Since I have no doubt at all our troll is reading this, you will understand I am not revealing
      all the information that we have on what he's done and who he is. In fact it's a pretty
      difficult exercise.&lt;/p&gt;
      
      &lt;p&gt;I also don't want to explicitly name his identities here because I don't believe in mob justice,
      I hope you will understand that.&lt;/p&gt;
      
      &lt;p&gt;Naturally we've tried many things to make sure he stops poisoning our community, and are still
      working on measures behind the scenes, but his impact cannot be ignored.&lt;/p&gt;
      
      &lt;p&gt;Although we've always tried to follow the usual Troll-avoidance strategy of ignoring him, we
      have many people in the Ceylon community who see these events and wonder what's going on. They
      don't understand why every new user is suspect (our troll uses about two new fake accounts per
      day), or why suddenly a seemingly sane person will start throwing insults at everyone. The
      more we talk to him, and the more we talk about him, the more persisting he becomes, so we don't
      want to make it worse.&lt;/p&gt;
      
      &lt;p&gt;But there has to be an explanation we can point to when people ask what the hell is happening, so
      this is it.&lt;/p&gt;
      
      &lt;p&gt;We have a toxic person in our community, we haven't been able to get rid of him no matter how many
      times we asked him, and we don't have the tools to prevent him from harassing us, and he knows it.
      What goes on in his mind is beyond our ability to understand, but the fact is he exists, and seems
      driven by some motive to spend hours every day annoying us.&lt;/p&gt;
      
      &lt;p&gt;We are, again, withholding information about him and about the various things we are doing behind
      the scenes to deal with him, but rest assured we are not sitting idle.&lt;/p&gt;
      
      &lt;p&gt;That's pretty much as I can say at this point. If you see someone throwing insults at people on
      our Gitter channel, this is not something we condone at all, and we keep banning his new accounts
      for that, so don't let our apparent lack of reaction (besides the banning) fool you into thinking
      that we're silently condoning his attitude. We're not.&lt;/p&gt;
      
      &lt;p&gt;Thanks for your understanding.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/12/01/weld-guice</id>
    <title>Dependency injection in Ceylon with Weld and Guice</title>
    <updated>2015-12-01T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/12/01/weld-guice" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      I'm personally ambivalent about the benefits of dependency
      injection. On the one hand, I recognize its usefulness in
      certain container environments such as Java EE. (For the
      record, I was the author of the CDI 1.0 specification, with
      my JCP Expert Group.) On the other hand, given the nature of
      what I've been working on for the last few years, I don't
      really have a use for it in my own programs.
      
      But there are plenty of folks out there who swear by
      dependency injection, and ask me what Ceylon offers in this
      area. The short answer is: nothing special; the Ceylon SDK is
      architected around the notion of modular...
    </summary>
    <content type="html">
      &lt;p&gt;I'm personally ambivalent about the benefits of dependency
      injection. On the one hand, I recognize its usefulness in
      certain container environments such as Java EE. (For the
      record, I was the author of the CDI 1.0 specification, with
      my JCP Expert Group.) On the other hand, given the nature of
      what I've been working on for the last few years, I don't
      really have a use for it in my own programs.&lt;/p&gt;
      
      &lt;p&gt;But there are plenty of folks out there who swear by
      dependency injection, and ask me what Ceylon offers in this
      area. The short answer is: nothing special; the Ceylon SDK is
      architected around the notion of modular libraries. It offers
      neither framework nor container. This makes the SDK as general
      purpose as possible, meaning it can be reused from any other
      container environment (say, Java EE, vert.x, OSGi, or whatever).&lt;/p&gt;
      
      &lt;p&gt;So if you want dependency injection in Ceylon today, you're
      going to have to use a container written in Java. Fortunately,
      Ceylon 1.2 features such excellent interoperation with Java
      that this results in barely any friction at all. Surely
      someone will write a dependency injection container in Ceylon
      &lt;em&gt;some day&lt;/em&gt;, but, as we're about to see, there's no urgency at
      all.&lt;/p&gt;
      
      &lt;p&gt;I'm going to explore:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;a href=&quot;http://weld.cdi-spec.org/&quot;&gt;Weld&lt;/a&gt;, which is the reference
      implementation of CDI, developed by my colleagues at Red Hat,
      and,&lt;/li&gt;
      &lt;li&gt;in the interests of giving equal time to a &quot;competitor&quot;,
      Google's &lt;a href=&quot;https://github.com/google/guice&quot;&gt;Guice&lt;/a&gt;, originally
      written by my friend Bob Lee, which was one of the major
      influences on the CDI specification.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;These are my favorite containers for Java, though of course
      Spring has legions of fans. Perhaps I'll find time to play with
      it some other day.&lt;/p&gt;
      
      &lt;p&gt;You can find the example code in the following Git repository:&lt;/p&gt;
      
      &lt;p&gt;&lt;a href=&quot;https://github.com/ceylon/ceylon-examples-di&quot;&gt;https://github.com/ceylon/ceylon-examples-di&lt;/a&gt;&lt;/p&gt;
      
      &lt;h2&gt;Weld&lt;/h2&gt;
      
      &lt;p&gt;I found it extremely straightforward to use Weld in Ceylon,
      except for one relatively minor problem, which I'll mention
      below.&lt;/p&gt;
      
      &lt;h3&gt;Module descriptor for Weld&lt;/h3&gt;
      
      &lt;p&gt;Weld provides a fat jar in Maven Central, which makes it
      especially easy to use in Ceylon. I used the following module
      descriptor to download Weld from Maven Central and import it
      into my project:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;native(&quot;jvm&quot;)
      module weldelicious &quot;1.0.0&quot; {
          import &quot;org.jboss.weld.se:weld-se&quot; &quot;2.3.1.Final&quot;;
          import ceylon.interop.java &quot;1.2.0&quot;;
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Where &lt;code&gt;org.jboss.weld.se&lt;/code&gt; is the Maven &lt;em&gt;group id&lt;/em&gt;, and &lt;code&gt;weld-se&lt;/code&gt;
      is the Maven &lt;em&gt;artifact id&lt;/em&gt;. (I have not the slightest clue what
      these things actually mean, I just know there are two of them.)&lt;/p&gt;
      
      &lt;p&gt;I also imported the Ceylon SDK module &lt;code&gt;ceylon.interop.java&lt;/code&gt;
      because I'm going to use its &lt;code&gt;javaClass()&lt;/code&gt; function.&lt;/p&gt;
      
      &lt;h3&gt;Bootstrapping Weld&lt;/h3&gt;
      
      &lt;p&gt;Though it's not part of the CDI specification, Weld offers a
      very simple API for creating a container. I copy/pasted the
      following code from stackoverflow:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import org.jboss.weld.environment.se { Weld }
      
      shared void run() {
      
          value container = Weld().initialize();
      
          //do stuff with beans
          ...
      
          container.shutdown();
      
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;I tried to run this function.&lt;/p&gt;
      
      &lt;h3&gt;Gotcha!&lt;/h3&gt;
      
      &lt;p&gt;Just like every other CDI developer &lt;em&gt;ever&lt;/em&gt;, I forgot the
      &lt;code&gt;beans.xml&lt;/code&gt; file. Fortunately, Weld gave me a rather clear
      error message. Not quite as poetic as
      &lt;a href=&quot;http://qriollo.github.io&quot;&gt;&quot;se te escapó la tortuga&quot;&lt;/a&gt;,
      perhaps, but good enough to remind me of this requirement of
      the spec. (Yeah, the spec I wrote.)&lt;/p&gt;
      
      &lt;p&gt;To resolve the problem, I added an empty file named
      &lt;code&gt;beans.xml&lt;/code&gt; to the directory &lt;code&gt;resource/weldelicious/ROOT/META-INF&lt;/code&gt;,
      which is the magical location to use if you want Ceylon to
      put a file into the &lt;code&gt;META-INF&lt;/code&gt; directory of a module archive.&lt;/p&gt;
      
      &lt;h3&gt;Defining Weld beans&lt;/h3&gt;
      
      &lt;p&gt;I defined the following interface, for a bean I hoped to
      inject:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;interface Receiver {
          shared formal void accept(String message);
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Next, I defined a bean which depends on an instance of this
      interface:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import javax.inject { inject }
      
      inject class Sender(Receiver receiver) {
          shared void send() =&amp;gt; receiver.accept(&quot;Hello!&quot;);
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;(The &lt;code&gt;inject&lt;/code&gt; annotation is the thing you write &lt;code&gt;@Inject&lt;/code&gt; in
      Java.)&lt;/p&gt;
      
      &lt;p&gt;Finally, we need a bean which implements &lt;code&gt;Receiver&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class PrintingReceiver() satisfies Receiver {
          accept = print;
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h3&gt;Obtaining and calling a bean&lt;/h3&gt;
      
      &lt;p&gt;Going back to the &lt;code&gt;run()&lt;/code&gt; function, I added some code to
      obtain a &lt;code&gt;Sender&lt;/code&gt; from the container, and call &lt;code&gt;send()&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import org.jboss.weld.environment.se { Weld }
      import ceylon.interop.java { type = javaClass }
      
      shared void run() {
      
          value container = Weld().initialize();
      
          value sender 
                  = container
                      .select(type&amp;lt;Sender&amp;gt;())
                      .get();
      
          sender.send();
      
          weld.shutdown();
      
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Note that I'm using the &lt;code&gt;javaClass()&lt;/code&gt; function to obtain an
      instance of &lt;code&gt;java.lang.Class&lt;/code&gt; for the Ceylon type &lt;code&gt;Sender&lt;/code&gt;.
      An alternative approach, which uses only a CDI API, and which
      also works for generic types, is to use
      &lt;code&gt;javax.enterprise.inject.TypeLiteral&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;value sender 
              = container
                  .select(object extends TypeLiteral&amp;lt;Sender&amp;gt;(){})
                  .get();
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Unfortunately, that's a little more verbose.&lt;/p&gt;
      
      &lt;h3&gt;Named constructor injection&lt;/h3&gt;
      
      &lt;p&gt;Using a little quick fix in the IDE, we can transform the
      &lt;code&gt;Sender&lt;/code&gt; class into a class with a default constructor:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class Sender {
          Receiver receiver;
          inject shared new (Receiver receiver) {
              this.receiver = receiver;
          }
          shared void send() =&amp;gt; receiver.accept(&quot;Hello!&quot;);
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;As far as Weld is concerned, this is the same as what we had
      before.&lt;/p&gt;
      
      &lt;p&gt;But we can even give our constructor a name:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class Sender {
          Receiver receiver;
          inject shared new inject(Receiver receiver) {
              this.receiver = receiver;
          }
          shared void send() =&amp;gt; receiver.accept(&quot;Hello!&quot;);
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Due to unanticipated serendipity, this actually Just Works.&lt;/p&gt;
      
      &lt;h3&gt;Method and field injection&lt;/h3&gt;
      
      &lt;p&gt;I don't think that method or field injection is a very natural
      thing to do in Ceylon, and so I don't recommend it. However, it
      does work, just as long as you mark any fields initialized by
      injection with the &lt;code&gt;late&lt;/code&gt; annotation:&lt;/p&gt;
      
      &lt;p&gt;This works, but doesn't feel very Ceylonic:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class Sender() {
          inject late Receiver receiver;
          shared void send() =&amp;gt; receiver.accept(&quot;Hello!&quot;);
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This works too:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class Sender() {
          late Receiver receiver;
          inject void init(Receiver receiver) {
              this.receiver = receiver;
          }
          shared void send() =&amp;gt; receiver.accept(&quot;Hello!&quot;);
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h3&gt;Using a CDI producer&lt;/h3&gt;
      
      &lt;p&gt;One nice thing about using Ceylon with Weld is that you can
      use the &lt;code&gt;produces&lt;/code&gt; annotation on a toplevel function.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import javax.enterprise.inject { produces }
      
      produces Receiver createReceiver() 
              =&amp;gt; object satisfies Receiver {
                  accept = print;
              };
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h3&gt;CDI qualifiers&lt;/h3&gt;
      
      &lt;p&gt;We can define CDI qualifier annotations in Ceylon:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import javax.inject { qualifier }
      
      annotation Fancy fancy() =&amp;gt; Fancy();
      final qualifier annotation class Fancy() 
              satisfies OptionalAnnotation&amp;lt;Fancy&amp;gt; {}
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;A qualifier annotation must be applied at both the injection
      point and to the bean or producer function. First, I annotated
      the bean class:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;fancy class FancyReceiver() satisfies Receiver {
          accept(String message) 
                  =&amp;gt; print(message + &quot; \{BALLOON}\{PARTY POPPER}&quot;);
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Next, I tried annotating an injected initializer parameter:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;//this doesn't work!
      inject class Sender(fancy Receiver receiver) {
          shared void send() =&amp;gt; receiver.accept(&quot;Hello!&quot;);
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Unfortunately, this didn't work. When compiled to Java
      bytecode, Ceylon actually places this &lt;code&gt;fancy&lt;/code&gt; annotation on
      a generated getter method of &lt;code&gt;Sender&lt;/code&gt;, not on the parameter,
      and Weld only looks for qualifier annotations on injected
      parameters. I had to use constructor injection to make the
      qualifier work right:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;//this does work
      class Sender {
          Receiver receiver;
          inject shared new (fancy Receiver receiver) {
              this.receiver = receiver;
          }
          shared void send() =&amp;gt; receiver.accept(&quot;Hello!&quot;);
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;For the record, qualifier annotations also work with method
      injection. They don't work with field injection.&lt;/p&gt;
      
      &lt;p&gt;This was the only disappointment I had using Weld with Ceylon,
      and I believe I already know
      &lt;a href=&quot;https://github.com/ceylon/ceylon/issues/5779&quot;&gt;how to solve this&lt;/a&gt;
      in Ceylon 1.2.1.&lt;/p&gt;
      
      &lt;h3&gt;Scoped beans&lt;/h3&gt;
      
      &lt;p&gt;You can define scoped beans (beans with what the CDI spec
      calls a &lt;em&gt;normal scope&lt;/em&gt;) in Ceylon, just by applying a scope
      annotation to the bean:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import javax.enterprise.context { applicationScoped }
      
      applicationScoped
      class PrintingReceiver() satisfies Receiver {
          accept = print;
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;However, there's something to be careful of here: CDI creates
      proxies for scoped beans, and since the operations of a Ceylon
      class are &quot;final&quot; by default, you have a choice between:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;annotating all operations of the bean &lt;code&gt;default&lt;/code&gt;, or&lt;/li&gt;
      &lt;li&gt;injecting an interface instead of the concrete bean class.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;I think the second option is a much better path to go down,
      and is probably even the best approach in Java.&lt;/p&gt;
      
      &lt;p&gt;Surely the same caveat applies to beans with CDI interceptors
      or decorators, though I did not test that.&lt;/p&gt;
      
      &lt;p&gt;Weld offers &lt;em&gt;lots&lt;/em&gt; of additional functionality which I did not
      have time to test, but that I anticipate will work in Ceylon.&lt;/p&gt;
      
      &lt;h2&gt;Guice&lt;/h2&gt;
      
      &lt;p&gt;Guice was also pretty easy to get set up, though I wasted a bit
      of time on the Maven side of things.&lt;/p&gt;
      
      &lt;h3&gt;Module overrides for Guice&lt;/h3&gt;
      
      &lt;p&gt;Guice doesn't come in a fat jar, so we'll have to deal with a
      common problem when using Maven modules from Ceylon. Maven is
      designed for a flat Java classpath, so a Maven module doesn't
      come with metadata about which of its dependencies are
      re-exported via its public API. There are three basic strategies
      for solving this problem:&lt;/p&gt;
      
      &lt;ol&gt;
      &lt;li&gt;Compile and run with a flat classpath by using
      &lt;code&gt;--flat-classpath&lt;/code&gt;. This makes Ceylon work like Java, and
      robs us of module isolation.&lt;/li&gt;
      &lt;li&gt;Use &lt;code&gt;--export-maven-dependencies&lt;/code&gt; to re-export &lt;em&gt;all&lt;/em&gt;
      dependencies of every Maven module.&lt;/li&gt;
      &lt;li&gt;Use an &lt;code&gt;overrides.xml&lt;/code&gt; file to explicitly specify which
      dependencies are re-exported.&lt;/li&gt;
      &lt;/ol&gt;&lt;p&gt;We're going to go with option 3, since it's the hardest.&lt;/p&gt;
      
      &lt;p&gt;But wait—you must be thinking—&lt;em&gt;XML?!&lt;/em&gt; And yeah,
      don't worry, we hate XML just as much as you do. This is a
      stopgap measure until Ceylon has real &lt;em&gt;assemblies&lt;/em&gt;. Once we
      have assemblies, you'll be able to override module dependencies
      in a Ceylon assembly descriptor.&lt;/p&gt;
      
      &lt;p&gt;Anyway, after that longwinded preamble, all I had to do was
      mark &lt;code&gt;javax.inject&lt;/code&gt; as a shared dependency:&lt;/p&gt;
      
      &lt;!-- lang: xml--&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;overrides xmlns=&quot;http://www.ceylon-lang.org/xsd/overrides&quot;&amp;gt;
          &amp;lt;module groupId=&quot;com.google.inject&quot; 
               artifactId=&quot;guice&quot; 
                  version=&quot;4.0&quot;&amp;gt;
              &amp;lt;share groupId=&quot;javax.inject&quot; 
                  artifactId=&quot;javax.inject&quot;/&amp;gt;
          &amp;lt;/module&amp;gt;
      &amp;lt;/overrides&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;You're very welcome to copy and paste the above bit of
      boilerplate into your own Ceylon and Guice projects.&lt;/p&gt;
      
      &lt;h3&gt;Module descriptor for Guice&lt;/h3&gt;
      
      &lt;p&gt;The following module descriptor fetches Guice and its dependencies
      from Maven Central, and imports Guice into the project:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;native(&quot;jvm&quot;)
      module guicy &quot;1.0.0&quot; {
          import &quot;com.google.inject:guice&quot; &quot;4.0&quot;;
          import ceylon.interop.java &quot;1.2.0&quot;;
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h3&gt;Code we can reuse from the Weld example&lt;/h3&gt;
      
      &lt;p&gt;Since Guice recognizes the &lt;code&gt;inject&lt;/code&gt; annotation defined in
      &lt;code&gt;javax.inject&lt;/code&gt;, we can reuse the definitions of &lt;code&gt;Sender&lt;/code&gt;,
      &lt;code&gt;Receiver&lt;/code&gt;, and &lt;code&gt;PrintingReceiver&lt;/code&gt; we started out with above.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import javax.inject { inject }
      
      inject class Sender(Receiver receiver) {
          shared void send() =&amp;gt; receiver.accept(&quot;Hello!&quot;);
      }
      
      interface Receiver {
          shared formal void accept(String message);
      }
      
      class PrintingReceiver() satisfies Receiver {
          accept = print;
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h3&gt;Bootstrapping Guice&lt;/h3&gt;
      
      &lt;p&gt;Guice has the notion of a &lt;em&gt;module&lt;/em&gt; object, which has a collection
      of &lt;em&gt;bindings&lt;/em&gt; of types to objects. Unlike Weld, which automatically
      scans our module archive looking for beans, bindings must be
      registered explicitly in Guice.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import ceylon.interop.java {
          type = javaClass
      }
      import com.google.inject {
          AbstractModule,
          Guice {
              createInjector
          },
          Injector
      }
      
      Injector injector
              = createInjector(
          object extends AbstractModule() {
              shared actual void configure() {
                  bind(type&amp;lt;Receiver&amp;gt;()).to(type&amp;lt;PrintingReceiver&amp;gt;());
              }
          });
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This code binds the implementation &lt;code&gt;PrintingReceiver&lt;/code&gt; to the
      interface &lt;code&gt;Receiver&lt;/code&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Obtaining and calling an object&lt;/h3&gt;
      
      &lt;p&gt;Now it's easy to obtain and call a container-bound instance
      of &lt;code&gt;Sender&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import ceylon.interop.java {
          type = javaClass
      }
      
      shared void run() {
          value sender = injector.getInstance(type&amp;lt;Sender&amp;gt;());
          sender.send();
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;We're again using &lt;code&gt;javaClass()&lt;/code&gt;, but Guice has its own &lt;code&gt;TypeLiteral&lt;/code&gt;.
      (For the record, CDI stole &lt;code&gt;TypeLiteral&lt;/code&gt; from Guice.)&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import com.google.inject {
          Key,
          TypeLiteral
      }
      
      shared void run() {
          value key = Key.get(object extends TypeLiteral&amp;lt;Sender&amp;gt;(){});
          value sender = injector.getInstance(key);
          sender.send();
      } 
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h3&gt;Constructor injection&lt;/h3&gt;
      
      &lt;p&gt;Injection into default constructors works, and looks exactly
      like what it looks like for Weld. However, injection into named
      constructors doesn't work with Ceylon 1.2.0 and Guice 4.0. This
      is &lt;a href=&quot;https://github.com/ceylon/ceylon/issues/5777&quot;&gt;pretty easy to fix&lt;/a&gt;
      on our side, and so it should work in Ceylon 1.2.1.&lt;/p&gt;
      
      &lt;h3&gt;Method and field injection&lt;/h3&gt;
      
      &lt;p&gt;The creators of Guice strongly prefer constructor injection,
      which is, as we have observed, also more natural in Ceylon.
      But method and field injection works fine, as with Weld, if
      you mark injected field &lt;code&gt;late&lt;/code&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Provider methods&lt;/h3&gt;
      
      &lt;p&gt;Guice scans the module object for methods annotated &lt;code&gt;provides&lt;/code&gt;.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import com.google.inject {
          AbstractModule,
          Guice {
              createInjector
          },
          Injector,
          provides
      }
      
      Injector injector
              = createInjector(
          object extends AbstractModule() {
              shared actual void configure() {}
              provides Receiver createReceiver()
                      =&amp;gt; object satisfies Receiver {
                          accept = print;
                      };
          });
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;I find this significantly inferior to the approach in CDI
      where producer methods can be defined as toplevel functions.&lt;/p&gt;
      
      &lt;h3&gt;Binding annotations&lt;/h3&gt;
      
      &lt;p&gt;Guice's &lt;em&gt;binding annotations&lt;/em&gt; work almost exactly like CDI
      qualifier annotations (since that's where CDI copied them from).
      The code to define a binding annotation is exactly the same
      as for Weld.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import javax.inject { qualifier }
      
      annotation Fancy fancy() =&amp;gt; Fancy();
      final binding annotation class Fancy() 
              satisfies OptionalAnnotation&amp;lt;Fancy&amp;gt; {}
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;The qualifier annotation must be specified when defining a
      binding:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Injector injector
              = createInjector(
          object extends AbstractModule() {
              shared actual void configure() {
                  bind(type&amp;lt;Receiver&amp;gt;())
                      .to(type&amp;lt;PrintingReceiver&amp;gt;());
                  bind(type&amp;lt;Receiver&amp;gt;())
                      .annotatedWith(Fancy()) //binding annotation
                      .to(type&amp;lt;FancyReceiver&amp;gt;());
              }
          });
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Just like in Weld, qualifier annotations work with constructor
      or method injection, but don't currently work with initializer
      parameter or field injection.&lt;/p&gt;
      
      &lt;h3&gt;Scoped beans&lt;/h3&gt;
      
      &lt;p&gt;Like CDI, Guice has scoped objects.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import com.google.inject { singleton }
      
      singleton
      class PrintingReceiver() satisfies Receiver {
          accept = print;
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;I didn't have time to test this feature of Guice extensively,
      but I happen to know that Guice doesn't use proxies, so it's
      not necessary to use an interface instead of a concrete class.&lt;/p&gt;
      
      &lt;h2&gt;Conclusion&lt;/h2&gt;
      
      &lt;p&gt;If you want dependency injection in Ceylon, it's clear that
      you have at least two excellent options.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/11/20/obr</id>
    <title>One Big Repository</title>
    <updated>2015-11-20T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/11/20/obr" rel="alternate" type="text/html" />
    <author>
      <name>Tako Schotanus</name>
    </author>
    <summary>
      Over the last year and a half it has happened quite frequently that users on our mailing lists or Gitter channels asked: "What is this OBR you people keep talking about?". It was something that would most often be mentioned when we were frustrated with the current project setup making things more difficult than necessary.
      
      How it all started
      
      To understand what the OBR really is you first need to know how our project was organized all these years. Ceylon started out with nothing but the parser and the code that checks and models our unique typesystem, we call it the "typechecker"....
    </summary>
    <content type="html">
      &lt;p&gt;Over the last year and a half it has happened quite frequently that users on our &lt;a href=&quot;http://groups.google.com/group/ceylon-users&quot;&gt;mailing lists&lt;/a&gt; or &lt;a href=&quot;https://gitter.im/ceylon/user&quot;&gt;Gitter channels&lt;/a&gt; asked: &quot;What is this OBR you people keep talking about?&quot;. It was something that would most often be mentioned when we were frustrated with the current project setup making things more difficult than necessary.&lt;/p&gt;
      
      &lt;h2&gt;How it all started&lt;/h2&gt;
      
      &lt;p&gt;To understand what the OBR really is you first need to know how our project was organized all these years. Ceylon started out with nothing but the parser and the code that checks and models our unique typesystem, we call it the &quot;typechecker&quot;. When we started working on the compilers new modules got added, first for the Java Virtual Machine, later for JavaScript. Then we added a module that handles downloading and caching of external modules retrieved from the &lt;a href=&quot;https://modules.ceylon-lang.org/&quot;&gt;Herd&lt;/a&gt;. This went on to the point that we wound up with 9 separate but very interdependent projects.&lt;/p&gt;
      
      &lt;h2&gt;The problem&lt;/h2&gt;
      
      &lt;p&gt;Now of course modularization is a good software engineering practise so there was no problem there. The problem was with the way we had created multiple &lt;a href=&quot;https://github.com/ceylon&quot;&gt;Git repositories&lt;/a&gt; for each of the projects. We started noticing that for certain types of cross-module issues we often had to make changes to multiple repositories at a time. And when you do that, let's say you change 6 repositories for a single bug report or for a single new feature, you lose cohesion. The changes are all separate and you lose sight of the fact that they belong together. So if you need to go back in time looking for a specific problem and when it was introduced and by which code commit it suddenly becomes very hard to synchronize all the repositories in such a way that you get a working system. The famous &lt;code&gt;git bisect&lt;/code&gt; becomes impossible to use.&lt;/p&gt;
      
      &lt;p&gt;It also caused minor problems when managing issues on GitHub because users, not knowing, would often open issues on the wrong project which meant manually copying the issue from one project to another (and sometimes even &lt;em&gt;we&lt;/em&gt; didn't know where to put an issue and it would get moved several times).&lt;/p&gt;
      
      &lt;h2&gt;Looking for a solution&lt;/h2&gt;
      
      &lt;p&gt;So at a certain moment it became obvious that our project setup was working against us, that its structure made certain operations way too hard. A single repository on the other hand wouldn't have those problems. A single big repository, the only one for the entire distribution. So we started calling it the &quot;One Big Repository&quot;, quickly shortened to &quot;OBR&quot;.&lt;/p&gt;
      
      &lt;p&gt;But there were doubts that a single repository would become too big and unwieldy. And &lt;em&gt;how&lt;/em&gt; would we go from 9 repositories to just 1? Are there tools to do that? And what about our GitHub issues?&lt;/p&gt;
      
      &lt;p&gt;Instead we first looked at tools like &lt;code&gt;git submodule&lt;/code&gt; and &lt;code&gt;git subtree&lt;/code&gt; which would allow us to keep our current projects but still treat them as a one. But after researching it for a while we came to the conclusion that although it might work it &lt;em&gt;does&lt;/em&gt; make things more complex for the developer. And given the fact that most of us aren't Git experts and sometimes have trouble enough with it as it is we decided that the added complexity would not work in our favor. Besides the problem with the GitHub issues being separate would still remain.&lt;/p&gt;
      
      &lt;h2&gt;The execution&lt;/h2&gt;
      
      &lt;p&gt;One Big Repository it would be then, merging all 9 Ceylon distribution repositories into a single one. But how? No ready-made tools seemed to exist, just fragments of &lt;a href=&quot;http://stackoverflow.com/questions/1425892/how-do-you-merge-two-git-repositories&quot;&gt;scripts&lt;/a&gt; and &lt;a href=&quot;http://stackoverflow.com/questions/13040958/merge-two-git-repositories-without-breaking-file-history&quot;&gt;examples&lt;/a&gt; of &lt;a href=&quot;http://stackoverflow.com/questions/1683531/how-to-import-existing-git-repository-into-another&quot;&gt;complex&lt;/a&gt; &lt;a href=&quot;http://www.harecoded.com/merging-two-three-or-more-git-repositories-keeping-the-log-history-2366393&quot;&gt;Git commands&lt;/a&gt;. And for the GitHub issues we could only rely on their &lt;a href=&quot;https://developer.github.com/v3/&quot;&gt;remote API&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;I will spare you all the nitty gritty details on the many dozens of practise merges we did to get to a point where we were happy enough with the result but finally, last monday on November 16th, we made public the new OBR, the &lt;a href=&quot;https://github.com/ceylon/ceylon&quot;&gt;One Big Repository&lt;/a&gt;!&lt;/p&gt;
      
      &lt;h2&gt;How to use it&lt;/h2&gt;
      
      &lt;p&gt;Setting up a Ceylon environment for development used to be a big hassle. So much in fact that we created some pretty complex build scripts to do that all for you. So fortunately as a contributor you'd never notice, you'd just type &lt;code&gt;ant setup&lt;/code&gt; and everything would be done for you.&lt;/p&gt;
      
      &lt;p&gt;But now things have become still easier, for you as a potential contributor the only that is needed is:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ git clone https://github.com/ceylon/ceylon
      $ cd ceylon
      $ ant clean dist
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;For a more thorough explanation on how to set up a development environment and how to go from there to submitting your first contribution please visit &lt;a href=&quot;https://ceylon-lang.org/code/contribute/&quot;&gt;Contributing to the compiler backend&lt;/a&gt;&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/11/12/openshift</id>
    <title>Running Ceylon on OpenShift</title>
    <updated>2015-11-12T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/11/12/openshift" rel="alternate" type="text/html" />
    <author>
      <name>St&#233;phane &#201;pardaud</name>
    </author>
    <summary>
      This year we released three different ways you can run your Ceylon code on OpenShift:
      
      
      Bare-bones, using the Ceylon cartridge,
      Writing a verticle in Ceylon, using the Vert.x cartridge, or
      Packaging your Ceylon application as a .war file and running it on the WildFly cartridge.
      
      
      
      In this post we will see how you can write and publish a bare-bones application on
      OpenShift Online using the OpenShift Ceylon cartridge.
      The Vert.x and WildFly methods will be described in a later blog post.
      
      The OpenShift Ceylon cartridge is for OpenShift V2. Yes I know that's old, as it is now V3, but
      the online version of OpenShift is still V2,...
    </summary>
    <content type="html">
      &lt;p&gt;This year we released three different ways you can run your Ceylon code on &lt;a href=&quot;https://www.openshift.com/features/technologies.html&quot;&gt;OpenShift&lt;/a&gt;:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Bare-bones, using the &lt;a href=&quot;https://developers.openshift.com/en/ceylon-overview.html#_using_the_ceylon_cartridge&quot;&gt;Ceylon cartridge&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;Writing a verticle in Ceylon, using the &lt;a href=&quot;https://developers.openshift.com/en/ceylon-overview.html#_using_the_a_href_vertx_overview_html_vert_x_a_cartridge&quot;&gt;Vert.x cartridge&lt;/a&gt;, or&lt;/li&gt;
      &lt;li&gt;Packaging your Ceylon application as a &lt;code&gt;.war&lt;/code&gt; file and running it on the WildFly cartridge.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;In this post we will see how you can write and publish a bare-bones application on
      &lt;a href=&quot;https://openshift.redhat.com/app/login&quot;&gt;OpenShift Online&lt;/a&gt; using the &lt;a href=&quot;https://hub.openshift.com/quickstarts/138-ceylon&quot;&gt;OpenShift Ceylon cartridge&lt;/a&gt;.
      The Vert.x and WildFly methods will be described in a later blog post.&lt;/p&gt;
      
      &lt;p&gt;The OpenShift Ceylon cartridge is for OpenShift V2. Yes I know that's old, as it is now V3, but
      the online version of OpenShift is still V2, so it's still relevant. We are working on the
      V3 cartridge too, and it should be out soon.&lt;/p&gt;
      
      &lt;h2&gt;Writing a bare-bones web application with Ceylon&lt;/h2&gt;
      
      &lt;p&gt;Let's start by creating a new Ceylon project:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ ceylon new hello-world ceylon-blog-openshift
      Enter module name [com.example.helloworld]: openshift.bare  
      Enter module version [1.0.0]: 1
      Would you like to generate Eclipse project files? (y/n) [y]: n
      Would you like to generate an ant build.xml? (y/n) [y]: n
      $ cd ceylon-blog-openshift
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now compile and run it to check that everything is under control:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ ceylon compile
      Note: Created module openshift.bare/1
      $ ceylon run openshift.bare/1
      Hello, World!
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now let's make it start an HTTP server, by using the &lt;a href=&quot;https://modules.ceylon-lang.org/modules/ceylon.net/1.2.0&quot;&gt;&lt;code&gt;ceylon.net&lt;/code&gt;&lt;/a&gt; module
      and adapting its &lt;a href=&quot;https://modules.ceylon-lang.org/repo/1/ceylon/net/1.2.0/module-doc/api/index.html&quot;&gt;documentation code sample&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;First import that module in &lt;code&gt;source/openshift/bare/module.ceylon&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;native(&quot;jvm&quot;)
      module openshift.bare &quot;1&quot; {
        import ceylon.net &quot;1.2.0&quot;;
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Then use it in &lt;code&gt;source/openshift/bare/run.ceylon&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import ceylon.io { SocketAddress }
      import ceylon.net.http.server { ... }
      
      shared void start(String host, Integer port){
          //create a HTTP server
          value server = newServer {
              //an endpoint, on the path /hello
              Endpoint {
                  path = startsWith(&quot;/&quot;);
                  //handle requests to this path
                  service(Request request, Response response)
                          =&amp;gt; response.writeString(&quot;hello world&quot;);
              }
          };
          //start the server
          server.start(SocketAddress(host, port));
      }
      
      shared void run(){
          start(&quot;127.0.0.1&quot;, 8080);
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Let's run it:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ ceylon compile
      Note: Created module openshift.bare/1
      $ ceylon run openshift.bare/1
      Starting on 127.0.0.1:8080
      Debug: XNIO version 3.3.0.Final 
      Debug: XNIO NIO Implementation Version 3.3.0.Final 
      Httpd started.
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And try it locally at &lt;a href=&quot;http://localhost:8080&quot;&gt;&lt;code&gt;http://localhost:8080&lt;/code&gt;&lt;/a&gt;, it should show a web page with &lt;code&gt;hello world&lt;/code&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Adapt our application for running on OpenShift&lt;/h2&gt;
      
      &lt;p&gt;Now let's adapt it to run on OpenShift, where the host name and port are specified by OpenShift,
      by using the &lt;a href=&quot;https://modules.ceylon-lang.org/modules/ceylon.openshift/1.2.0&quot;&gt;&lt;code&gt;ceylon.openshift&lt;/code&gt;&lt;/a&gt;
      module to see if we are running on OpenShift and if yes, bind to the right address.&lt;/p&gt;
      
      &lt;p&gt;First import the OpenShift module in &lt;code&gt;source/openshift/bare/module.ceylon&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;native(&quot;jvm&quot;)
      module openshift.bare &quot;1&quot; {
        import ceylon.net &quot;1.2.0&quot;;
        import ceylon.openshift &quot;1.2.0&quot;;
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And use it in in &lt;code&gt;source/openshift/bare/run.ceylon&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;import ceylon.openshift { openshift }
      import ceylon.io { SocketAddress }
      import ceylon.net.http.server { ... }
      
      shared void start(String host, Integer port){
          //create a HTTP server
          value server = newServer {
              //an endpoint, on the path /hello
              Endpoint {
                  path = startsWith(&quot;/&quot;);
                  //handle requests to this path
                  service(Request request, Response response)
                          =&amp;gt; response.writeString(&quot;hello world&quot;);
              }
          };
          //start the server
          server.start(SocketAddress(host, port));
      }
      
      shared void run(){
          if(openshift.running){
              start(openshift.ceylon.ip, openshift.ceylon.port);
          }else{
              start(&quot;127.0.0.1&quot;, 8080);
          }
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;So now it can run either locally as before, or in OpenShift.&lt;/p&gt;
      
      &lt;h2&gt;Configuring our application for the OpenShift Ceylon cartridge&lt;/h2&gt;
      
      &lt;p&gt;Let's create the required OpenShift structure to tell the OpenShift Ceylon
      cartridge how to run our module. We do this by installing the OpenShift
      Ceylon command-line plugin:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ ceylon plugin install ceylon.openshift/1.2.0
      Scripts for ceylon.openshift installed in /home/stephane/.ceylon/bin/ceylon.openshift
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And now we run it:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ ceylon openshift init openshift.bare/1
      Installing file .openshift/config/ceylon.properties: Generated
      ...
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;For those who want more information, or tune how the application is deployed by the OpenShift
      Ceylon cartridge, &lt;a href=&quot;https://github.com/ceylon/openshift-cartridge/blob/master/template/README.md&quot;&gt;the documentation has a lot more information&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;Our application is now ready to be run on OpenShift.&lt;/p&gt;
      
      &lt;h2&gt;Deploying our application to OpenShift Online&lt;/h2&gt;
      
      &lt;p&gt;Now, assuming you already have an &lt;a href=&quot;https://openshift.redhat.com/app/login&quot;&gt;OpenShift Online account&lt;/a&gt;,
      and the &lt;a href=&quot;https://developers.openshift.com/en/getting-started-overview.html&quot;&gt;&lt;code&gt;rhc&lt;/code&gt; command installed&lt;/a&gt;,
      you can proceed to create an OpenShift application with the Ceylon cartridge:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ rhc create-app --no-git -a test https://raw.github.com/ceylon/openshift-cartridge/master/metadata/manifest.yml
      The cartridge 'https://raw.github.com/ceylon/openshift-cartridge/master/metadata/manifest.yml' will be downloaded and installed
      
      Application Options
      -------------------
      Domain:     fromage
      Cartridges: https://raw.github.com/ceylon/openshift-cartridge/master/metadata/manifest.yml
      Gear Size:  default
      Scaling:    no
      
      Creating application 'test' ... done
      
      
      Waiting for your DNS name to be available ... done
      
      Your application 'test' is now available.
      
        URL:        http://test-fromage.rhcloud.com/
        SSH to:     ...@test-fromage.rhcloud.com
        Git remote: ssh://...@test-fromage.rhcloud.com/~/git/test.git/
      
      Run 'rhc show-app test' for more details about your app.
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This created our application on OpenShift Online, and gave us a URL at which we can access it (&lt;code&gt;http://test-fromage.rhcloud.com/&lt;/code&gt;),
      as well as a Git repository where we can push our application (&lt;code&gt;ssh://...@test-fromage.rhcloud.com/~/git/test.git/&lt;/code&gt;).&lt;/p&gt;
      
      &lt;p&gt;Now we just have to turn our application into a Git repository and add the &lt;code&gt;openshift&lt;/code&gt; remote Url
      that &lt;code&gt;rhc&lt;/code&gt; gave us just above:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ git init
      Initialised empty Git repository in /home/stephane/src/java-eclipse/ceylon-blog-openshift/.git/
      $ git remote add openshift ssh://...@test-fromage.rhcloud.com/~/git/test.git/
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;The Ceylon OpenShift cartridge includes a demo sample app that we can get rid of by forcing
      a push of our current application to OpenShift:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ git add source .openshift
      $ git commit -m &quot;Initial commit&quot;
      ...
      $ git push -f openshift master
      Counting objects: 23, done.
      Delta compression using up to 16 threads.
      Compressing objects: 100% (18/18), done.
      Writing objects: 100% (23/23), 3.79 KiB | 0 bytes/s, done.
      Total 23 (delta 1), reused 0 (delta 0)
      remote: Stopping Ceylon cart
      remote: Application is already stopped
      remote: Repairing links for 1 deployments
      remote: Building git ref 'master', commit 58ab35c
      remote: 
      remote: Building Ceylon app...
      remote: Compiling every module in /var/lib/openshift/../app-root/runtime/repo//source for the JVM:
      remote: Note: Created module openshift.bare/1
      remote: Ceylon build done.
      remote: Preparing build for deployment
      remote: Deployment id is ...
      remote: Activating deployment
      remote: TODO
      remote: Starting Ceylon cart
      remote: Executing /var/lib/openshift/.../ceylon/usr/ceylon-1.2.0/bin/ceylon
      remote: With params: run   --rep=/var/lib/openshift/.../app-root/runtime/repo/.openshift/config/modules --cacherep=/var/lib/openshift/.../app-root/runtime/repo//cache --rep=https://modules.ceylon-lang.org/repo/1/ --rep=/var/lib/openshift/.../app-root/runtime/repo//modules openshift.bare/1 
      remote: With JAVA_OPTS:  -Dcom.redhat.ceylon.common.tool.terminal.width=9999 -Dceylon.cache.repo=/var/lib/openshift/.../app-root/runtime/repo//cache
      remote: Ceylon started with pid: 350715
      remote: Waiting for http server to boot on 127.5.184.1:8080 ... (1/30)
      remote: Waiting for http server to boot on 127.5.184.1:8080 ... (2/30)
      remote: Waiting for http server to boot on 127.5.184.1:8080 ... (3/30)
      remote: Waiting for http server to boot on 127.5.184.1:8080 ... (4/30)
      remote: Found 127.5.184.1:8080 listening port
      remote: 
      remote: -------------------------
      remote: Git Post-Receive Result: success
      remote: Activation status: success
      remote: Deployment completed with status: success
      To ssh://...@test-fromage.rhcloud.com/~/git/test.git/
         2a29bdf..58ab35c  master -&amp;gt; master
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;That's it, you can now go and check your application online at &lt;code&gt;http://test-fromage.rhcloud.com/&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Congratulations!&lt;/p&gt;
      
      &lt;p&gt;Now you can also publish your code online, at GitHub or elsewhere, and every time you
      push your modifications to the &lt;code&gt;openshift&lt;/code&gt; remote, your application will be restarted
      with your changes.&lt;/p&gt;
      
      &lt;p&gt;Stay tuned for the Vert.x and WildFly Ceylon OpenShift deployment guides on this blog.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/11/07/intellij</id>
    <title>Porting Ceylon IDE to IntelliJ</title>
    <updated>2015-11-07T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/11/07/intellij" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      We've had many questions about developing Ceylon in IntelliJ IDEA,
      so I thought it would be worth a quick status update.
      
      TL;DR: The screenshots are below.
      
      As you might know, Ceylon already has the most feature rich IDE
      of any modern language for the JVM, with some features that even
      the Java IDE for Eclipse doesn't have. But IntelliJ users don't
      like having to switch to Eclipse when they code Ceylon, so a few
      months ago we got serious about porting Ceylon IDE to IntelliJ.
      Bastien Jansen is working on this fulltime, together with David
      Festal from SERLI.
      
      The approach they're taking is to refactor reusable functionality
      of Ceylon IDE out...
    </summary>
    <content type="html">
      &lt;p&gt;We've had many questions about developing Ceylon in IntelliJ IDEA,
      so I thought it would be worth a quick status update.&lt;/p&gt;
      
      &lt;p&gt;&lt;strong&gt;TL;DR:&lt;/strong&gt; The &lt;a href=&quot;#screenshots&quot;&gt;screenshots&lt;/a&gt; are below.&lt;/p&gt;
      
      &lt;p&gt;As you might know, Ceylon already has the most &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/ide/features/&quot;&gt;feature rich IDE&lt;/a&gt;
      of any modern language for the JVM, with some features that even
      the Java IDE for Eclipse doesn't have. But IntelliJ users don't
      like having to switch to Eclipse when they code Ceylon, so a few
      months ago we got serious about porting Ceylon IDE to IntelliJ.
      Bastien Jansen is working on this fulltime, together with David
      Festal from &lt;a href=&quot;http://www.serli.com/&quot;&gt;SERLI&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;The approach they're taking is to refactor reusable functionality
      of Ceylon IDE out into a separate project &lt;a href=&quot;https://github.com/ceylon/ceylon-ide-common&quot;&gt;ceylon-ide-common&lt;/a&gt;.
      Simultaneously they're rewriting the common code in Ceylon (which
      David reports is really helping simplify and improve the code).
      Then this &quot;abstracted&quot; code is reused in the &lt;a href=&quot;https://github.com/ceylon/ceylon-ide-intellij&quot;&gt;ceylon-ide-intellij&lt;/a&gt;
      project—which is also being written in Ceylon—and in
      &lt;a href=&quot;https://github.com/ceylon/ceylon-ide-eclipse&quot;&gt;ceylon-ide-eclipse&lt;/a&gt;. Thus, &lt;code&gt;ceylon-ide-common&lt;/code&gt; gives us a common
      foundation for both IDEs, and enables us to get some really
      sophisticated functionality into the IntelliJ IDE very quickly.&lt;/p&gt;
      
      &lt;p&gt;Even better, once &lt;code&gt;ceylon-ide-common&lt;/code&gt; is stabilized, we can reuse
      it elsewhere, for example, in the &lt;a href=&quot;https://github.com/ceylon/ceylon-web-ide-backend&quot;&gt;Web IDE&lt;/a&gt;, or in the new
      (experimental) plugin for NetBeans. Bastien was able to add
      autocompletion to the experimental Netbeans plugin in about 2-3
      hours.&lt;/p&gt;
      
      &lt;p&gt;This also all demonstrates just how well Ceylon's Java interop
      works in practice. Here we have Java calling Ceylon and Ceylon
      calling back to Java all over the place!&lt;/p&gt;
      
      &lt;p&gt;The IntelliJ plugin isn't really usable just yet, since David is
      still working on abstraction of the Ceylon IDE incremental builder,
      but we expect to have a first release in a handful of months.&lt;/p&gt;
      
      &lt;h3&gt;Screenshots&lt;/h3&gt;
      
      &lt;p&gt;Ceylon IDE for IntelliJ already features completion:&lt;/p&gt;
      
      &lt;div style=&quot;text-align:center;&quot;&gt;
      &lt;img alt=&quot;completion&quot; src=&quot;https://ceylon-lang.org/images/screenshots/intellij/completion.png&quot; width=&quot;80%&quot;&gt;
      &lt;/div&gt;
      
      
      &lt;p&gt;Including linked mode argument completion:&lt;/p&gt;
      
      &lt;div style=&quot;text-align:center;&quot;&gt;
      &lt;img alt=&quot;linked mode&quot; src=&quot;https://ceylon-lang.org/images/screenshots/intellij/linked-mode.png&quot; width=&quot;50%&quot;&gt;
      &lt;/div&gt;
      
      
      &lt;p&gt;Outline view and hover:&lt;/p&gt;
      
      &lt;div style=&quot;text-align:center;&quot;&gt;
      &lt;img alt=&quot;outline&quot; src=&quot;https://ceylon-lang.org/images/screenshots/intellij/outline.jpg&quot; width=&quot;40%&quot;&gt;
         
      &lt;img alt=&quot;hover&quot; src=&quot;https://ceylon-lang.org/images/screenshots/intellij/doc.jpg&quot; width=&quot;45%&quot;&gt;
      &lt;/div&gt;
      
      
      &lt;p&gt;Live error reporting:&lt;/p&gt;
      
      &lt;div style=&quot;text-align:center;&quot;&gt;
      &lt;img alt=&quot;errors&quot; src=&quot;https://ceylon-lang.org/images/screenshots/intellij/errors.jpg&quot; width=&quot;80%&quot;&gt;
      &lt;/div&gt;
      
      
      &lt;p&gt;And execution:&lt;/p&gt;
      
      &lt;div style=&quot;text-align:center;&quot;&gt;
      &lt;img alt=&quot;run&quot; src=&quot;https://ceylon-lang.org/images/screenshots/intellij/run.png&quot; width=&quot;40%&quot;&gt;
      &lt;/div&gt;
      
      
      &lt;p&gt;Much more functionality is coming soon!&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/10/29/ceylon-1-2-0</id>
    <title>Ceylon 1.2.0 is now available</title>
    <updated>2015-10-29T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/10/29/ceylon-1-2-0" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      After a full year in development, and with more than
      1500 issues closed, Ceylon 1.2.0 brings new
      language features, including:
      
      
      named constructors,
      serialization,
      native declarations,
      improved flow-sensitive typing,
      destructuring for tuples and entries
      let, switch, if, and object expressions, and
      more powerful annotation constraints.
      
      
      
      Furthermore, the typechecker and JavaScript backend now
      support type functions as an experimental feature.
      
      Also part of this release are enhancements to the tooling,
      such as:
      
      
      a new debugger for Ceylon, and
      the Java EE packaging command, ceylon war.
      
      
      
      As always, this release incorporates hundreds of other
      bugfixes and enhancements.
      
      About Ceylon
      
      Ceylon is a modern, modular, statically typed programming
      language for the Java and JavaScript virtual machines. The
      language features a flexible and very readable syntax,...
    </summary>
    <content type="html">
      &lt;p&gt;After a full year in development, and with more than
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.1/roadmap/&quot;&gt;1500 issues&lt;/a&gt; closed, &lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;Ceylon 1.2.0&lt;/a&gt; brings new
      language features, including:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;named &lt;a href=&quot;https://ceylon-lang.org/blog/2015/06/21/constructors/&quot;&gt;constructors&lt;/a&gt;,&lt;/li&gt;
      &lt;li&gt;serialization,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;native&lt;/code&gt; declarations,&lt;/li&gt;
      &lt;li&gt;improved flow-sensitive typing,&lt;/li&gt;
      &lt;li&gt;destructuring for tuples and entries&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and &lt;code&gt;object&lt;/code&gt; expressions, and&lt;/li&gt;
      &lt;li&gt;more powerful annotation constraints.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Furthermore, the typechecker and JavaScript backend now
      support &lt;a href=&quot;https://ceylon-lang.org/blog/2015/06/03/generic-function-refs/&quot;&gt;type functions&lt;/a&gt; as an experimental feature.&lt;/p&gt;
      
      &lt;p&gt;Also part of this release are enhancements to the tooling,
      such as:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;a new debugger for Ceylon, and&lt;/li&gt;
      &lt;li&gt;the Java EE packaging command, &lt;code&gt;ceylon war&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;As always, this release incorporates hundreds of other
      bugfixes and enhancements.&lt;/p&gt;
      
      &lt;h2&gt;About Ceylon&lt;/h2&gt;
      
      &lt;p&gt;Ceylon is a modern, modular, statically typed programming
      language for the Java and JavaScript virtual machines. The
      language features a flexible and very readable syntax, a
      unique and uncommonly elegant static type system, a powerful
      module architecture, and excellent tooling, including an
      awesome Eclipse-based IDE.&lt;/p&gt;
      
      &lt;p&gt;Ceylon enables the development of cross-platform modules
      that execute portably in both virtual machine environments.
      Alternatively, a Ceylon module may target one or the other
      platform, in which case it may interoperate with native code
      written for that platform.&lt;/p&gt;
      
      &lt;h2&gt;In the box&lt;/h2&gt;
      
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;This release&lt;/a&gt; includes:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;a complete &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/spec&quot;&gt;language specification&lt;/a&gt; that defines the
      syntax and semantics of Ceylon in language accessible to
      the professional developer,&lt;/li&gt;
      &lt;li&gt;a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/reference/tool/ceylon/subcommands/index.html&quot;&gt;command line toolset&lt;/a&gt; including compilers for
      Java and JavaScript, a documentation compiler, a test
      runner, a WAR archive packager, and support for executing
      modular programs on the JVM and Node.js,&lt;/li&gt;
      &lt;li&gt;a powerful module architecture for code organization,
      dependency management, and module isolation at runtime,&lt;/li&gt;
      &lt;li&gt;the &lt;a href=&quot;https://herd.ceylon-lang.org/modules/ceylon.language&quot;&gt;language module&lt;/a&gt;, our minimal,
      cross-platform foundation of the &lt;a href=&quot;https://modules.ceylon-lang.org/categories/SDK&quot;&gt;Ceylon SDK&lt;/a&gt;, and&lt;/li&gt;
      &lt;li&gt;a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/ide/features/&quot;&gt;full-featured&lt;/a&gt; Eclipse-based integrated
      development environment.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Language&lt;/h2&gt;
      
      &lt;p&gt;Ceylon is a highly understandable object-oriented language
      with static typing. The language features:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;an emphasis upon &lt;strong&gt;readability&lt;/strong&gt; and a strong bias toward
      &lt;strong&gt;omission or elimination of potentially-harmful or
      potentially-ambiguous constructs&lt;/strong&gt; and toward highly
      &lt;strong&gt;disciplined use of static types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;an extremely powerful and uncommonly elegant type system
      combining subtype and parametric polymorphism with:
      
      &lt;ul&gt;
      &lt;li&gt;first-class &lt;strong&gt;union and intersection types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;both &lt;strong&gt;declaration-site and use-site variance&lt;/strong&gt;, and&lt;/li&gt;
      &lt;li&gt;the use of principal types for &lt;strong&gt;local type inference&lt;/strong&gt;
      and &lt;strong&gt;flow-sensitive typing&lt;/strong&gt;,&lt;/li&gt;
      &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;a unique treatment of &lt;strong&gt;function and tuple types&lt;/strong&gt;,
      enabling powerful abstractions, along with the most
      &lt;strong&gt;elegant approach to &lt;code&gt;null&lt;/code&gt;&lt;/strong&gt; of any modern language,&lt;/li&gt;
      &lt;li&gt;first-class constructs for defining &lt;strong&gt;modules and
      dependencies between modules&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;a very flexible syntax including &lt;strong&gt;comprehensions&lt;/strong&gt; and
      support for expressing &lt;strong&gt;tree-like structures&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;fully-reified generic types&lt;/strong&gt;, on both the JVM and
      JavaScript virtual machines, and a unique &lt;strong&gt;typesafe
      metamodel&lt;/strong&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;More information about these language features may be
      found in the &lt;a href=&quot;https://ceylon-lang.org/features&quot;&gt;feature list&lt;/a&gt; and
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2/introduction/&quot;&gt;quick introduction&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;This release introduces the following new language features
      and improvements:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;named &lt;strong&gt;constructors&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;support for &lt;strong&gt;serialization&lt;/strong&gt; libraries in the metamodel,&lt;/li&gt;
      &lt;li&gt;the &lt;code&gt;native&lt;/code&gt; annotation, which allows the use of
      platform-dependent code in cross-platform modules&lt;/li&gt;
      &lt;li&gt;improvements to &lt;strong&gt;flow-sensitive typing&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;destructuring&lt;/strong&gt; for tuples and entries,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, and &lt;code&gt;if&lt;/code&gt; expressions,&lt;/li&gt;
      &lt;li&gt;inline &lt;code&gt;object&lt;/code&gt; expressions,&lt;/li&gt;
      &lt;li&gt;more powerful &lt;strong&gt;annotation constraints&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;type argument inference for &lt;strong&gt;function references&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;an improved algorithm for type argument inference in
      &lt;strong&gt;invocation expressions&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;improvements to analysis of &lt;strong&gt;disjointness for sequence
      types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;new &lt;strong&gt;type abbreviations&lt;/strong&gt;, &lt;code&gt;T[N]&lt;/code&gt; and &lt;code&gt;T(*A)&lt;/code&gt;,&lt;/li&gt;
      &lt;li&gt;an abbreviated syntax for identifying the containing
      &lt;code&gt;`package`&lt;/code&gt;, &lt;code&gt;`module`&lt;/code&gt;, &lt;code&gt;`class`&lt;/code&gt;, or
      &lt;code&gt;`interface`&lt;/code&gt;,&lt;/li&gt;
      &lt;li&gt;inline variable defininition in &lt;code&gt;switch&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;the ability to directly &lt;code&gt;import&lt;/code&gt; members of a singleton
      &lt;code&gt;object&lt;/code&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;relaxation of type constraint checking&lt;/strong&gt; where
      unnecessary to ensure soundness, and&lt;/li&gt;
      &lt;li&gt;experimental support for &lt;strong&gt;type functions&lt;/strong&gt; (higher-order
      generics) and references to generic functions (higher-rank
      polymorphism).&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Language module&lt;/h2&gt;
      
      &lt;p&gt;For Ceylon 1.2, the following new APIs were introduced to
      the language module:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;the &lt;code&gt;map()&lt;/code&gt; and &lt;code&gt;set()&lt;/code&gt; functions allow creation of
      immutable &lt;code&gt;Map&lt;/code&gt;s and &lt;code&gt;Set&lt;/code&gt;s with no dependency to
      &lt;code&gt;ceylon.collection&lt;/code&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;distinct&lt;/code&gt;, &lt;code&gt;frequences()&lt;/code&gt;, &lt;code&gt;group()&lt;/code&gt;, &lt;code&gt;tabulate()&lt;/code&gt;, and
      &lt;code&gt;summarize()&lt;/code&gt; were added to &lt;code&gt;Iterable&lt;/code&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;getOrDefault()&lt;/code&gt;, &lt;code&gt;defaultNullItems()&lt;/code&gt;, and &lt;code&gt;coalescedMap&lt;/code&gt;
      were added to &lt;code&gt;Map&lt;/code&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;Collection.permutations()&lt;/code&gt; was added,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;formatFloat()&lt;/code&gt; was added,&lt;/li&gt;
      &lt;li&gt;the &lt;code&gt;Contextual&lt;/code&gt; interface was added, a cross-platform
      abstraction of thread-local values,&lt;/li&gt;
      &lt;li&gt;some operations of &lt;code&gt;List&lt;/code&gt; were split out onto the new
      &lt;code&gt;SearchableList&lt;/code&gt; interface, and&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;arrayOfSize()&lt;/code&gt; was deperecated and replaced with the
      constructor &lt;code&gt;Array.ofSize()&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Furthermore, some native implementation code has been
      rewritten in Ceylon using &lt;code&gt;native&lt;/code&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Compiler and command line tools&lt;/h2&gt;
      
      &lt;p&gt;Enhancements to the Java compiler include:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;much improved interoperation with Maven, including support
      for overriding module metadata with &lt;code&gt;overrides.xml&lt;/code&gt;, and
      &lt;code&gt;--flat-classpath&lt;/code&gt; and &lt;code&gt;--auto-export-maven-dependencies&lt;/code&gt;,&lt;/li&gt;
      &lt;li&gt;all compiled classes are now &lt;code&gt;Serializable&lt;/code&gt; and have
      default constructors, allowing much smoother
      interoperation with certain Java frameworks,&lt;/li&gt;
      &lt;li&gt;improved interoperation with Java annotations, and&lt;/li&gt;
      &lt;li&gt;basic support for interoperation with libraries written in
      Scala.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;The JavaScript compiler now supports &lt;a href=&quot;https://ceylon-lang.org/blog/2015/06/03/generic-function-refs/&quot;&gt;type functions&lt;/a&gt;,
      allowing the use of higher-order and higher-rank polymorphism
      in Ceylon. These experimental features are not yet supported
      by the Java compiler.&lt;/p&gt;
      
      &lt;p&gt;There are several new features and improvements to the
      command line toolset:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;the &lt;code&gt;ceylon war&lt;/code&gt; command repackages a module as a Java EE
      WAR archive,&lt;/li&gt;
      &lt;li&gt;the &lt;code&gt;ceylon browse&lt;/code&gt; command opens module documentation in
      the browser,&lt;/li&gt;
      &lt;li&gt;multiple commands can be given simultaneously, for example
      &lt;code&gt;ceylon compile,doc,run com.redhat.hello&lt;/code&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon help command&lt;/code&gt; and &lt;code&gt;ceylon --help&lt;/code&gt; now page output
      by default, and&lt;/li&gt;
      &lt;li&gt;the &lt;code&gt;ceylon&lt;/code&gt; command architecture now supports writing
      plugins in Ceylon.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;IDE&lt;/h2&gt;
      
      &lt;p&gt;Ceylon IDE now features the following improvements, along
      with many bugfixes and a number of performance enhancements:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;a brand new &lt;strong&gt;debugger&lt;/strong&gt; for Ceylon,&lt;/li&gt;
      &lt;li&gt;extensive support for new language features including
      constructors and &lt;code&gt;native&lt;/code&gt;,&lt;/li&gt;
      &lt;li&gt;improvements to the powerful &lt;strong&gt;Change Parameter List&lt;/strong&gt;
      refactoring,&lt;/li&gt;
      &lt;li&gt;the Inline refactoring can now &lt;strong&gt;inline a type alias&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;filtering&lt;/strong&gt; of packages from searches and completions,&lt;/li&gt;
      &lt;li&gt;many new &lt;strong&gt;quick fixes and assists&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;Paste Java as Ceylon&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;the popup Outline can now show inherited members,&lt;/li&gt;
      &lt;li&gt;the redesigned Open Declaration dialog now shows
      documentation,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;keyboard shortcuts&lt;/strong&gt; were added for certain quick assists,&lt;/li&gt;
      &lt;li&gt;support for Eclipse's new &lt;strong&gt;dark theme&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;refactored preferences pages, with much &lt;strong&gt;greater
      customizability&lt;/strong&gt;, including&lt;/li&gt;
      &lt;li&gt;two new &lt;strong&gt;alternative syntax highlighting themes&lt;/strong&gt;, along
      with an alternative icon set.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;A number of important subsystems have been abstracted and
      rewritten in Ceylon, to support the ongoing development of
      the new IntelliJ-based IDE for Ceylon.&lt;/p&gt;
      
      &lt;h2&gt;SDK&lt;/h2&gt;
      
      &lt;p&gt;The &lt;a href=&quot;https://modules.ceylon-lang.org/categories/SDK&quot;&gt;platform modules&lt;/a&gt;, recompiled for 1.2.0, are
      available in the shared community repository, &lt;a href=&quot;https://herd.ceylon-lang.org&quot;&gt;Ceylon Herd&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;This release introduces two new platform modules:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.transaction&lt;/code&gt; provides support for distributed
      transaction processing, and&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.regex&lt;/code&gt; provides regular expressions.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Along with several API enhancements and bugfixes, including:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.time&lt;/code&gt; now has functions for parsing ISO 8601
      formatted dates, times, and datetimes,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.locale&lt;/code&gt; now supports formatting zoned times, and
      parsing dates and times,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.interop.java&lt;/code&gt; now has &lt;code&gt;javaClassFromDeclaration()&lt;/code&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.net&lt;/code&gt; now has &lt;code&gt;redirect()&lt;/code&gt;, and its &lt;code&gt;Uri&lt;/code&gt; is now
      immutable, and&lt;/li&gt;
      &lt;li&gt;the collection types in &lt;code&gt;ceylon.collection&lt;/code&gt; now offer
      additional named constructors.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;OpenShift cartridge&lt;/h2&gt;
      
      &lt;p&gt;The &lt;a href=&quot;https://developers.openshift.com/en/ceylon-overview.html&quot;&gt;Ceylon cartridge&lt;/a&gt; for &lt;a href=&quot;https://www.openshift.com/&quot;&gt;OpenShift&lt;/a&gt; has been improved
      and updated to support Ceylon 1.2.&lt;/p&gt;
      
      &lt;h2&gt;Web IDE&lt;/h2&gt;
      
      &lt;p&gt;You can try Ceylon using the redesigned &lt;a href=&quot;http://try.ceylon-lang.org&quot;&gt;Web IDE&lt;/a&gt;, now
      rewritten in Ceylon, and featuring syntax highlighting,
      interactive error reporting, autocompletion, online
      documentation, and persistence and code sharing via Gist.&lt;/p&gt;
      
      &lt;p&gt;The Web IDE serves a dual purpose as a standard example
      demonstrating the use of Ceylon for web application
      development and deployment to the &lt;a href=&quot;https://www.openshift.com/&quot;&gt;OpenShift&lt;/a&gt; cloud
      platform.&lt;/p&gt;
      
      &lt;h2&gt;Community&lt;/h2&gt;
      
      &lt;p&gt;The Ceylon community site, &lt;a href=&quot;http://ceylon-lang.org&quot;&gt;http://ceylon-lang.org&lt;/a&gt;, includes
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.2&quot;&gt;documentation&lt;/a&gt;, and information about
      &lt;a href=&quot;https://ceylon-lang.org/community/&quot;&gt;getting involved&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Source code&lt;/h2&gt;
      
      &lt;p&gt;The source code for Ceylon, its specification, and its website,
      is freely available from &lt;a href=&quot;https://github.com/ceylon&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;Information about Ceylon's open source licenses is available
      &lt;a href=&quot;https://ceylon-lang.org/code/licenses/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Issues&lt;/h2&gt;
      
      &lt;p&gt;Bugs and suggestions may be reported in GitHub's
      &lt;a href=&quot;https://ceylon-lang.org/code/issues&quot;&gt;issue tracker&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Migrating from Ceylon 1.1&lt;/h2&gt;
      
      &lt;p&gt;Migration from Ceylon 1.1 is easy. To recompile a module for
      1.2:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;First ensure that its dependencies have also been
      recompiled.&lt;/li&gt;
      &lt;li&gt;If it imports a Ceylon SDK platform module, upgrade the
      version number specified by the module &lt;code&gt;import&lt;/code&gt; statement
      from &lt;code&gt;&quot;1.1.0&quot;&lt;/code&gt; to &lt;code&gt;&quot;1.2.0&quot;&lt;/code&gt; .&lt;/li&gt;
      &lt;li&gt;If it imports any platform-native module, annotate its
      &lt;code&gt;module&lt;/code&gt; declaration &lt;code&gt;native(&quot;jvm&quot;)&lt;/code&gt; or &lt;code&gt;native(&quot;js&quot;)&lt;/code&gt;,
      depending upon the target platform. This step does not
      apply to cross-platform modules.&lt;/li&gt;
      &lt;li&gt;If, when recompiling, you encounter errors on &lt;code&gt;assert&lt;/code&gt;
      statements, try removing the assertion (the improvements
      to flow typing now make some type assertions redundant).&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Acknowledgement&lt;/h2&gt;
      
      &lt;p&gt;As always, we're deeply grateful to the community volunteers
      who contributed a substantial part of the current Ceylon
      codebase, working in their own spare time. The following
      people have contributed to Ceylon:&lt;/p&gt;
      
      &lt;p&gt;Gavin King, Stéphane Épardaud, Tako Schotanus, Tom Bentley,
      David Festal, Enrique Zamudio, Bastien Jansen,
      Emmanuel Bernard, Aleš Justin, Tomáš Hradec, James Cobb,
      Ross Tate, Max Rydahl Andersen, Mladen Turk,
      Lucas Werkmeister, Roland Tepp, Diego Coronel, Matej Lazar,
      John Vasileff, Toby Crawley, Julien Viet, Loic Rouchon,
      Stephane Gallès, Ivo Kasiuk, Corbin Uselton, Paco Soberón,
      Michael Musgrove, Daniel Rochetti, Henning Burdack,
      Luke deGruchy, Rohit Mohan, Griffin DeJohn, Casey Dahlin,
      Alexander Altman, Alexander Zolotko, Alex Szczuczko,
      Andrés G. Aragoneses, Anh Nhan Nguyen, Brice Dutheil,
      Carlos Augusto Mar, Charles Gould, Chris Gregory, klinger,
      Martin Voelkle, Mr. Arkansas, Paŭlo Ebermann, Vorlent,
      Akber Choudhry, Renato Athaydes, Flavio Oliveri,
      Michael Brackx, Brent Douglas, Lukas Eder, Markus Rydh,
      Julien Ponge, Pete Muir, Nicolas Leroux, Brett Cannon,
      Geoffrey De Smet, Guillaume Lours, Gunnar Morling,
      Jeff Parsons, Jesse Sightler, Oleg Kulikov, Raimund Klein,
      Sergej Koščejev, Chris Marshall, Simon Thum, Maia Kozheva,
      Shelby, Aslak Knutsen, Fabien Meurisse, Sjur Bakka,
      Xavier Coulon, Ari Kast, Dan Allen, Deniz Türkoglu,
      F. Meurisse, Jean-Charles Roger, Johannes Lehmann, allentc,
      Nikolay Tsankov, Chris Horne, Gabriel Mirea, Georg Ragaller,
      Harald Wellmann, klinger, Oliver Gondža, Stephen Crawley.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/10/27/why</id>
    <title>Why you might want to choose Ceylon</title>
    <updated>2015-10-27T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/10/27/why" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      In a couple of days Ceylon 1.2 will be released. Ceylon 1.2 is
      out now, after a year of development. That’s exciting for us,
      but we think it would be interesting to summarize our thoughts about why you should be excited
      about Ceylon, and why you might consider it over other programming languages designed to run on the
      Java and JavaScript virtual machines.
      
      Ceylon is a rather ambitious programming language, so sometimes when people ask us to summarize
      its advantages, it can be a bit difficult to know where to start!
      
      A truly cross-platform language
      
      Ceylon is a language that is equally at home on the JVM and...
    </summary>
    <content type="html">
      &lt;p&gt;&lt;del&gt;In a couple of days Ceylon 1.2 will be released.&lt;/del&gt; Ceylon 1.2 is
      &lt;a href=&quot;https://ceylon-lang.org/blog/2015/10/29/ceylon-1-2-0/&quot;&gt;out now&lt;/a&gt;, after a year of development. That’s exciting for us,
      but we think it would be interesting to summarize our thoughts about why &lt;em&gt;you&lt;/em&gt; should be excited
      about Ceylon, and why you might consider it over other programming languages designed to run on the
      Java and JavaScript virtual machines.&lt;/p&gt;
      
      &lt;p&gt;Ceylon is a rather &lt;em&gt;ambitious&lt;/em&gt; programming language, so sometimes when people ask us to summarize
      its advantages, it can be a bit difficult to know where to start!&lt;/p&gt;
      
      &lt;h2&gt;A truly cross-platform language&lt;/h2&gt;
      
      &lt;p&gt;Ceylon is a language that is equally at home on the JVM and on any JavaScript VM. Furthermore,
      implementation of a compiler backend for the Dart VM is already quite advanced, and work has begun
      on a native backend based on LLVM. The architecture of the compiler and tooling make addition of a
      new runtime environment, if not easy, at least &lt;em&gt;straightforward&lt;/em&gt;.&lt;/p&gt;
      
      &lt;p&gt;Also important: Ceylon is rigorously defined by a complete &lt;em&gt;language specification&lt;/em&gt;. The very act
      of writing a specification forces the language designer to really think through the semantics and
      corner cases, and acts as an essential reference as to what the behavior of the compiler
      &lt;em&gt;should be&lt;/em&gt;.&lt;/p&gt;
      
      &lt;p&gt;Unlike other languages designed first for the JVM and then, belatedly, ported to JavaScript, Ceylon
      doesn’t feature JVM-specific numeric types with semantics that aren’t relevant to—or can’t be
      honored on—other VMs. And its language module isn’t polluted with dependencies to types like
      &lt;code&gt;java.lang.Exception&lt;/code&gt; that don’t exist in other runtime environments. Instead, Ceylon’s language
      module completely abstracts the underlying runtime, and offers a set of elegant APIs that vastly
      improve on those available natively.&lt;/p&gt;
      
      &lt;p&gt;But this abstraction doesn’t come at the cost of lowest-common-denominator performance
      characteristics. On the contrary, you can expect Java-like performance when Ceylon executes on the
      JVM, Dart-like performance when Ceylon executes on the Dart VM, and JavaScript-like performance when
      Ceylon executes on a JavaScript VM like Node.js.&lt;/p&gt;
      
      &lt;p&gt;Nor does this abstraction limit the potential for interoperation with native code. Ceylon features
      excellent interoperation with Java and Maven, and it’s very easy to use most Java libraries in
      Ceylon. Similarly, Ceylon’s battery of &lt;code&gt;dynamic&lt;/code&gt; constructs make interoperation with native
      JavaScript straightforward. With the new &lt;code&gt;native&lt;/code&gt; functions and classes in Ceylon 1.2, it’s even
      possible to write a cross-platform module that interoperates with native Java &lt;em&gt;and&lt;/em&gt; JavaScript code!&lt;/p&gt;
      
      &lt;p&gt;Finally, Ceylon's module system is already compatible with OSGi, with Maven, with Vert.x, with &lt;code&gt;npm&lt;/code&gt;,
      and with &lt;code&gt;requirejs&lt;/code&gt;. When Jigsaw finally arrives, we'll support it too.&lt;/p&gt;
      
      &lt;p&gt;This all amounts to an impressive engineering achievement, especially when taking into account the
      sophistication of the language itself.&lt;/p&gt;
      
      &lt;h2&gt;Truly disciplined static typing&lt;/h2&gt;
      
      &lt;p&gt;Chances are you have some experience writing code in a language with static typing. In combination
      with the right tooling, static typing makes code more robust, more understandable, and much more
      maintainable. But most languages go out of their way to include features and APIs which  undermine
      their own static type system. A handful of languages such as ML and Haskell eschew this, offering
      a principled, disciplined approach to static typing. And programmers working with these languages
      report a curious thing: that their programs have a strange tendency to work first or second time
      they run them. Sure, it takes a little longer to produce a program that the compiler accepts, but
      once the compiler is satisfied, so many common bugs have already been eliminated, that the program
      is often already correct or at least &lt;em&gt;almost&lt;/em&gt; correct.&lt;/p&gt;
      
      &lt;p&gt;Ceylon follows this same philosophy and, even though it’s a very different sort of language to ML,
      our experience is that our programs have the very same tendency to just work, almost immediately.
      You surely won’t believe this until you experience it yourself.&lt;/p&gt;
      
      &lt;p&gt;Ceylon’s type system itself is state-of-the-art, including generic types with both use-site and
      declaration-site covariance and contravariance, mixin (multiple) inheritance, principal instantiation
      inheritance, sum types, disjointness analysis, experimental support for higer-order and higher-rank
      generics, and, best of all, union and intersection types.&lt;/p&gt;
      
      &lt;h4&gt;Union and intersection types&lt;/h4&gt;
      
      &lt;p&gt;Ceylon was the first modern language to introduce a full implementation of union and intersection
      types, and the first language to realize that union and intersection types make flow-typing and type
      inference, especially generic type inference, very much simpler, more predictable, and more elegant.
      As of today, it’s still the language with the most sophisticated support for unions and intersections.&lt;/p&gt;
      
      &lt;p&gt;What’s most difficult to explain to folks who’ve never written any significant amount of code in
      Ceylon is just how powerful union and intersection types really are. Far from being an exotic
      construct that you encounter occasionally in tricky library code, they form an essential part of the
      everyday experience of writing code in Ceylon, and there is almost no significant Ceylon program
      which doesn’t use union types &lt;em&gt;somewhere&lt;/em&gt;. It’s no exaggeration to say they will totally change the
      way you think about types.&lt;/p&gt;
      
      &lt;h4&gt;Flow-sensitive typing&lt;/h4&gt;
      
      &lt;p&gt;Ceylon was also the first modern language to embrace the notion of flow-sensitive typing, where the
      conditional logic in the body of a function affects the types inferred by the compiler. This approach
      eliminates a significant amount of verbosity and a significant number of runtime type casting errors.
      In combination with Ceylon’s powerful coverage and disjointness analysis, it also helps detect
      certain other kinds of logic errors.&lt;/p&gt;
      
      &lt;h4&gt;The cleanest solution to the problem of null&lt;/h4&gt;
      
      &lt;p&gt;The &lt;code&gt;null&lt;/code&gt; value has perplexed language designers for decades. For a long time the “best” solution
      to the problem was an ML- or Haskell-style &lt;code&gt;Maybe&lt;/code&gt; type, which offered type safety and eliminated
      the hated “null pointer” error. That solution works quite well for languages without subtyping, but
      it’s not the best approach for a language with subtyping and union types. Ceylon’s approach to &lt;code&gt;null&lt;/code&gt;
      is just as type safe, but, with flow-sensitive typing, is more user-friendly, and it doesn’t require
      the overhead of separate &lt;code&gt;Option&lt;/code&gt;-style wrapper objects. Unlike some other languages, &lt;code&gt;Null&lt;/code&gt; isn’t a
      special case in Ceylon’s type system. Rather, it’s just one further example of the power of union
      types.&lt;/p&gt;
      
      &lt;h4&gt;An elegant and powerful representation of tuple and function types&lt;/h4&gt;
      
      &lt;p&gt;Like most other modern languages, Ceylon features tuples and function references. Unlike other
      languages Ceylon doesn’t represent these things as special cases in the type system, nor as an
      explosion of interface types, one for each tuple/function -arity. Instead, there is just one class
      &lt;code&gt;Tuple&lt;/code&gt;, and one interface &lt;code&gt;Callable&lt;/code&gt; which expresses function types in terms of tuple types. This
      approach allows the language to abstract over tuple or function -arity, and write higher-order
      functions that simply can’t be expressed in many other modern languages.&lt;/p&gt;
      
      &lt;h4&gt;Reified generics&lt;/h4&gt;
      
      &lt;p&gt;Along with Gosu, Ceylon is one of only two languages to offer reified generics on the JVM. And it’s
      the only language to offer reified generics on JavaScript virtual machines. You’ll sometimes run
      into attempts to “backsplain” the lack of reified generics in Java or other JVM languages: claims
      that reified generics perform badly, aren’t useful, or don’t work correctly with variance or with
      higher-order generics. Ceylon is an existence proof that none of these assertions is true.&lt;/p&gt;
      
      &lt;p&gt;The system of reified generics backs Ceylon's unique typesafe metamodel, which enables powerful
      runtime metaprogramming (reflection). It also makes debugging easier: you can see the runtime
      type arguments of every generic type or generic function in the Ceylon debugger!&lt;/p&gt;
      
      &lt;h2&gt;A clean, efficient, highly readable syntax&lt;/h2&gt;
      
      &lt;p&gt;A program written in idiomatic Ceylon is usually much more &lt;em&gt;compact&lt;/em&gt; than the same program written
      in Java. But it’s also usually more readable. Ceylon’s syntax appears, at first glance, to be rather
      boring and conservative: it uses familiar (and &lt;em&gt;cleaner&lt;/em&gt;) prefix type annotations instead of postfix
      types; it uses plain English keywords instead of cryptic strings of symbols; its naming convention
      eschews the use of abbreviations. When you look at a program written in Ceylon, you’ll probably
      understand more or less what it’s doing, even if you have only a passing familiarity with the
      language.&lt;/p&gt;
      
      &lt;p&gt;But that first impression misses a surprising amount of syntactic flexibility. Type inference, named
      arguments, comprehensions, tuples and sequences, “fat arrow” function definitions, anonymous
      functions, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, and &lt;code&gt;object&lt;/code&gt; expressions, flow-sensitive typing, and a
      very powerful facility for stream processing all work together to lend a level of expressiveness
      rarely seen outside of dynamic languages.&lt;/p&gt;
      
      &lt;p&gt;Operator overloading is a feature that, while useful, is widely abused in languages that offer it in
      unadulterated form. Instead of untrammelled operator overloading, Ceylon supports operator
      &lt;em&gt;polymorphism&lt;/em&gt;, a more disciplined approach, where its operators have fixed, well-defined semantics,
      but are defined in terms of interfaces that user-written types may satisfy. Thus, you can have the
      &lt;code&gt;+&lt;/code&gt; operator apply to your own class, but it always means some kind of addition-like operation.&lt;/p&gt;
      
      &lt;p&gt;We often don’t need to write down the types of things explicitly (type inference takes care of that),
      but when we do, Ceylon features a uniquely sophisticated expression syntax for types, along with
      type aliases, eliminating the verbosity of generic type declarations in other languages.&lt;/p&gt;
      
      &lt;h2&gt;Awesome modularity and tooling&lt;/h2&gt;
      
      &lt;p&gt;Ceylon’s suite of command line tools, including an incremental compiler, program runner, test runner,
      documentation compiler, code formatter, and WAR archive packager, are all accessible via the &lt;code&gt;ceylon&lt;/code&gt;
      command, which features a plugin architecture, and excellent usability.&lt;/p&gt;
      
      &lt;p&gt;But Ceylon really comes into its own when authoring code using its powerful Eclipse-based IDE.
      Ceylon’s IDE has a feature set that easily surpasses other modern languages, and competes with much
      more mature languages like Java and C#. For those who prefer IntelliJ, an IntelliJ-based IDE is
      already in the works, with a first release planned in the next few months.&lt;/p&gt;
      
      &lt;p&gt;If you’ve ever spent time waiting for &lt;code&gt;mvn&lt;/code&gt; to finish, you’ll immediately appreciate Ceylon’s
      powerful module architecture, which comes fully integrated into the command line tools and IDE.
      Modularity is a problem that is utterly &lt;em&gt;central&lt;/em&gt; to the discipline of software engineering, and
      Ceylon, at least arguably, does it better than any other language out there. You don’t usually need
      to interact directly with the module repository architecture, since the command line compiler, IDE,
      and runtime all know how to fetch dependencies transparently.&lt;/p&gt;
      
      &lt;p&gt;Finally, &lt;a href=&quot;https://herd.ceylon-lang.org&quot;&gt;Ceylon Herd&lt;/a&gt; is an fantastic tool that makes it ridiculously easy to share your work
      with other Ceylon developers.&lt;/p&gt;
      
      &lt;h2&gt;Seamless web development&lt;/h2&gt;
      
      &lt;p&gt;Ceylon is evolving into a compelling platform for web development, allowing you to reuse code
      written for a Java server on the JavaScript client and vice-versa, while still interoperating
      cleanly with native code on both sides. With our new serialization facility, you'll be able to
      transparently move objects between client and server. The Ceylon SDK comes with a HTTP server
      module based on Undertow, and a transactions module based on JBoss Transactions, but if you're
      looking for something &quot;heavier&quot;, Ceylon modules can already be deployed on RedHat's &lt;a href=&quot;https://developers.openshift.com/en/ceylon-overview.html&quot;&gt;OpenShift&lt;/a&gt;
      cloud platform, on WildFly, or on &lt;a href=&quot;http://vertx.io/vertx2/core_manual_ceylon.html&quot;&gt;Vert.x 2&lt;/a&gt; (with Vert.x 3 support coming soon). Alternatively
      you could use Ceylon in Node.js!&lt;/p&gt;
      
      &lt;p&gt;Developing web applications in Ceylon is actually &lt;em&gt;enjoyable&lt;/em&gt;. With Ceylon, you'll spend much less
      time redeploying and/or refreshing things, or wrestling with inadequate tooling, and more time
      focused on writing elegant code.&lt;/p&gt;
      
      &lt;h2&gt;A helpful and open-minded community&lt;/h2&gt;
      
      &lt;p&gt;The Ceylon community is friendly and helpful, and you can usually get your questions answered
      quickly at just about any time of day. And we're &lt;em&gt;extremely&lt;/em&gt; open to feedback, and don't mind
      explaining the reasoning behind decisions we've made. Of course we have the traditional mailing
      lists like any other open source project, but actually we're much more active on Gitter and on the
      GitHub issue tracking system. So come join us on &lt;a href=&quot;https://gitter.im/ceylon/user&quot;&gt;our Gitter channel&lt;/a&gt;, and ask us anything!&lt;/p&gt;
      
      &lt;p&gt;If you're motivated to contribute, there's plenty of places to get involved. Some fairly significant
      parts of the Ceylon ecosystem were originally written by community contributors. Currently, the
      development of two new compiler backends is being driven by the community. Note that a whole lot of
      development, including the IntelliJ IDE, and the new compiler backends, is now being done in Ceylon,
      so you can learn Ceylon by contributing to the Ceylon project itself!&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/07/04/model</id>
    <title>Why build your own type system?</title>
    <updated>2015-07-04T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/07/04/model" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      In Ceylon 1.2 we've factored out the type system of Ceylon
      as an independent module, with minimal dependencies and a
      clean API. The ceylon-model
      project
      incorporates:
      
      
      an extensible object-oriented model of the type system in
      Ceylon,
      algorithms for reasoning about types at compile
      time&#x2014;or even at runtime in a system with reified
      generics&#x2014;and
      a framework for model loading, that is, for loading a
      model representing the types in a program or module from
      binary artifacts, source artifacts, or anything
      else&#x2014;this is a necessary feature for incremental
      compilation and modularity.
      
      
      
      Why might this be interesting to someone outside the Ceylon
      team? Well, if you're thinking of creating a programming
      language with nominal typing, you could consider reusing
      ceylon-model in...
    </summary>
    <content type="html">
      &lt;p&gt;In Ceylon 1.2 we've factored out the type system of Ceylon
      as an independent module, with minimal dependencies and a
      clean API. The &lt;code&gt;ceylon-model&lt;/code&gt;
      &lt;a href=&quot;https://github.com/ceylon/ceylon-model/&quot;&gt;project&lt;/a&gt;
      incorporates:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;an extensible object-oriented model of the type system in
      Ceylon,&lt;/li&gt;
      &lt;li&gt;algorithms for reasoning about types at compile
      time—or even at &lt;em&gt;runtime&lt;/em&gt; in a system with reified
      generics—and&lt;/li&gt;
      &lt;li&gt;a framework for &lt;em&gt;model loading&lt;/em&gt;, that is, for loading a
      model representing the types in a program or module from
      binary artifacts, source artifacts, or anything
      else—this is a necessary feature for incremental
      compilation and modularity.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Why might this be interesting to someone outside the Ceylon
      team? Well, if you're thinking of creating a programming
      language with nominal typing, you could consider reusing
      &lt;code&gt;ceylon-model&lt;/code&gt; in your own language, saving yourself the
      problem of implementing all the hairy typing algorithms that
      we've already spent years getting right. That way, you can
      concentrate on the stuff that's really different about your
      language, that is, the syntax, the compiler backend, the
      runtime semantics, and the basic language types.&lt;/p&gt;
      
      &lt;p&gt;&lt;code&gt;ceylon-model&lt;/code&gt; implements an &lt;em&gt;extremely&lt;/em&gt; complete type
      system, including all the following features:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;nominal typing with single-inheritance of classes and
      multiple-inheritance of interfaces,&lt;/li&gt;
      &lt;li&gt;bounded parametric polymorphism (generics with constraints),&lt;/li&gt;
      &lt;li&gt;sum types,&lt;/li&gt;
      &lt;li&gt;union and intersection types, with sophisticated reasoning
      about principal types and canonicalization,&lt;/li&gt;
      &lt;li&gt;reasoning about subtyping,&lt;/li&gt;
      &lt;li&gt;reasoning about coverage and disjoint types,&lt;/li&gt;
      &lt;li&gt;principal instantiation inheritance (more powerful than
      the single-instantiation inheritance found in other
      languages with subtyping and generics),&lt;/li&gt;
      &lt;li&gt;declaration-site and use-site variance,&lt;/li&gt;
      &lt;li&gt;type constructor polymorphism (higher-kinded types),&lt;/li&gt;
      &lt;li&gt;higher-rank / impredicative polymorphism,&lt;/li&gt;
      &lt;li&gt;type aliases including generic type aliases,&lt;/li&gt;
      &lt;li&gt;self types, and&lt;/li&gt;
      &lt;li&gt;some support for overloading.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;It doesn't include any functionality for type inference,
      flow-sensitive typing, or pattern matching, since in Ceylon
      that stuff is implemented within the typechecker, and anyway
      your language probably has different rules to ours.&lt;/p&gt;
      
      &lt;p&gt;It seems to me that unless your type system is based on
      structural typing or dependent types, &lt;code&gt;ceylon-model&lt;/code&gt; is an
      awesome starting point. It might already have everything you
      need, and, even if it doesn't, it provides a framework that
      would let you incorporate other features into the type
      system. For example, I imagine that primitively-defined
      function, array, tuple, or record types would be easy to
      incorporate.&lt;/p&gt;
      
      &lt;p&gt;We're already reusing this model between the typechecker,
      two compiler backends, two IDE projects, and the runtime, so
      we know its API is reasonable.&lt;/p&gt;
      
      &lt;p&gt;The only stumbling block is that the project is implemented
      in Java, so if you want to use it in a compiler written in a
      different language, you'll probably want to translate it to
      that language first. The code is pretty clean and
      straightforward, so that's probably not a massive hurdle to
      overcome.&lt;/p&gt;
      
      &lt;p&gt;The license for &lt;code&gt;ceylon-model&lt;/code&gt; is Apache 2.0, so you can
      basically do what you like with it. But if you decide to
      use it in a project, please drop us a note, because it makes
      us happy to see people reuse our work.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/06/21/constructors</id>
    <title>Constructors in Ceylon</title>
    <updated>2015-06-21T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/06/21/constructors" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      Since the earliest versions of Ceylon, we've supported a
      streamlined syntax for class initialization where the
      parameters of a class are listed right after the class name,
      and initialization logic goes directly in the body of the
      class.
      
      
      
      
      class Color(shared Integer rgba) {
      
          assert (0 &lt;= rgba &lt;= #FFFFFFFF);
      
          function encodedValue(Integer slot)
                  =&gt; rgba.rightLogicalShift(8*slot).and(#FF);
      
          shared Integer alpha =&gt; encodedValue(3);
      
          shared Integer red =&gt; encodedValue(2);
          shared Integer green =&gt; encodedValue(1);
          shared Integer blue =&gt; encodedValue(0);
      
        ...
    </summary>
    <content type="html">
      &lt;p&gt;Since the earliest versions of Ceylon, we've supported a
      streamlined syntax for class initialization where the
      parameters of a class are listed right after the class name,
      and initialization logic goes directly in the body of the
      class.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class Color(shared Integer rgba) {
      
          assert (0 &amp;lt;= rgba &amp;lt;= #FFFFFFFF);
      
          function encodedValue(Integer slot)
                  =&amp;gt; rgba.rightLogicalShift(8*slot).and(#FF);
      
          shared Integer alpha =&amp;gt; encodedValue(3);
      
          shared Integer red =&amp;gt; encodedValue(2);
          shared Integer green =&amp;gt; encodedValue(1);
          shared Integer blue =&amp;gt; encodedValue(0);
      
          function hex(Integer int) =&amp;gt; formatInteger(int, 16);
      
          string =&amp;gt; &quot;Color { \ 
                     alpha=``hex(alpha)``, \ 
                     red=``hex(red)``, \ 
                     green=``hex(green)``, \ 
                     blue=``hex(blue)`` }&quot;;
      
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;We can instantiate a class like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Color red = Color(#FFFF0000);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;The ability to refer to parameters of the class directly
      from the members of the class really helps cut down on
      verbosity, and most of the time this is a really comfortable
      way to write code.&lt;/p&gt;
      
      &lt;p&gt;However, as we've seen over the past few years of writing
      Ceylon code, there are moments when we would really
      appreciate the ability to write a class with multiple
      initialization paths, something like constructors in Java,
      C#, or C++. To be clear, in the overwhelmingly common
      case—something more than 90% of classes, I would
      estimate—constructors are unnecessary and uncomfortable.
      But we still need a good solution for the remaining trickier
      cases.&lt;/p&gt;
      
      &lt;p&gt;A couple of especially compelling cases we ran into were:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;the class &lt;code&gt;Array&lt;/code&gt; in &lt;code&gt;ceylon.language&lt;/code&gt;, which can be
      allocated with a list of elements, or with a size and a
      single element value, and&lt;/li&gt;
      &lt;li&gt;cloning copy constructors, used, for example, to implement
      &lt;code&gt;HashMap.clone()&lt;/code&gt; and &lt;code&gt;HashSet.clone()&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Unfortunately, I've always found the design of constructors
      that Java and C# inherited from C++ to be a bit strange and
      inexpressive. So before I tell you what we've done about
      constructors in Ceylon 1.2, let me start by explaining what
      I think is wrong with constructors in Java.&lt;/p&gt;
      
      &lt;h2&gt;What's wrong with constructors in Java?&lt;/h2&gt;
      
      &lt;p&gt;As alluded above, the biggest problem with the constructor
      syntax in languages that borrow from C++ is that in the
      common case of a class with just one constructor, the
      parameters of that constructor aren't available in the body
      of the class, leading to awful code like the following:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang: java --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class Point {
          public float x;
          public float y;
          public Point(float x, float y) {
              this.x = x;
              this.y = y;
          }
          public String toString() {
              return &quot;(&quot; + x + &quot;, &quot; + y + &quot;)&quot;;
          }
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This hurts. Fortunately, we've already made that pain go
      away in Ceylon.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class Point(shared Float x, shared Float y) {
          string =&amp;gt; &quot;(``x``, ``y``)&quot;;
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;So let's look at some additional issues with constructors in
      Java.&lt;/p&gt;
      
      &lt;p&gt;To begin with, the syntax is irregular. In C-like languages,
      the grammar for a declaration is:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Modifier* (Keyword|Type) Identifier OtherStuff
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Constructors, strangely, don't conform to this general
      schema, having been bolted on later.&lt;/p&gt;
      
      &lt;p&gt;Second, the constructors of a class are all forced to have
      the same name. This seems like a quite bizarre restriction:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;If they all have the same name, why not declare them with
      a keyword instead of an identifier? DRY, anyone?&lt;/li&gt;
      &lt;li&gt;It's a restriction that robs me of expressiveness. Instead
      of &lt;code&gt;new ColorWithRGBAndAlpha(r,g,b,a)&lt;/code&gt;, giving me a clue
      as to the semantics of the arguments, I write just
      &lt;code&gt;new Color(r,g,b,a)&lt;/code&gt;, and the reader is left guessing.&lt;/li&gt;
      &lt;li&gt;Constructors thus run into Java's totally broken support
      for overloading. I can't have a constructor that takes
      a &lt;code&gt;List&amp;lt;Float&amp;gt;&lt;/code&gt; and another which takes a &lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt;,
      since these two parameter types have the same erasure.&lt;/li&gt;
      &lt;li&gt;Constructor references (&lt;code&gt;Class::new&lt;/code&gt; in Java) can be
      ambiguous, depending on the context.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Third, constructors aren't forced to initialize the instance
      variables of the class. All Java types have a &quot;default&quot;
      (zero or null) value, and if you forget to initialize an
      instance variable in Java, you'll get a &lt;code&gt;NullPointerException&lt;/code&gt;,
      or, worse, an incorrect zero value at runtime. These problems
      most certainly belong to the class of problems that I expect
      a static type system to be able to detect, and, indeed, in
      other contexts Java &lt;em&gt;does&lt;/em&gt; detect uninitialized variables.&lt;/p&gt;
      
      &lt;p&gt;Further note that this would be an even bigger problem in
      Ceylon, because most types don't have &lt;code&gt;null&lt;/code&gt; as an instance,
      so there is no obvious &quot;default&quot; value.&lt;/p&gt;
      
      &lt;p&gt;As usual, my purpose here isn't to bash Java, but to justify
      why we've done things differently in Ceylon.&lt;/p&gt;
      
      &lt;h2&gt;Named constructors and  default constructors&lt;/h2&gt;
      
      &lt;p&gt;By contrast, the newly introduced syntax for constructors in
      Ceylon is regular, expressive, and doesn't rely on
      overloading (which Ceylon doesn't support, except when
      interoperating with native Java code). Here's the basic
      syntax for a constructor:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;new withFooAndBar(Foo foo, Bar bar)
              extends anotherConstructor(foo) {
          //do stuff
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;When the class to which the constructor belongs directly
      extends &lt;code&gt;Basic&lt;/code&gt;, the &lt;code&gt;extends&lt;/code&gt; clause is optional.&lt;/p&gt;
      
      &lt;p&gt;And here's an example of how it's used:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class Color {
      
          shared Integer rgba;
      
          //default constructor
          shared new (Integer rgba) {
              assert (0 &amp;lt;= rgba &amp;lt;= #FFFFFFFF);
              this.rgba = rgba;
          }
      
          //named constructor
          shared new withRGB(
              Integer red, Integer green, Integer blue, 
              Integer alpha = #FF) {
              assert (0 &amp;lt;= red &amp;lt;= #FF, 
                      0 &amp;lt;= green &amp;lt;= #FF, 
                      0 &amp;lt;= blue &amp;lt;= #FF);
              rgba = 
                      alpha.leftLogicalShift(24) +
                      red.leftLogicalShift(16) +
                      green.leftLogicalShift(8) +
                      blue;
          }
      
          //another named constructor
          shared new withRGBIntensities(
              Float red, Float green, Float blue, 
              Float alpha = 1.0) {
              assert (0.0 &amp;lt;= red &amp;lt;= 1.0, 
                      0.0 &amp;lt;= green &amp;lt;= 1.0, 
                      0.0 &amp;lt;= blue &amp;lt;= 1.0);
              function int(Float intensity) 
                      =&amp;gt; (intensity*#FF).integer;
              rgba = 
                      int(alpha).leftLogicalShift(24) +
                      int(red).leftLogicalShift(16) +
                      int(green).leftLogicalShift(8) +
                      int(blue);
          }
      
          function encodedValue(Integer slot)
                  =&amp;gt; rgba.rightLogicalShift(8*slot).and(#FF);
      
          shared Integer alpha =&amp;gt; encodedValue(3);
      
          shared Integer red =&amp;gt; encodedValue(2);
          shared Integer green =&amp;gt; encodedValue(1);
          shared Integer blue =&amp;gt; encodedValue(0);
      
          function hex(Integer int) =&amp;gt; formatInteger(int, 16);
      
          string =&amp;gt; &quot;Color { \ 
                     alpha=``hex(alpha)``, \ 
                     red=``hex(red)``, \ 
                     green=``hex(green)``, \ 
                     blue=``hex(blue)`` }&quot;;
      
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Constructor declarations are indicated with the keyword &lt;code&gt;new&lt;/code&gt;,
      and have a name which begins with a lowercase letter. We call
      a constructor like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Color red = Color.withRGBIntensities(1.0, 0.0, 0.0);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or, using named arguments, like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Color red = 
          Color.withRGBIntensities { 
              red = 1.0; 
              green = 0.0;
              blue = 0.0;
          };
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;A function reference to a constructor has a natural syntax:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Color(Float,Float,Float) createColor
              = Color.withRGBIntensities;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;A class may have a constructor, called the &lt;em&gt;default constructor&lt;/em&gt;,
      with no name. Instantiation via the default constructor works
      just like instantiation of a class without constructors:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Color red = Color(#FFFF0000);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;A class isn't required to have a default constructor, but
      most classes will have one.&lt;/p&gt;
      
      &lt;p&gt;Why do we need the concept of a default constructor? Well,
      because a class with constructors &lt;em&gt;may not have a parameter
      list&lt;/em&gt;. Wait, let's stop and reemphasize that caveat, because
      it's an important one:&lt;/p&gt;
      
      &lt;blockquote&gt;&lt;p&gt;You can't add constructors to a class with a parameter
      list! Instead, you must first rewrite the class to use
      a &quot;default constructor&quot; for its &quot;normal&quot; initialization
      logic.&lt;/p&gt;&lt;/blockquote&gt;
      
      &lt;p&gt;However, a class with constructors may still have
      initialization logic directly in the body of the class. For
      example, the following is perfectly legal:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class Color {
      
          shared Integer rgba;
      
          shared new (Integer rgba) {
              this.rgba = rgba;
          }
      
          shared new withRGB(
              Integer red, Integer green, Integer blue, 
              Integer alpha = #FF) {
              assert (0 &amp;lt;= red &amp;lt;= #FF, 
                      0 &amp;lt;= green &amp;lt;= #FF, 
                      0 &amp;lt;= blue &amp;lt;= #FF);
              rgba = 
                      alpha.leftLogicalShift(24) +
                      red.leftLogicalShift(16) +
                      green.leftLogicalShift(8) +
                      blue;
          }
      
          shared new withRGBIntensities(
              Float red, Float green, Float blue, 
              Float alpha = 1.0) {
              assert (0.0 &amp;lt;= red &amp;lt;= 1.0, 
                      0.0 &amp;lt;= green &amp;lt;= 1.0, 
                      0.0 &amp;lt;= blue &amp;lt;= 1.0);
              function int(Float intensity) 
                      =&amp;gt; (intensity*#FF).integer;
              rgba = 
                      int(alpha).leftLogicalShift(24) +
                      int(red).leftLogicalShift(16) +
                      int(green).leftLogicalShift(8) +
                      int(blue);
          }
      
          //executed for every constructor
          assert (0 &amp;lt;= rgba &amp;lt;= #FFFFFFFF);
      
          //other members
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;The last &lt;code&gt;assert&lt;/code&gt; statement is executed every time the class
      is instantiated.&lt;/p&gt;
      
      &lt;h2&gt;Value constructors&lt;/h2&gt;
      
      &lt;p&gt;The constructors we've just seen are termed &lt;em&gt;callable
      constructors&lt;/em&gt; in the language specification, because they
      declare parameters. We also have &lt;em&gt;value constructors&lt;/em&gt;, which
      don't declare parameters, and which are executed once, the
      first time the constructor is evaluated in the context to
      which the class belongs. For a toplevel class, a value
      constructor is a singleton.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class Color {
      
          shared Integer rgba;
      
          //default constructor
          shared new (Integer rgba) {
              this.rgba = rgba;
          }
      
          //value constructors
      
          shared new white {
              rgba = #FFFFFFFF;
          }
      
          shared new red {
              rgba = #FFFF0000;
          }
      
          shared new green {
              rgba = #FF00FF00;
          }
      
          shared new blue {
              rgba = #FF0000FF;
          }
      
          //etc
          ...
      
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;We can use a value constructor like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Color red = Color.red;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Sometimes the constructors of a class share certain
      initialization logic. If that logic doesn't depend upon the
      parameters of the class, we can put it directly in the body
      of the class, as we've already seen. But if it &lt;em&gt;does&lt;/em&gt; depend
      upon the parameters, we often need to take a different tack.&lt;/p&gt;
      
      &lt;h2&gt;Constructor delegation&lt;/h2&gt;
      
      &lt;p&gt;To facilitate reuse of initialization logic within a class,
      it's useful to allow a constructor to delegate to a different
      constructor of the same class. For this, we use the &lt;code&gt;extends&lt;/code&gt;
      clause:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Integer int(Float intensity) 
              =&amp;gt; (intensity*#FF).integer;
      
      class Color {
      
          shared Integer rgba;
      
          shared new (Integer rgba) {
              this.rgba = rgba;
          }
      
          //value constructors delegate to the default constructor
      
          shared new white 
                  extends Color(#FFFFFFFF) {}
      
          shared new red 
                  extends Color(#FFFF0000) {}
      
          shared new green 
                  extends Color(#FF00FF00) {}
      
          shared new blue 
                  extends Color(#FF0000FF) {}
      
          shared new withRGB(
              Integer red, Integer green, Integer blue, 
              Integer alpha = #FF) {
              assert (0 &amp;lt;= red &amp;lt;= #FF, 
                      0 &amp;lt;= green &amp;lt;= #FF, 
                      0 &amp;lt;= blue &amp;lt;= #FF);
              rgba = 
                      alpha.leftLogicalShift(24) +
                      red.leftLogicalShift(16) +
                      green.leftLogicalShift(8) +
                      blue;
          }
      
          shared new withRGBIntensities(
              Float red, Float green, Float blue, 
              Float alpha = 1.0) 
                  //delegate to other named constructor
                  extends withRGB(int(red), 
                                  int(green), 
                                  int(blue),
                                  int(alpha)) {}
      
          assert (0 &amp;lt;= rgba &amp;lt;= #FFFFFFFF);
      
          //other members
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;A constructor may only delegate to a constructor defined
      earlier in the body of the class.&lt;/p&gt;
      
      &lt;p&gt;Note that we've written &lt;code&gt;extends Color(#FFFFFFFF)&lt;/code&gt; to
      delegate to the default constructor of &lt;code&gt;Color&lt;/code&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Definite initialization and partial constructors&lt;/h2&gt;
      
      &lt;p&gt;An ordinary constructor like &lt;code&gt;Color.withRGB()&lt;/code&gt; or
      &lt;code&gt;Color.withRGBIntensities()&lt;/code&gt; has a responsibility to
      initialize every value reference belonging to the class that
      is either:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;shared&lt;/code&gt;, or&lt;/li&gt;
      &lt;li&gt;used (&quot;captured&quot;) by another member of the class.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;The Ceylon compiler enforces this responsibility at compile
      time and will reject the code unless it can prove that every
      value reference has been fully initialized, either:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;by every ordinary constructor, or&lt;/li&gt;
      &lt;li&gt;in the body of the class itself.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;This rule would make it difficult to factor out common logic
      contained in constructors if it weren't for the notion of a
      &lt;em&gt;partial constructor&lt;/em&gt;. For a partial constructor, the
      requirement that all references are fully initialized is
      relaxed. But a partial constructor may not be used to
      directly instantiate the class. It may only be called from
      the &lt;code&gt;extends&lt;/code&gt; clause of another constructor of the same
      class. A partial constructor is indicated by the &lt;code&gt;abstract&lt;/code&gt;
      annotation:&lt;/p&gt;
      
      &lt;p&gt;Here's a contrived example:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class ColoredPoint {
          shared Point point;
          shared Color color;
      
          //partial constructor
          abstract new withColor(Color color) {
              this.color = color;
          }
      
          shared new forCartesianCoords(Color color, 
              Float x, Float y) 
                  //delegate to partial constructor
                  extends withColor(color) {
              point = Point.cartesian(x, y);
          }
      
          shared new forPolarCoords(Color color, 
              Float r, Float theta) 
                  //delegate to partial constructor
                  extends withColor(color) {
              point = Point.polar(r, theta);
          }
      
          ...
      
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;So far, we've only seen how to delegate to another
      constructor of the same class. But when a class extends a
      superclass, every constructor must ultimately
      delegate—perhaps indirectly—to a constructor of
      the superclass.&lt;/p&gt;
      
      &lt;h2&gt;Constructors and inheritance&lt;/h2&gt;
      
      &lt;p&gt;A class may extend a class with constructors, for example:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class ColoredPoint2(color, Float x, Float y) 
              extends Point.cartesian(x, y) {
          shared Color color;
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;A more interesting case is when the extending class itself
      has constructors:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class ColoredPoint extends Point {
          shared Color color;
      
          shared new forCartesianCoords(Color color, 
              Float x, Float y)
                  //delegate to Point.cartesian()
                  extends cartesian(x, y) {
              this.color = color;
          }
      
          shared new forPolarCoords(Color color, 
              Float r, Float theta)
                  //delegate to Point.polar()
                  extends polar(r, theta) {
              this.color = color;
          }
      
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;In this example, the constructors delegate directly to
      constructors of the superclass.&lt;/p&gt;
      
      &lt;h3&gt;Ordering of initialization logic&lt;/h3&gt;
      
      &lt;p&gt;With constructor delegation, together with initialization
      logic defined directly in the body of the class, you must
      be imagining that initialization can get pretty convoluted.&lt;/p&gt;
      
      &lt;p&gt;Well, no. The general principle of initialization in Ceylon
      remains unchanged: initialization always flows from top to
      bottom, allowing the typechecker to verify that every &lt;code&gt;value&lt;/code&gt;
      is initialized before it is used.&lt;/p&gt;
      
      &lt;p&gt;Consider this class:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class Class {
          print(1);
          abstract new partial() {
              print(2);
          }
          print(3);
          shared new () extends partial() {
              print(4);
          }
          print(5);
          shared new create() extends partial() {
              print(6);
          }
          print(7);
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Calling &lt;code&gt;Class()&lt;/code&gt; results in the following output:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;1
      2
      3
      4
      5
      7
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Calling &lt;code&gt;Class.create()&lt;/code&gt; results in this output:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;1
      2
      3
      5
      6
      7
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;All quite orderly and predictable!&lt;/p&gt;
      
      &lt;p&gt;In the &lt;a href=&quot;http://ceylon-lang.org/blog/2015/06/21/constructors/#comment-2091964265&quot;&gt;comments&lt;/a&gt;,
      David Hagen suggests a way of understanding how constructor
      delegation and ordering works.&lt;/p&gt;
      
      &lt;h2&gt;Using value constructors to emulate enums&lt;/h2&gt;
      
      &lt;p&gt;You might already have noticed that if a class &lt;em&gt;only&lt;/em&gt; has
      value constructors, it's very similar to a Java &lt;code&gt;enum&lt;/code&gt;.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;shared class Day {
          shared actual String string;
          abstract new named(String name) {
              string = name;
          } 
          shared new sunday extends named(&quot;SUNDAY&quot;) {}
          shared new monday extends named(&quot;MONDAY&quot;) {}
          shared new tuesday extends named(&quot;TUESDAY&quot;) {}
          shared new wednesday extends named(&quot;WEDNESDAY&quot;) {}
          shared new thursday extends named(&quot;THURSDAY&quot;) {}
          shared new friday extends named(&quot;FRIDAY&quot;) {}
          shared new saturday extends named(&quot;SATURDAY&quot;) {}
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;We therefore let you use value constructors in a &lt;code&gt;switch&lt;/code&gt;
      statement. The ability to &lt;code&gt;switch&lt;/code&gt; over value constructors
      can be viewed as an extension of the pre-existing facility
      for &lt;code&gt;switch&lt;/code&gt;ing over literal values of types like &lt;code&gt;Integer&lt;/code&gt;,
      &lt;code&gt;Character&lt;/code&gt;, and &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Day day = ... ;
      String message;
      switch (day)
      case (Day.friday) { 
          message = &quot;thank god&quot;; 
      }
      case (Day.sunday | Day.saturday) { 
          message = &quot;we could be having this conversation with beer&quot;; 
      }
      else {
          message = &quot;need more coffee&quot;;
      }
      print(message);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;But when we noticed the similarity to Java &lt;code&gt;enum&lt;/code&gt;s, we
      decided to take the idea a little further than what Java
      offers here. Java enumerations are &lt;em&gt;open&lt;/em&gt;, in the sense that
      a &lt;code&gt;switch&lt;/code&gt; statement which covers all enumerated values of
      an &lt;code&gt;enum&lt;/code&gt; must still include a &lt;code&gt;default&lt;/code&gt; case to be
      considered exhaustive by definite assignment and definite
      return checking.&lt;/p&gt;
      
      &lt;p&gt;But in Ceylon we also have the notion of &lt;em&gt;closed&lt;/em&gt;
      enumerated types, where the &quot;default&quot; case—the &lt;code&gt;else&lt;/code&gt;
      clause of Ceylon's &lt;code&gt;switch&lt;/code&gt; statement—may be omitted,
      but the whole &lt;code&gt;switch&lt;/code&gt; will still be considered exhaustive.&lt;/p&gt;
      
      &lt;p&gt;Note: API designers should be careful to only &quot;close&quot; an
      enumeration that won't grow new value constructors in future
      revisions of the API. &lt;code&gt;Day&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt; are good examples
      of closed enumerations. &lt;code&gt;ErrorType&lt;/code&gt; is an examples of an
      open enumeration.&lt;/p&gt;
      
      &lt;p&gt;If we add an &lt;code&gt;of&lt;/code&gt; clause to &lt;code&gt;Day&lt;/code&gt;, it will be considered a
      closed enumeration.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;shared class Day 
              of sunday | monday | tuesday | wednesday | 
                 thursday | friday | saturday {
          shared actual String string;
          abstract new named(String name) {
              string = name;
          } 
          shared new sunday extends named(&quot;SUNDAY&quot;) {}
          shared new monday extends named(&quot;MONDAY&quot;) {}
          shared new tuesday extends named(&quot;TUESDAY&quot;) {}
          shared new wednesday extends named(&quot;WEDNESDAY&quot;) {}
          shared new thursday extends named(&quot;THURSDAY&quot;) {}
          shared new friday extends named(&quot;FRIDAY&quot;) {}
          shared new saturday extends named(&quot;SATURDAY&quot;) {}
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now Ceylon will consider a &lt;code&gt;switch&lt;/code&gt; statement that covers
      all the value constructors as an exhaustive &lt;code&gt;switch&lt;/code&gt;, and we
      can write the following code without needing an &lt;code&gt;else&lt;/code&gt;
      clause:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Day day = ... ;
      String message;
      switch (day)
      case (Day.monday | Day.tuesday | 
            Day.wednesday | Day.thursday) { 
          message = &quot;need more coffee&quot;; 
      }
      case (Day.friday) { 
          message = &quot;thank god&quot;; 
      }
      case (Day.sunday | Day.saturday) { 
          message = &quot;we could be having this conversation with beer&quot;; 
      }
      print(message);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This is an alternative to the &lt;a href=&quot;http://ceylon-lang.org/documentation/1.1/tour/types/#enumerated_instances&quot;&gt;existing pattern for emulating
      Java-style &lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;A final word&lt;/h2&gt;
      
      &lt;p&gt;The design I've presented here is the final result of a
      thought process that spanned five years. I personally found
      this to be a surprisingly difficult problem to address in a
      principled way. For a time, I hoped to not even need to have
      constructors in the language at all. But ultimately I'm very
      happy with the end result. It seems to me not only
      principled and consistent with the rest of the language, but
      also very expressive and powerful.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/06/12/more-type-functions</id>
    <title>A little more about type functions</title>
    <updated>2015-06-12T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/06/12/more-type-functions" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      My previous post about
      type functions
      generated some interesting discussion, here, and
      on reddit.
      
      Therefore, I think it's worth tying up several loose ends
      from the earlier post. So here's a collection of further
      observations about type functions.
      
      Warning: this post addresses some very technical details of
      how we've incorporated type functions into Ceylon's type
      system. Don't even bother continuing any further until
      you've read the earlier post.
      
      The "why" of this
      
      The most well-known application of higher-order generics is
      for representing high-level abstractions of container types:
      functors, monads, and friends. That's not what motivated me
      to experiment with higher-order generics in Ceylon, and as a
      practical matter I still have little interest in these
      abstractions, though...
    </summary>
    <content type="html">
      &lt;p&gt;My previous post about
      &lt;a href=&quot;https://ceylon-lang.org/blog/2015/06/03/generic-function-refs&quot;&gt;type functions&lt;/a&gt;
      generated some interesting discussion, here, and
      &lt;a href=&quot;http://www.reddit.com/r/programming/comments/38hsrb/programming_with_type_functions_in_ceylon/&quot;&gt;on reddit&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;Therefore, I think it's worth tying up several loose ends
      from the earlier post. So here's a collection of further
      observations about type functions.&lt;/p&gt;
      
      &lt;p&gt;&lt;em&gt;Warning: this post addresses some very technical details of
      how we've incorporated type functions into Ceylon's type
      system. Don't even bother continuing any further until
      you've read the &lt;a href=&quot;https://ceylon-lang.org/blog/2015/06/03/generic-function-refs&quot;&gt;earlier post&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
      
      &lt;h3&gt;The &quot;why&quot; of this&lt;/h3&gt;
      
      &lt;p&gt;The most well-known application of higher-order generics is
      for representing high-level abstractions of container types:
      functors, monads, and friends. That's not what motivated me
      to experiment with higher-order generics in Ceylon, and as a
      practical matter I still have little interest in these
      abstractions, though they're fun to play with.&lt;/p&gt;
      
      &lt;p&gt;No, what bothered me was not that Ceylon's type system
      wasn't powerful enough to represent &lt;code&gt;Functor&lt;/code&gt; or &lt;code&gt;Monad&lt;/code&gt;,
      but rather that Ceylon's type system &lt;em&gt;wasn't powerful enough
      to represent Ceylon&lt;/em&gt;. I'll show you what I mean by that in
      just a second. But first I want to argue that type functions
      can be seen as a regularization of the language.&lt;/p&gt;
      
      &lt;p&gt;From a &lt;em&gt;purely syntactic&lt;/em&gt; point of view, it's always seemed
      a little strange that every sort of type declaration in
      Ceylon can have a list of type parameters, &lt;em&gt;except for a
      type parameter itself&lt;/em&gt;. Furthermore, it's noticeable that I
      can take a reference, or meta reference to any program
      element &lt;em&gt;unless it has a list of type parameters&lt;/em&gt;. Now, such
      restrictions might seem reasonable if a parameterized type
      parameter or a reference to a generic declaration were not
      meaningful notions at a fundamental level. But they clearly
      &lt;em&gt;are&lt;/em&gt; meaningful, and even at least &lt;em&gt;somewhat&lt;/em&gt; useful.&lt;/p&gt;
      
      &lt;p&gt;Exactly &lt;em&gt;how&lt;/em&gt; useful is a different question—the
      jury's still out, at least in my mind. And so perhaps we'll
      ultimately conclude that this stuff isn't worth its weight.
      The weight being, substantially, the time it takes for
      programmers new to Ceylon to understand this stuff.&lt;/p&gt;
      
      &lt;p&gt;In the original post, I showed how type functions were
      necessary to represent the type of a reference to a generic
      function. One place where this problem arises is with one of
      Ceylon's more unique features: its &lt;em&gt;typesafe metamodel&lt;/em&gt;.&lt;/p&gt;
      
      &lt;h3&gt;A use case for generic function reference types&lt;/h3&gt;
      
      &lt;p&gt;Usually, I can obtain a metamodel object that represents a
      class or function and captures its type signature. For
      example, the expression &lt;code&gt;`String`&lt;/code&gt; evaluates to a
      metamodel object that captures the type and initializer
      parameters of the class &lt;code&gt;String&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Class&amp;lt;String,[{Character*}]&amp;gt; stringClass = `String`;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;For a generic declaration, I can do a similar thing, as long
      as I'm prepared to nail down the type arguments. For example,
      I can write &lt;code&gt;`Singleton&amp;lt;String&amp;gt;`&lt;/code&gt; to get a metamodel
      object representing the class &lt;code&gt;Singleton&lt;/code&gt; after applying the
      type argument &lt;code&gt;String&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Class&amp;lt;Singleton&amp;lt;String&amp;gt;,[String]&amp;gt; stringSingletonClass
              = `Singleton&amp;lt;String&amp;gt;`
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;But in Ceylon as it exists today, I can't obtain a typed
      metamodel object that represents just &lt;code&gt;`Singleton`&lt;/code&gt;,
      because to represent the type of that metamodel object I
      would necessarily need a type function.&lt;/p&gt;
      
      &lt;p&gt;Now, with the new experimental support for type functions,
      the type of the expression &lt;code&gt;`Singleton`&lt;/code&gt; could be
      &lt;code&gt;&amp;lt;T&amp;gt; =&amp;gt; Class&amp;lt;Singleton&amp;lt;T&amp;gt;,[T]&amp;gt;()&lt;/code&gt;, allowing code like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;value singletonGenericClass = `Singleton`;
      ...
      Class&amp;lt;Singleton&amp;lt;String&amp;gt;,[String]&amp;gt; stringSingletonClass 
              = singletonGenericClass&amp;lt;String&amp;gt;();
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;That's just one example of how allowing references to
      generic functions makes Ceylon feel more &quot;complete&quot;.&lt;/p&gt;
      
      &lt;h3&gt;Two use cases for anonymous type functions&lt;/h3&gt;
      
      &lt;p&gt;I get the impression that the &quot;scariest&quot; bit of what I've
      presented in the previous post is the notation for anonymous
      type functions. That is, the following syntax:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;X&amp;gt; =&amp;gt; X
      &amp;lt;X&amp;gt; =&amp;gt; [X,X,X]
      &amp;lt;X,Y&amp;gt; =&amp;gt; X|Y
      &amp;lt;T&amp;gt; given T satisfies Object =&amp;gt; Category&amp;lt;T&amp;gt;(T*)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;But I'm convinced that this notation is not really that
      hard to understand. The reason I assert this is because if
      I give each of these type functions a name, then most of
      you guys have no problem understanding them:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;alias Identity&amp;lt;X&amp;gt; =&amp;gt; X;
      alias Triple&amp;lt;X&amp;gt; =&amp;gt; [X,X,X];
      alias Union&amp;lt;X,Y&amp;gt; =&amp;gt; X|Y;
      alias CategoryCreator&amp;lt;T&amp;gt; given T satisfies Object =&amp;gt; Category&amp;lt;T&amp;gt;(T*);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;&lt;em&gt;But&lt;/em&gt;—one might reasonably enquire—&lt;em&gt;why do we
      even need them, if the named versions are easier to read&lt;/em&gt;?&lt;/p&gt;
      
      &lt;p&gt;Well, we need them:&lt;/p&gt;
      
      &lt;ol&gt;
      &lt;li&gt;in order to be able to denote the type of a reference to
      a generic function—remember, we don't have
      undenotable types in Ceylon—and&lt;/li&gt;
      &lt;li&gt;to make it easy to &lt;em&gt;partially apply&lt;/em&gt; a named type
      function like &lt;code&gt;Map&lt;/code&gt;.&lt;/li&gt;
      &lt;/ol&gt;&lt;p&gt;For example, we want to be able to write stuff like
      &lt;code&gt;&amp;lt;T&amp;gt; =&amp;gt; Map&amp;lt;String,T&amp;gt;&lt;/code&gt; when working with higher-order
      generics, thus turning a type function of two type
      parameters into a type function of one type parameter.&lt;/p&gt;
      
      &lt;h3&gt;Are type functions &quot;type types&quot;?&lt;/h3&gt;
      
      &lt;p&gt;One thing I should have made very clear, and forgot, is that
      type functions don't represent an additional meta level. In
      Ceylon's type system, type functions are types, in the very
      same sense that function are values in Ceylon and other
      modern languages.&lt;/p&gt;
      
      &lt;p&gt;There simply is no additional meta-type system for types in
      Ceylon. The closest thing we have to a &quot;type type&quot; is a
      generic type constraint, but that's an extremely
      impoverished sort of type type, since Ceylon provides no
      facilities at all to abstract over type constraints—I
      can't even assign an alias to a type constraint and reuse it
      by name.&lt;/p&gt;
      
      &lt;p&gt;Ceylon reasons about type constraints and assignability of
      types to type variables using hardcoded rules written
      primitively into the language spec and type checker, not by
      abstraction over the types of types.&lt;/p&gt;
      
      &lt;h3&gt;Type functions and subtyping&lt;/h3&gt;
      
      &lt;p&gt;But if a type function is a type, what are its subtyping
      relationships with other types and other type functions?&lt;/p&gt;
      
      &lt;p&gt;Well, first, recall that some type functions have instances:
      generic function references. We didn't want to introduce
      values into the language that aren't &lt;code&gt;Object&lt;/code&gt;s, so we've
      declared that every type function is a subtype of &lt;code&gt;Object&lt;/code&gt;.
      This preserves the useful property that our type system has
      a single root type &lt;code&gt;Anything&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Next, recall that an ordinary function type is &lt;em&gt;covariant&lt;/em&gt;
      in its return type, and &lt;em&gt;contravariant&lt;/em&gt; in its parameter
      types. For example, the function type:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;String(Object, Object)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;is a subtype of:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Object(String, String)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Since if a function accepts two &lt;code&gt;Object&lt;/code&gt;s and returns a
      &lt;code&gt;String&lt;/code&gt;, then it's clearly also a function that accepts two
      &lt;code&gt;String&lt;/code&gt;s and returns an &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Given two function types with one parameter:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;F(P)
      G(Q)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Then &lt;code&gt;F(P)&lt;/code&gt; is a subtype of &lt;code&gt;G(Q)&lt;/code&gt; iff &lt;code&gt;P&lt;/code&gt; is a supertype of
      &lt;code&gt;Q&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt; is a subtype of &lt;code&gt;G&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Similar rules apply to type functions. Consider two type
      functions of one type parameter:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;alias A&amp;lt;X&amp;gt; given X satisfies U =&amp;gt; F&amp;lt;X&amp;gt;
      alias B&amp;lt;Y&amp;gt; given Y satisfies V =&amp;gt; G&amp;lt;Y&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Then &lt;code&gt;A&lt;/code&gt; is a subtype of &lt;code&gt;B&lt;/code&gt; iff:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;the upper bound &lt;code&gt;U&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt; is a supertype of the upper
      bound &lt;code&gt;V&lt;/code&gt; on &lt;code&gt;Y&lt;/code&gt;, and&lt;/li&gt;
      &lt;li&gt;for any type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;F&amp;lt;T&amp;gt;&lt;/code&gt; is a subtype of &lt;code&gt;G&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;That is to say, if &lt;code&gt;A&amp;lt;X&amp;gt;&lt;/code&gt; accepts every type argument &lt;code&gt;T&lt;/code&gt;
      that &lt;code&gt;B&amp;lt;Y&amp;gt;&lt;/code&gt; accepts, and for each such &lt;code&gt;T&lt;/code&gt;, the applied type
      &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; is a subtype of the applied type &lt;code&gt;B&amp;lt;T&amp;gt;&lt;/code&gt;, then we can
      soundly replace &lt;code&gt;B&lt;/code&gt; with &lt;code&gt;A&lt;/code&gt; in well-typed code.&lt;/p&gt;
      
      &lt;p&gt;(Of course, these rules generalize to type functions with
      multiple type parameters.)&lt;/p&gt;
      
      &lt;h3&gt;Generic function types and subtyping&lt;/h3&gt;
      
      &lt;p&gt;Now let's narrow our attention to consider only type
      functions that represent the types of generic functions.
      To make it easier, we'll consider generic functions of the
      following form, with just one type parameter and just one
      value parameter:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;F&amp;lt;X&amp;gt; f&amp;lt;X&amp;gt;(P&amp;lt;X&amp;gt; p) given X satisfies U =&amp;gt; ... ;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Here, &lt;code&gt;F&amp;lt;X&amp;gt;&lt;/code&gt; is the return type, a type expression involving
      the type parameter &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;P&amp;lt;X&amp;gt;&lt;/code&gt; is the parameter type,
      which also involves &lt;code&gt;X&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;The type of this generic function—as we
      &lt;a href=&quot;https://ceylon-lang.org/blog/2015/06/03/generic-function-refs/#the_type_of_a_generic_function_is_a_type_function&quot;&gt;saw&lt;/a&gt;
      in the previous post— is the type function:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;X&amp;gt; given X satisfies U =&amp;gt; F&amp;lt;X&amp;gt;(P&amp;lt;X&amp;gt;)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;So let's consider two type functions of the general form
      we're considering:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;alias A&amp;lt;X&amp;gt; given X satisfies U =&amp;gt; F&amp;lt;X&amp;gt;(P&amp;lt;X&amp;gt;)
      alias B&amp;lt;Y&amp;gt; given Y satisfies V =&amp;gt; G&amp;lt;Y&amp;gt;(Q&amp;lt;Y&amp;gt;)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Then we see quickly that &lt;code&gt;A&lt;/code&gt; is a subtype of &lt;code&gt;B&lt;/code&gt; iff:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;the upper bound &lt;code&gt;U&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt; is a supertype of the upper
      bound &lt;code&gt;V&lt;/code&gt; on &lt;code&gt;Y&lt;/code&gt;, and&lt;/li&gt;
      &lt;li&gt;for any type &lt;code&gt;T&lt;/code&gt;, the return type &lt;code&gt;F&amp;lt;T&amp;gt;&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is a
      subtype of the return type &lt;code&gt;G&amp;lt;T&amp;gt;&lt;/code&gt; of &lt;code&gt;B&lt;/code&gt;, and the
      parameter type &lt;code&gt;P&amp;lt;T&amp;gt;&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is a supertype of the
      parameter type &lt;code&gt;Q&amp;lt;T&amp;gt;&lt;/code&gt; of &lt;code&gt;B&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;For example, this generic function type:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;X&amp;gt; =&amp;gt; X&amp;amp;Object(X|Object)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;is a subtype of this generic function type:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;X&amp;gt; given X satisfies Object =&amp;gt; X(X)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Take a minute to convince yourself that this is correct
      intuitively.&lt;/p&gt;
      
      &lt;p&gt;(Again, these rules generalize naturally to functions with
      multiple type parameters and/or multiple value parameters.)&lt;/p&gt;
      
      &lt;h3&gt;Type functions and type inference&lt;/h3&gt;
      
      &lt;p&gt;When we call a first-order generic function in Ceylon, we
      don't usually need to explicitly specify type arguments.
      Instead, we can usually infer them from the value arguments
      of the invocation expression. For example, if we have this
      generic function:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;List&amp;lt;Out&amp;gt; map&amp;lt;In,Out&amp;gt;(Out(In) fun, List&amp;lt;In&amp;gt; list) =&amp;gt; ... ;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Then we can always safely infer &lt;code&gt;In&lt;/code&gt; and &lt;code&gt;Out&lt;/code&gt;, because
      there's a unique most-precise choice of type arguments:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;value list = map(Integer.string, ArrayList { 10, 20, 30 });
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;In this example, we can safely infer that &lt;code&gt;In&lt;/code&gt; is &lt;code&gt;Integer&lt;/code&gt;,
      and &lt;code&gt;Out&lt;/code&gt; is &lt;code&gt;String&lt;/code&gt;, without any loss of precision.&lt;/p&gt;
      
      &lt;p&gt;Unfortunately, once higher-order generics come into play,
      inference of type functions is a much more ambiguous problem.
      Consider this second-order generic function, which abstracts
      the &lt;code&gt;map()&lt;/code&gt; function away from the container type, by
      introducing the type function variable &lt;code&gt;Box&lt;/code&gt; to represent
      the unknown container type:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Box&amp;lt;Out&amp;gt; fmap&amp;lt;Box,In,Out&amp;gt;(Out(In) fun, Box&amp;lt;In&amp;gt; box) 
              given Box&amp;lt;Element&amp;gt; { ... }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And now consider the following invocation of this function:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;fmap(Integer.string, ArrayList { 10, 20, 30 })
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;What type should we infer for &lt;code&gt;Element&lt;/code&gt;, and what type
      function for &lt;code&gt;Box&lt;/code&gt;?&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;Integer&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt;?&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;Integer&lt;/code&gt; and &lt;code&gt;Iterable&lt;/code&gt;?&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;Integer&lt;/code&gt; and &lt;code&gt;ArrayList&lt;/code&gt;?&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;Integer&lt;/code&gt; and &lt;code&gt;MutableList&lt;/code&gt;?&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;Integer&lt;/code&gt; and &lt;code&gt;ListMutator&lt;/code&gt;?&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;Integer&lt;/code&gt; and &lt;code&gt;Collection&lt;/code&gt;?&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;Category&lt;/code&gt;?&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;In general, there might be several different reasonable
      choices, and no really good criteria for choosing between
      them. So in this case, we require that the type arguments be
      specified explicitly:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;fmap&amp;lt;List,Integer,String&amp;gt;(Integer.string, ArrayList { 10, 20, 30 })
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;However, there is a pattern we can use to make type function
      inference possible. In this case, we could define the
      following interface:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;interface Functor&amp;lt;Box,Element&amp;gt; given Box&amp;lt;Value&amp;gt; { ... }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now let's imagine that our &lt;code&gt;ArrayList&lt;/code&gt; class inherits
      &lt;code&gt;Functor&lt;/code&gt;, so that any &lt;code&gt;ArrayList&amp;lt;Element&amp;gt;&lt;/code&gt; is a
      &lt;code&gt;Functor&amp;lt;List,Element&amp;gt;&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;And let's redefine &lt;code&gt;fmap()&lt;/code&gt; like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;  Box&amp;lt;Out&amp;gt; fmap&amp;lt;Box,In,Out&amp;gt;(Out(In) fun, Functor&amp;lt;Box,In&amp;gt; box) 
              given Box&amp;lt;Element&amp;gt; { ... }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Then, finally, for the same instantiation expression we had
      before:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;fmap(Integer.string, ArrayList { 10, 20, 30 })
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;we can now unambiguously infer that &lt;code&gt;Box&lt;/code&gt; is &lt;code&gt;List&lt;/code&gt; and
      &lt;code&gt;In&lt;/code&gt; is &lt;code&gt;Integer&lt;/code&gt;, since those types are encoded as type
      arguments to &lt;code&gt;Functor&lt;/code&gt; in the principal supertype
      instantiation of &lt;code&gt;Functor&lt;/code&gt; for the expression
      &lt;code&gt;ArrayList { 10, 20, 30 }&lt;/code&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Instances of type functions&lt;/h3&gt;
      
      &lt;p&gt;In the original post, we noted that a type function that
      returns a function type is the type of a generic function.
      For example, the type function:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;X&amp;gt; given X satisfies Object =&amp;gt; X(X)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Is the type of this generic function:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;X f&amp;lt;X&amp;gt;(X x) given X satisfies Object =&amp;gt; x;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;But then it's natural to enquire: if some type functions are
      the types of generic functions, what are the &lt;em&gt;other&lt;/em&gt; type
      functions the types of?&lt;/p&gt;
      
      &lt;p&gt;Well, if you reflect for a second on the relationship
      between types and values, I think you'll see that they must
      be the types of &lt;em&gt;generic value declarations&lt;/em&gt;. That is, this
      type function:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;X&amp;gt; =&amp;gt; List&amp;lt;X&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;would be the type of this value, written in pseudo-Ceylon:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;List&amp;lt;X&amp;gt; list&amp;lt;X&amp;gt; =&amp;gt; ... ;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;That is, when presented with a type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;list&amp;lt;X&amp;gt;&lt;/code&gt; evaluates
      to a &lt;code&gt;List&amp;lt;X&amp;gt;&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Of course there are no actual generic values in Ceylon, the
      closest thing we have is a nullary generic function:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;List&amp;lt;X&amp;gt; list&amp;lt;X&amp;gt;() =&amp;gt; ... ;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;whose type is actually:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;X&amp;gt; =&amp;gt; List&amp;lt;X&amp;gt;()
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;There's no plan to ever introduce generic values into Ceylon,
      so types like &lt;code&gt;&amp;lt;X&amp;gt; =&amp;gt; List&amp;lt;X&amp;gt;&lt;/code&gt; have no instances. They're
      useful only as type arguments to higher-order generic types.&lt;/p&gt;
      
      &lt;h3&gt;Type functions and principal typing&lt;/h3&gt;
      
      &lt;p&gt;Finally, let's address a rather technical point.&lt;/p&gt;
      
      &lt;p&gt;A very important property of Ceylon's type system is the
      ability to form a &lt;em&gt;principal instantiation&lt;/em&gt; of any union or
      intersection of different instantiations of a generic type.&lt;/p&gt;
      
      &lt;p&gt;For, example, for the covariant type &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;List&amp;lt;X&amp;gt; | List&amp;lt;Y&amp;gt;&lt;/code&gt; has the principal instantiation
      &lt;code&gt;List&amp;lt;X|Y&amp;gt;&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;List&amp;lt;X&amp;gt; &amp;amp; List&amp;lt;Y&amp;gt;&lt;/code&gt; has the principal instantiation
      &lt;code&gt;List&amp;lt;X&amp;amp;Y&amp;gt;&lt;/code&gt;
      &lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;For the contravariant type &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt;:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;Comparable&amp;lt;X&amp;gt; | Comparable&amp;lt;Y&amp;gt;&lt;/code&gt; has the principal
      instantiation &lt;code&gt;Comparable&amp;lt;X&amp;amp;Y&amp;gt;&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;Comparable&amp;lt;X&amp;gt; &amp;amp; Comparable&amp;lt;Y&amp;gt;&lt;/code&gt; has the principal
      instantiation &lt;code&gt;Comparable&amp;lt;X|Y&amp;gt;&lt;/code&gt;
      &lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Naturally, it's important that we can do the same tricks for
      intersections and unions of instantiations of higher-order
      types. As at happens, this works out extremely naturally,
      using the following identities:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;&amp;lt;&amp;lt;X&amp;gt; =&amp;gt; F&amp;lt;X&amp;gt;&amp;gt; | &amp;lt;&amp;lt;Y&amp;gt; =&amp;gt; G&amp;lt;Y&amp;gt;&amp;gt;&lt;/code&gt; is a subtype of
      &lt;code&gt;&amp;lt;T&amp;gt; =&amp;gt; F&amp;lt;T&amp;gt; | G&amp;lt;T&amp;gt;&lt;/code&gt;, and&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;&amp;lt;&amp;lt;X&amp;gt; =&amp;gt; F&amp;lt;X&amp;gt;&amp;gt; &amp;amp; &amp;lt;&amp;lt;Y&amp;gt; =&amp;gt; G&amp;lt;Y&amp;gt;&amp;gt;&lt;/code&gt; is a subtype of
      &lt;code&gt;&amp;lt;T&amp;gt; =&amp;gt; F&amp;lt;T&amp;gt; &amp;amp; G&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Thus, if we have the following covariant second-order type:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;interface Functor&amp;lt;out Element, out Container&amp;gt;
              given Container&amp;lt;E&amp;gt; { ... }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Then we obtain the following principal instantiations:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;Functor&amp;lt;E,A&amp;gt; | Functor&amp;lt;F,B&amp;gt;&lt;/code&gt; has the principal
      instantiation &lt;code&gt;Functor&amp;lt;E|F,&amp;lt;T&amp;gt; =&amp;gt; A&amp;lt;T&amp;gt;|B&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, and&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;Functor&amp;lt;E,A&amp;gt; &amp;amp; Functor&amp;lt;F,B&amp;gt;&lt;/code&gt; has the principal
      instantiation &lt;code&gt;Functor&amp;lt;E&amp;amp;F, &amp;lt;T&amp;gt; =&amp;gt; A&amp;lt;T&amp;gt;&amp;amp;B&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;You don't need to know these identities when you're writing
      code in Ceylon, but it's nice to know that type functions
      don't undermine the basic algebraic properties which are the
      reason Ceylon's type system is so nice to work with.
      Everything fits together here, without weird holes and
      corner cases.&lt;/p&gt;
      
      &lt;h3&gt;A word about &quot;rank&quot;&lt;/h3&gt;
      
      &lt;p&gt;In the previous post I described our support for references
      to generic functions as &quot;arbitrary rank&quot; polymorphism, which
      prompted a short discussion about how to measure the rank of
      a generic type. I now think that the term &quot;rank&quot; probably
      isn't very meaningful in connection to Ceylon, since there's
      nothing special about our function types: they're just
      instantiations of the perfectly ordinary generic type
      &lt;code&gt;Callable&lt;/code&gt;. As suggested by Kamatsu
      &lt;a href=&quot;http://www.reddit.com/r/programming/comments/38hsrb/programming_with_type_functions_in_ceylon/crva8md&quot;&gt;on reddit&lt;/a&gt;,
      it seems to me that a better word to use is probably
      &quot;impredicative&quot;.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/06/03/generic-function-refs</id>
    <title>Programming with type functions in Ceylon</title>
    <updated>2015-06-03T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/06/03/generic-function-refs" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      I've recently been working on some experimental new features
      of Ceylon's already extremely powerful type system. What I'm
      going to explain in this post is known, technically, as:
      
      
      higher order generic types (or type constructor
      polymorphism, or higher kinds), and
      higher rank generic types (or rank-N polymorphism).
      
      
      
      Please don't worry about this jargon salad. (And please don't
      try to google any of those terms, because the explanations
      you'll find will only make these pretty straightforward
      notions seem confusing.) Stick with me, and I'll do my best
      to explain the concepts in intuitive terms, without needing
      any of the above terminology.
      
      But first, let's start with pair of examples that illustrate
      a motivating problem.
      
      This...
    </summary>
    <content type="html">
      &lt;p&gt;I've recently been working on some experimental new features
      of Ceylon's already extremely powerful type system. What I'm
      going to explain in this post is known, technically, as:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;strong&gt;higher order generic types&lt;/strong&gt; (or &lt;em&gt;type constructor
      polymorphism&lt;/em&gt;, or &lt;em&gt;higher kinds&lt;/em&gt;), and&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;higher rank generic types&lt;/strong&gt; (or &lt;em&gt;rank-N polymorphism&lt;/em&gt;).&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Please don't worry about this jargon salad. (And please don't
      try to google any of those terms, because the explanations
      you'll find will only make these pretty straightforward
      notions seem confusing.) Stick with me, and I'll do my best
      to explain the concepts in intuitive terms, without needing
      any of the above terminology.&lt;/p&gt;
      
      &lt;p&gt;But first, let's start with pair of examples that illustrate
      a motivating problem.&lt;/p&gt;
      
      &lt;p&gt;This function simply returns its argument:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Object pipeObject(Object something) =&amp;gt; something;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This function adds &lt;code&gt;Float&lt;/code&gt;s:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Float addFloats(Float x, Float y) =&amp;gt; x+y;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Modern programming language let us treat either of these
      functions as a value and pass it around the system. For
      example, I can write:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Object(Object) pipeObjectFun = pipeObject;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Float(Float,Float) addFloatsFun = addFloats;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Where &lt;code&gt;Object(Object)&lt;/code&gt; and &lt;code&gt;Float(Float,Float)&lt;/code&gt; represent
      the &lt;em&gt;types&lt;/em&gt; of the functions, and &lt;code&gt;pipeObject&lt;/code&gt; and
      &lt;code&gt;addFloats&lt;/code&gt; are a &lt;em&gt;references&lt;/em&gt; to the functions. So far so
      good.&lt;/p&gt;
      
      &lt;p&gt;But sometimes it's useful to have a function that abstracts
      away from the concrete data type using generics. We
      introduce a type variable, to represent the &quot;unknown&quot; type
      of thing we're dealing with:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Any pipe&amp;lt;Any&amp;gt;(Any anything) =&amp;gt; anything;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Number add&amp;lt;Number&amp;gt;(Number x, Number y)
                  given Number satisfies Summable&amp;lt;Number&amp;gt;
              =&amp;gt; x+y;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Sometimes, as in &lt;code&gt;add()&lt;/code&gt;, the unknown type is constrained
      in some way. We express this using a type constraint:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;given Number satisfies Summable&amp;lt;Number&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This is Ceylon's way of denoting that &lt;code&gt;Number&lt;/code&gt; may only be a
      type which is a subtype of the upper bound &lt;code&gt;Summable&amp;lt;Number&amp;gt;&lt;/code&gt;,
      i.e. that it is a type to which we can apply the addition
      operator &lt;code&gt;+&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Now, what if I want to pass around a reference to this
      function. Well, one thing I can typically do is nail down
      the unknown type to a concrete value:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Object(Object) pipeObjectFun = pipe&amp;lt;Object&amp;gt;;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Float(Float,Float) addFloatsFun = add&amp;lt;Float&amp;gt;;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;But that's a bit disappointing—we've lost the fact
      that &lt;code&gt;add()&lt;/code&gt; was generic. Now, in object-oriented languages
      it's possible to define the generic function as a member of
      a class, and pass an instance of the class around the system.
      This is called the &lt;em&gt;strategy pattern&lt;/em&gt;. But it's inconvenient
      to have to write a whole class just to encapsulate a function
      reference.&lt;/p&gt;
      
      &lt;p&gt;It would be nicer to be able to write:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;TypeOfPipe pipeFun = pipe;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;TypeOfAdd addFun = add; 
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Where &lt;code&gt;TypeOfPipe&lt;/code&gt; and &lt;code&gt;TypeOfAdd&lt;/code&gt; are the types of the
      generic functions. The problem is that there's no way to
      represent these types within the type system of most
      languages. Let's see how we can do that in Ceylon 1.2.&lt;/p&gt;
      
      &lt;h3&gt;Introducing type functions&lt;/h3&gt;
      
      &lt;p&gt;I promised to avoid jargon, and avoid jargon I will. The
      only bit of terminology we'll need is the idea of a &lt;em&gt;type
      function&lt;/em&gt;. A type function, as its name implies, is a
      function that accepts zero or more types, and produces a
      type. Type functions might seem exotic and abstract at
      first, but there's one thing that will help you understand
      them:&lt;/p&gt;
      
      &lt;blockquote&gt;&lt;p&gt;You already know almost everything you need to know about
      type functions, because almost everything you know about
      ordinary (value) functions is also true of type functions.&lt;/p&gt;&lt;/blockquote&gt;
      
      &lt;p&gt;If you stay grounded in the analogy to ordinary functions,
      you'll have no problems with the rest of this post, I
      &lt;em&gt;promise&lt;/em&gt;.&lt;/p&gt;
      
      &lt;p&gt;So, we all know what an ordinary function looks like:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;function addFloats(Float x, Float y) =&amp;gt; x+y;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Let's break that down, we have:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;the function name, and list of parameters, to the left
      of a fat arrow, and&lt;/li&gt;
      &lt;li&gt;an expression on the right of the fat arrow.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;A type function doesn't look very different. It has a name
      and (type) parameters on the left of a fat arrow, and a
      (type) expression on the right. It looks like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;alias Pair&amp;lt;Value&amp;gt; =&amp;gt; [Value,Value];
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Aha! This is something we've already seen! So a type
      function is nothing more than a generic type alias! This
      particular type function accepts a type, and produces a
      tuple type, a pair, whose elements are of the given type.&lt;/p&gt;
      
      &lt;p&gt;Actually not every type function is a type alias. A generic
      class or interface is a type function. For example:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;interface List&amp;lt;Element&amp;gt; { ... }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This interface declaration accepts a type &lt;code&gt;Element&lt;/code&gt;, and
      produces a type &lt;code&gt;List&amp;lt;Element&amp;gt;&lt;/code&gt;, so it's a type function.&lt;/p&gt;
      
      &lt;p&gt;I can call a function by providing values as arguments:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;pipe(&quot;hello&quot;)
      add(1.0, 2.0)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;These expressions produce the values &lt;code&gt;&quot;hello&quot;&lt;/code&gt; and &lt;code&gt;3.0&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;I can &lt;em&gt;apply&lt;/em&gt; a type function by providing types as
      arguments:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Pair&amp;lt;Float&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This &lt;em&gt;type&lt;/em&gt; expression produces the &lt;em&gt;type&lt;/em&gt; &lt;code&gt;[Float,Float]&lt;/code&gt;,
      by applying the type function &lt;code&gt;Pair&lt;/code&gt; to the type argument
      &lt;code&gt;Float&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Similarly, I can apply the type function &lt;code&gt;List&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This type expression just literally produces the type
      &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;, by applying the type function &lt;code&gt;List&lt;/code&gt; to
      the type argument &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;On the other hand, I can take a reference to a value
      function by just writing its name, without any arguments,
      for example, &lt;code&gt;pipe&lt;/code&gt;, or &lt;code&gt;add&lt;/code&gt;. I can do the same with type
      functions, writing &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;List&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Back in the quotidian world of ordinary values, I can write
      down an &lt;em&gt;anonymous function&lt;/em&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;(Float x, Float y) =&amp;gt; x+y
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;In the platonic world of types, I can do that too:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;Value&amp;gt; =&amp;gt; [Value,Value]
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Finally, an ordinary value function can constrain its
      arguments using a type annotation like &lt;code&gt;Float x&lt;/code&gt;. A type
      function can do the same thing, albeit with a more
      cumbersome syntax:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;interface List&amp;lt;Element&amp;gt; 
              given Element satisfies Object 
      {
          //define the type list
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Even an anonymous type function may have constraints:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;Value&amp;gt; given Value satisfies Object 
              =&amp;gt; [Value,Value]
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;&lt;strong&gt;Jargon watch:&lt;/strong&gt; most people, including me, use the term
      &lt;em&gt;type constructor&lt;/em&gt; instead of &quot;type function&quot;.&lt;/p&gt;
      
      &lt;h3&gt;Type functions are types&lt;/h3&gt;
      
      &lt;p&gt;Now we're going to make a key conceptual leap. Recall that
      in modern languages, functions are treated as values. I can&lt;/p&gt;
      
      &lt;ol&gt;
      &lt;li&gt;take a function, and assign it to a variable, and then&lt;/li&gt;
      &lt;li&gt;call that variable within the body of the function.&lt;/li&gt;
      &lt;/ol&gt;&lt;p&gt;For example:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;void secondOrder(Float(Float,Float) fun) {
          print(fun(1.0, 2.0));
      }
      
      //apply to a function reference
      secondOrder(addFloats);
      
      //apply to an anonymous function
      secondOrder((Float x, Float y) =&amp;gt; x+y);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;We call functions which accept functions &lt;em&gt;higher order
      functions&lt;/em&gt;.&lt;/p&gt;
      
      &lt;p&gt;Similarly, we're going to declare that &lt;em&gt;type functions are
      types&lt;/em&gt;. That is, I can:&lt;/p&gt;
      
      &lt;ol&gt;
      &lt;li&gt;take a type function and assign it to a type variable,
      and then&lt;/li&gt;
      &lt;li&gt;apply that type variable in the body of the declaration
      it parameterizes.&lt;/li&gt;
      &lt;/ol&gt;&lt;p&gt;For example:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;interface SecondOrder&amp;lt;Box&amp;gt; given Box&amp;lt;Value&amp;gt; {
          shared formal Box&amp;lt;Float&amp;gt; createBox(Float float);
      }
      
      //apply to a generic type alias
      SecondOrder&amp;lt;Pair&amp;gt; something;
      
      //apply to a generic interface
      SecondOrder&amp;lt;List&amp;gt; somethingElse;
      
      //apply to an anonymous type function
      SecondOrder&amp;lt;&amp;lt;Value&amp;gt; =&amp;gt; [Value,Value]&amp;gt; somethingScaryLookin;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;The type constraint &lt;code&gt;given Box&amp;lt;Value&amp;gt;&lt;/code&gt; indicates that the
      type variable &lt;code&gt;Box&lt;/code&gt; accepts type functions with one type
      argument.&lt;/p&gt;
      
      &lt;p&gt;Now, there's one thing to take note of here. At this point,
      the notion that type functions are types is a purely formal
      statement. An axiom that defines what kinds of types I can
      write down and expect the typechecker of my programming
      language to be able to reason about. I have
      not—yet—said that there are any actual &lt;em&gt;values&lt;/em&gt;
      of these types!&lt;/p&gt;
      
      &lt;p&gt;&lt;strong&gt;Jargon watch:&lt;/strong&gt; the ability to treat a type function as a
      type is called &lt;em&gt;higher order generics&lt;/em&gt;.&lt;/p&gt;
      
      &lt;h3&gt;The type of a generic function is a type function&lt;/h3&gt;
      
      &lt;p&gt;Let's come back to our motivating examples:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Any pipe&amp;lt;Any&amp;gt;(Any anything) =&amp;gt; anything;
      
      Number add&amp;lt;Number&amp;gt;(Number x, Number y)
                  given Number satisfies Summable&amp;lt;Number&amp;gt;
              =&amp;gt; x+y;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;If you squint, you'll see that these are actually functions
      with &lt;em&gt;two&lt;/em&gt; parameter lists. The first parameter lists are:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;Any&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;Number&amp;gt; given Number satisfies Summable&amp;lt;Number&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Which both accept a type. The second parameter lists are:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;(Any anything)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;(Number x, Number y)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Therefore, we can view each generic function as a function
      that accepts a type and produces an ordinary value function.
      The resulting functions are of type &lt;code&gt;Any(Any)&lt;/code&gt; and
      &lt;code&gt;Value(Value,Value)&lt;/code&gt; respectively.&lt;/p&gt;
      
      &lt;p&gt;Thus, we could write down the type of our first generic
      function &lt;code&gt;pipe()&lt;/code&gt; like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;Any&amp;gt; =&amp;gt; Any(Any)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And the type of &lt;code&gt;add()&lt;/code&gt; is:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;Number&amp;gt; given Number satisfies Summable&amp;lt;Number&amp;gt;
              =&amp;gt; Number(Number,Number)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Phew. That looks a bit scary. But mainly because of the type
      constraint. Because generic function types like this are
      pretty verbose, we can assign them aliases:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;alias AdditionLikeOperation
              =&amp;gt; &amp;lt;Number&amp;gt; given Number satisfies Summable&amp;lt;Number&amp;gt;
                      =&amp;gt; Number(Number,Number);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or, equivalently, but more simply:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;alias AdditionLikeOperation&amp;lt;Number&amp;gt; 
              given Number satisfies Summable&amp;lt;Number&amp;gt;
                      =&amp;gt; Number(Number,Number);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;That was the hard part—we're almost done.&lt;/p&gt;
      
      &lt;h3&gt;References to generic functions&lt;/h3&gt;
      
      &lt;p&gt;Now we can use these types as the types of references to
      generic functions:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;Any&amp;gt; =&amp;gt; Any(Any) pipeFun = pipe;
      
      AdditionLikeOperation addFun = add;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And we can apply these function references by providing type
      arguments:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;String(String) pipeString = pipeFun&amp;lt;String&amp;gt;;
      Object(Object) pipeObject = pipeFun&amp;lt;Object&amp;gt;;
      
      Float(Float,Float) addFloats = addFun&amp;lt;Float&amp;gt;;
      Integer(Integer,Integer) addInts = addFun&amp;lt;Integer&amp;gt;;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or, alternatively, we can just immediately apply the generic
      function references to &lt;em&gt;value&lt;/em&gt; arguments, and let Ceylon
      infer the type arguments, just as it usually does when you
      call a function directly:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;String hi = pipeFun(&quot;hello&quot;);
      Integer zero = pipeFun(0);
      
      Float three = addFun(1.0, 2.0);
      String helloWorld = addFun(&quot;Hello&quot;, &quot;World&quot;);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And now we've solved the problem posed at the beginning!&lt;/p&gt;
      
      &lt;p&gt;Now for the kicker: the types &lt;code&gt;&amp;lt;Any&amp;gt; =&amp;gt; Any(Any)&lt;/code&gt; and
      &lt;code&gt;AdditionLikeOperation&lt;/code&gt; are both type functions. Indeed, the
      type of &lt;em&gt;any&lt;/em&gt; generic function is a type function of this
      general form:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;TypeParameters&amp;gt; =&amp;gt; ReturnType(ParameterTypes)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Similarly, every type function of this general form is the
      type of some generic function.&lt;/p&gt;
      
      &lt;p&gt;So we've now shown that some type functions are not only
      types, they're the types of values—the values are
      references to generic functions like &lt;code&gt;pipe&lt;/code&gt; and
      &lt;code&gt;add&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;&lt;strong&gt;Jargon watch:&lt;/strong&gt; the ability to treat a generic function as
      a value is called &lt;em&gt;higher rank generics&lt;/em&gt;.&lt;/p&gt;
      
      &lt;h3&gt;Abstraction over generic functions&lt;/h3&gt;
      
      &lt;p&gt;Finally, we can use all this for something useful. Let's
      consider a scanner library that is abstracted away from
      all of:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;the character type,&lt;/li&gt;
      &lt;li&gt;the token type,&lt;/li&gt;
      &lt;li&gt;the kind of container that tokens occur in.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Then we might have a &lt;code&gt;scan()&lt;/code&gt; function with this sort
      of signature:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;&quot;Tokenize a stream of characters, producing
       a stream of tokens.&quot;
      Stream&amp;lt;Token&amp;gt; scan&amp;lt;Char,Token,Stream&amp;gt;
              (grammar, characterStream, newToken, newStream)
                  //Note: Stream is a reference to a type function!
                  given Stream&amp;lt;Element&amp;gt; satisfies {Element*} {
      
          //parameters:
      
          &quot;The token grammar.&quot;
          Grammar grammar;
      
          &quot;The character stream to tokenize.&quot;
          Stream&amp;lt;Char&amp;gt; characterStream;
      
          &quot;Constructor for tokens, accepting a
           substream of characters.&quot;
          Token newToken(Stream&amp;lt;Char&amp;gt; chars);
      
          &quot;Generic function to construct a stream
           of characters or tokens.&quot;
           //Note: newStream is a reference to a generic function!
           Stream&amp;lt;Elem&amp;gt; newStream&amp;lt;Elem&amp;gt;({Elem*} elements);
      
          //implementation:
      
          Stream&amp;lt;Token&amp;gt; tokenStream;
      
          //do all the hard work
          ...
      
          return tokenStream;
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Here:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;Char&lt;/code&gt; is the unknown character type,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;Token&lt;/code&gt; is the unknown token type,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;Stream&lt;/code&gt; is a type function representing an unknown
      container type that can contain either characters or
      tokens,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;newToken&lt;/code&gt; is a function that accepts a substream of
      characters and creates a &lt;code&gt;Token&lt;/code&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;characterStream&lt;/code&gt; is a stream of characters, and, most
      significantly,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;newStream&lt;/code&gt; is a generic function that constructs streams
      of any element type, used internally to create streams of
      characters as well as tokens.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;We could use this function like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;//Let's use String as the token type, Character as the
      //character type, and Iterable as the stream type.
      
      //input a stream of characters
      {Character*} input = ... ;
      
      //and some token grammar
      Grammar grammar = ... ;
      
      //get back a stream of Strings
      {String*} tokens =
              scan&amp;lt;Character, String, Iterable&amp;gt;
                  (grammar, input, String,
                          //Note: a generic anonymous function! 
                          &amp;lt;Elem&amp;gt;({Elem*} elems) =&amp;gt; elems);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;//use LinkedList as the stream type
      import ceylon.collection { LinkedList }
      
      //we don't need Unicode support, so let's use
      //Ceylon's 8-bit Byte as our character type
      alias Char =&amp;gt; Byte;
      
      //define our own token type
      class BasicToken(LinkedList&amp;lt;Char&amp;gt; charList) {
          string =&amp;gt; String { for (b in charList) 
                             b.unsigned.character };
      }
      
      //input a linked list of characters
      LinkedList&amp;lt;Char&amp;gt; input = ... ;
      
      //and some token grammar
      Grammar grammar = ... ;
      
      //get back a linked list of BasicTokens
      LinkedList&amp;lt;BasicToken&amp;gt; tokens =
              scan&amp;lt;Char, BasicToken, LinkedList&amp;gt;
                  (grammar, input, BasicToken,
                          //Note: a generic function ref! 
                          LinkedList);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;As you can see, our parsing algorithm is now almost
      completely abstracted away from the concrete types we want
      to use!&lt;/p&gt;
      
      &lt;h3&gt;Compiling this code&lt;/h3&gt;
      
      &lt;p&gt;In Ceylon 1.2, programming with type functions is an
      experimental feature that only works in conjunction with
      the JavaScript backend. So you can run code that uses type
      functions on a JavaScript virtual machine, but not on the
      JVM. This is something we're inviting you to play with to
      see if the whole community agrees it is useful. But right
      now it's not covered in the language specification, and it's
      not supported by the Java backend.&lt;/p&gt;
      
      &lt;p&gt;The typechecker itself supports &lt;em&gt;extremely&lt;/em&gt; sophisticated
      reasoning about higher order and higher rank types. Type
      functions are fully integrated with Ceylon's powerful
      system of subtype polymorphism, including with union
      and intersection types, and with type inference and type
      argument inference. There's even limited support for type
      function inference! And there's no arbitrary upper limits
      here; not only rank-2 but arbitrary rank types are supported.&lt;/p&gt;
      
      &lt;p&gt;If there's enough interest, I'll cover that material in a
      future post.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/04/19/observable</id>
    <title>Unique approach to observer/observable pattern in Ceylon</title>
    <updated>2015-04-19T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/04/19/observable" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      The essence of the famous observer/observable pattern is that
      you have an observable object that produces events of
      various kinds, and one or more observer objects that register
      themselves as interested in notification when these events
      occur.
      
      Of course, we represent each kind of event as a type, usually
      a class, though nothing prevents us from using an interface
      type as an event type.
      
      For example:
      
      
      
      
      class Started() {}
      class Stopped() {}
      
      
      An event type may even be generic:
      
      
      
      
      class Created&lt;out Entity&gt;
              (shared Entity entity) 
              given Entity satisfies Object {
          string =&gt; "Created[``entity``]";
      }
      
      class Updated&lt;out...
    </summary>
    <content type="html">
      &lt;p&gt;The essence of the famous observer/observable pattern is that
      you have an &lt;em&gt;observable&lt;/em&gt; object that produces &lt;em&gt;events&lt;/em&gt; of
      various kinds, and one or more &lt;em&gt;observer&lt;/em&gt; objects that register
      themselves as interested in notification when these events
      occur.&lt;/p&gt;
      
      &lt;p&gt;Of course, we represent each kind of event as a type, usually
      a class, though nothing prevents us from using an interface
      type as an event type.&lt;/p&gt;
      
      &lt;p&gt;For example:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class Started() {}
      class Stopped() {}
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;An event type may even be generic:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class Created&amp;lt;out Entity&amp;gt;
              (shared Entity entity) 
              given Entity satisfies Object {
          string =&amp;gt; &quot;Created[``entity``]&quot;;
      }
      
      class Updated&amp;lt;out Entity&amp;gt;
              (shared Entity entity) 
              given Entity satisfies Object {
          string =&amp;gt; &quot;Updated[``entity``]&quot;;
      }
      
      class Deleted&amp;lt;out Entity&amp;gt;
              (shared Entity entity) 
              given Entity satisfies Object {
          string =&amp;gt; &quot;Deleted[``entity``]&quot;;
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Of course, we have powerful mechanisms for abstracting over
      event types, for example:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;alias Lifecycle&amp;lt;Entity&amp;gt; 
              given Entity satisfies Object
              =&amp;gt; Created&amp;lt;Entity&amp;gt; |
                 Updated&amp;lt;Entity&amp;gt; |
                 Deleted&amp;lt;Entity&amp;gt;;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;An observer, usually, is in essence nothing more than a
      function that accepts a certain type of event as a parameter.&lt;/p&gt;
      
      &lt;p&gt;For example, this anonymous function observes the creation
      of &lt;code&gt;User&lt;/code&gt;s:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;(Created&amp;lt;User&amp;gt; userCreated) 
              =&amp;gt; print(&quot;new user created: &quot; + userCreated.entity.name)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This anonymous function observes lifecycle events of any
      kind of entity:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;(Lifecycle&amp;lt;Object&amp;gt; event) 
              =&amp;gt; print(&quot;something happened: &quot; + event)
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Union and intersection types give us a nice way to express
      conjunction and disjunction of event types:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;void (Created&amp;lt;User&amp;gt;|Deleted&amp;lt;User&amp;gt; userEvent) {
          switch (userEvent)
          case (is Created&amp;lt;User&amp;gt;) {
              print(&quot;user created: &quot; + userEvent.entity.name);
          }
          case (is Deleted&amp;lt;User&amp;gt;) {
              print(&quot;user deleted: &quot; + userEvent.entity.name);
          }
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now here's where we can do something really cute. Typically,
      in other languages, the observable object provides various
      observer registration operations, one for each kind of event
      the object produces. We're going to define a generic class
      &lt;code&gt;Observable&lt;/code&gt; that works for any event type, and uses reified
      generics to map events to observer functions.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;shared class Observable&amp;lt;in Event&amp;gt;() 
              given Event satisfies Object {
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;The type parameter &lt;code&gt;Event&lt;/code&gt; captures the various kinds of
      events that this object produces, for example, an
      &lt;code&gt;Observable&amp;lt;Lifecycle&amp;lt;User&amp;gt;&amp;gt;&lt;/code&gt; produces events of type
      &lt;code&gt;Created&amp;lt;User&amp;gt;&lt;/code&gt;, &lt;code&gt;Updated&amp;lt;User&amp;gt;&lt;/code&gt;, and &lt;code&gt;Deleted&amp;lt;User&amp;gt;&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;We need a list to store observers in:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;value listeners = ArrayList&amp;lt;Anything(Nothing)&amp;gt;();
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Here, &lt;code&gt;Anything(Nothing)&lt;/code&gt; is the supertype of any function
      with one parameter.&lt;/p&gt;
      
      &lt;p&gt;The &lt;code&gt;addObserver()&lt;/code&gt; method registers an observer function
      with the &lt;code&gt;Observable&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;shared void addObserver&amp;lt;ObservedEvent&amp;gt;
              (void handle(ObservedEvent event))
              given ObservedEvent satisfies Event
              =&amp;gt; listeners.add(handle);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This method only accepts observer functions for some subset
      of the events actually produced by the &lt;code&gt;Observable&lt;/code&gt;. This
      constraint is enforced by the upper bound
      &lt;code&gt;given ObservedEvent satisfies Event&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;The &lt;code&gt;raise()&lt;/code&gt; method produces an event:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;shared void raise&amp;lt;RaisedEvent&amp;gt;(RaisedEvent event)
              given RaisedEvent satisfies Event
              =&amp;gt; listeners.narrow&amp;lt;Anything(RaisedEvent)&amp;gt;()
                  .each((handle) =&amp;gt; handle(event));
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Again, the upper bound enforces that this method only
      accepts event objects that are of an event type produced by
      the &lt;code&gt;Observable&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;This method uses the new &lt;code&gt;narrow()&lt;/code&gt; method of &lt;code&gt;Iterable&lt;/code&gt;
      in Ceylon 1.2 to filter out observer functions that don't
      accept the raised event type. This method is implemented
      using reified generics. Here's its definition in
      &lt;code&gt;Iterable&amp;lt;Element&amp;gt;&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;shared default {Element&amp;amp;Type*} narrow&amp;lt;Type&amp;gt;() 
              =&amp;gt; { for (elem in this) if (is Type elem) elem };
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;That is, if we have a stream of &lt;code&gt;Element&lt;/code&gt;s, and we call
      &lt;code&gt;narrow&amp;lt;Type&amp;gt;()&lt;/code&gt;, explicitly passing an arbitrary type
      &lt;code&gt;Type&lt;/code&gt;, then we get back a stream of all elements of the
      original stream which are instances of &lt;code&gt;Type&lt;/code&gt;. This is,
      naturally, a stream of &lt;code&gt;Element&amp;amp;Type&lt;/code&gt;s.&lt;/p&gt;
      
      &lt;p&gt;Now, finally, if we define an instance of &lt;code&gt;Observable&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;object userPersistence 
              extends Observable&amp;lt;Lifecycle&amp;lt;User&amp;gt;&amp;gt;() {
      
          shared void create(User user) {
              ...
              //raise an event
              raise(Created(user));
          }
      
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Then we can register observers for this object like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;//observe User creation events
      userPersistence.addObserver(
              (Created&amp;lt;User&amp;gt; userCreated) 
              =&amp;gt; print(&quot;new user created: &quot; + userCreated.entity.name));
      
      //observe User creation and deletion events
      userPersistence.addObserver(
              void (Created&amp;lt;User&amp;gt;|Deleted&amp;lt;User&amp;gt; userEvent) {
          switch (userEvent)
          case (is Created&amp;lt;User&amp;gt;) {
              print(&quot;user created: &quot; + userEvent.entity.name);
          }
          case (is Deleted&amp;lt;User&amp;gt;) {
              print(&quot;user deleted: &quot; + userEvent.entity.name);
          }
      });
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Notice how with union and intersection types, subtyping, and
      variance, we find ourselves with a powerful expression
      language for specifying exactly which kinds of events we're
      interested in, in a typesafe way, right in the parameter
      list of the observer function.&lt;/p&gt;
      
      &lt;p&gt;For the record, here's the complete code of &lt;code&gt;Observable&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;shared class Observable&amp;lt;in Event&amp;gt;() 
              given Event satisfies Object {
          value listeners = ArrayList&amp;lt;Anything(Nothing)&amp;gt;();
      
          shared void addObserver&amp;lt;ObservedEvent&amp;gt;
                  (void handle(ObservedEvent event))
                  given ObservedEvent satisfies Event
                  =&amp;gt; listeners.add(handle);
      
          shared void raise&amp;lt;RaisedEvent&amp;gt;(RaisedEvent event)
                  given RaisedEvent satisfies Event
                  =&amp;gt; listeners.narrow&amp;lt;Anything(RaisedEvent)&amp;gt;()
                      .each((handle) =&amp;gt; handle(event));
      
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Finally, a caveat: the precise code above does not compile
      in Ceylon 1.1, because the &lt;code&gt;narrow()&lt;/code&gt; method is new, and
      because of a fixed bug in the typechecker. But it will work
      in the upcoming 1.2 release of Ceylon.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2015/02/10/uk-jug-tour</id>
    <title>UK JUG tour</title>
    <updated>2015-02-10T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2015/02/10/uk-jug-tour" rel="alternate" type="text/html" />
    <author>
      <name>St&#233;phane &#201;pardaud</name>
    </author>
    <summary>
      Tom and Stef are going to tour the UK Java User Groups to talk about Ceylon this week, starting
      with London today, Manchester tomorrow, then Newcastle and Belfast.
      
      Do not miss this if you’re in the UK, check out the details for each date and how to register.
      ...
    </summary>
    <content type="html">
      &lt;p&gt;Tom and Stef are going to tour the UK Java User Groups to talk about Ceylon this week, starting
      with London today, Manchester tomorrow, then Newcastle and Belfast.&lt;/p&gt;
      
      &lt;p&gt;Do not miss this if you’re in the UK, &lt;a href=&quot;https://ceylon-lang.org/community/events/#20150210&quot;&gt;check out the details for each date and how to register&lt;/a&gt;.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2014/12/29/destructuring</id>
    <title>Tuple and entry destructuring</title>
    <updated>2014-12-29T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2014/12/29/destructuring" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      The next release of Ceylon features an interesting range of
      new language features, including constructors, if and
      switch expression, let and object expressions, and
      destructuring of tuples and entries. In this post, I'm
      going to describe our new syntax for destructuring.
      
      A destructuring statement looks a lot like a normal value
      declaration, except that where we would expect to see the
      value name, a pattern occurs instead.
      
      An entry pattern is indicated using the skinny arrow -&gt;
      we use to construct entries:
      
      
      
      
      String-&gt;Integer entry = "one"-&gt;1;
      value key-&gt;item = entry;    //destructure the Entry
      
      
      A tuple pattern is indicated with brackets:
      
      
      
      
      [String,Integer] pair = ["one",1];
      value [first,second] = pair;   ...
    </summary>
    <content type="html">
      &lt;p&gt;The next release of Ceylon features an interesting range of
      new language features, including constructors, &lt;code&gt;if&lt;/code&gt; and
      &lt;code&gt;switch&lt;/code&gt; expression, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; expressions, and
      &lt;em&gt;destructuring&lt;/em&gt; of tuples and entries. In this post, I'm
      going to describe our new syntax for destructuring.&lt;/p&gt;
      
      &lt;p&gt;A destructuring statement looks a lot like a normal value
      declaration, except that where we would expect to see the
      value name, a &lt;em&gt;pattern&lt;/em&gt; occurs instead.&lt;/p&gt;
      
      &lt;p&gt;An &lt;em&gt;entry&lt;/em&gt; pattern is indicated using the skinny arrow &lt;code&gt;-&amp;gt;&lt;/code&gt;
      we use to construct entries:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;String-&amp;gt;Integer entry = &quot;one&quot;-&amp;gt;1;
      value key-&amp;gt;item = entry;    //destructure the Entry
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;A &lt;em&gt;tuple pattern&lt;/em&gt; is indicated with brackets:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;[String,Integer] pair = [&quot;one&quot;,1];
      value [first,second] = pair;    //destructure the Tuple
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;The &lt;em&gt;pattern variables&lt;/em&gt;, &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;item&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt;
      are just regular local values.&lt;/p&gt;
      
      &lt;p&gt;We can nest tuple and entry patterns:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;String-&amp;gt;[String,Integer] entry = &quot;one&quot;-&amp;gt;[&quot;one&quot;,1];
      value key-&amp;gt;[first,second] = entry;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;A tuple pattern may have a tail variable, indicated with a
      &lt;code&gt;*&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;[String+] ints = 1..100;
      value [first,*rest] = ints;    //destructure the Sequence
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;(This syntax resembles the spread operator.)&lt;/p&gt;
      
      &lt;p&gt;Patterns may optionally indicate an explicit type:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;value String key-&amp;gt;[String first, Integer second] = entry;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Pattern-based destructuring can occur in a number of other
      places in the language. A pattern can occur in a &lt;code&gt;for&lt;/code&gt; loop:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;for ([x, y] in points) { ... }
      
      for (key-&amp;gt;item in map) { ... }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or in an &lt;code&gt;exists&lt;/code&gt; or &lt;code&gt;nonempty&lt;/code&gt; condition:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;if (exists index-&amp;gt;item = stream.indexed.first) { ... }
      
      if (nonempty [first,*rest] = sequence) { ... }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or in a &lt;code&gt;let&lt;/code&gt; expression:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;value dist = let ([x,y] = point) sqrt(x^2+y^2);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;You might wonder why we decided to introduce this syntax, or
      at least, why we decided to do it &lt;em&gt;now&lt;/em&gt;. Well, I suppose the
      simple answer is that it always felt a bit incomplete or
      unfinished to have a language with tuples but no convenient
      destructuring syntax for them. Especially when we did already
      have destructuring for entries, but only in &lt;code&gt;for&lt;/code&gt;, as a
      special case.&lt;/p&gt;
      
      &lt;p&gt;But looking into the future, you could also choose to see
      this as us dipping our toes in the water of eventual support
      for &lt;em&gt;pattern matching&lt;/em&gt;. I remain ambivalent about pattern
      matching, and it's certainly not something we find that the
      language is missing or needs, but lots of folks tell us they
      like it in other languages, so we're keeping our options
      open. Fortunately, the syntax described above will scale
      nicely to more complex patterns in a full pattern matching
      facility.&lt;/p&gt;
      
      &lt;p&gt;This functionality is already implemented and available in
      github.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2014/12/01/version-ranges</id>
    <title>Useless lying version ranges</title>
    <updated>2014-12-01T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2014/12/01/version-ranges" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      A frequent request from the Ceylon community is support for
      version ranges in expressing module dependencies. There's no
      doubt that our current module system is too inflexible in
      terms of dependency resolution in the face of version
      conflicts, and I have some reasonable ideas about how to
      address that problem without needing version ranges. But I
      would like to document precisely why I think version ranges
      are strictly-speaking useless at best, and harmful at worst.
      
      First, a philosophical point: version ranges encourage module
      authors to make untested or untestable claims about their
      modules, such as:
      
      my.module is compatible with  other.dependency
      version 2.x.
      
      Yeah, right, 'cos you've actually tested my.module with
      every single minor...
    </summary>
    <content type="html">
      &lt;p&gt;A frequent request from the Ceylon community is support for
      version ranges in expressing module dependencies. There's no
      doubt that our current module system is too inflexible in
      terms of dependency resolution in the face of version
      conflicts, and I have some reasonable ideas about how to
      address that problem without needing version ranges. But I
      would like to document precisely why I think version ranges
      are strictly-speaking useless at best, and harmful at worst.&lt;/p&gt;
      
      &lt;p&gt;First, a philosophical point: version ranges encourage module
      authors to make untested or untestable claims about their
      modules, such as:&lt;/p&gt;
      
      &lt;blockquote&gt;&lt;p&gt;&lt;code&gt;my.module&lt;/code&gt; is compatible with  &lt;code&gt;other.dependency&lt;/code&gt;
      version 2.x.&lt;/p&gt;&lt;/blockquote&gt;
      
      &lt;p&gt;Yeah, right, 'cos you've &lt;em&gt;actually tested&lt;/em&gt; &lt;code&gt;my.module&lt;/code&gt; with
      every single minor version and point release of
      &lt;code&gt;other.dependency&lt;/code&gt;, including all the versions that have not
      even been released yet! Sorry, but I simply don't believe
      you and I have to assume you're lying to me. &lt;em&gt;Almost nobody&lt;/em&gt;
      tests their program or library with many different versions
      of its dependencies, and it's easy to see why they don't: as
      soon as we have a program with several dependencies, we face
      a factorial explosion of dependency version combinations.&lt;/p&gt;
      
      &lt;p&gt;OK, sure, you might argue, but version ranges are still
      &lt;em&gt;better than nothing&lt;/em&gt;. Alright, alright. I'm not the kind of
      guy who much buys into the notion that something broken is
      better than nothing, but I realize I'm in the minority on
      that one, 'cos, y'know, &lt;em&gt;worse is better&lt;/em&gt;, as the neckbeards
      keep telling me.&lt;/p&gt;
      
      &lt;p&gt;So let's see what we could do to make the most of version
      ranges. Let's consider the problem first from the point of
      view of two library authors assigning version ranges to their
      modules, and then from the point of view of the program or
      person assembling these modules.&lt;/p&gt;
      
      &lt;p&gt;Let's suppose my library &lt;code&gt;x.y&lt;/code&gt; depends on &lt;code&gt;org.hibernate&lt;/code&gt;. I
      tested and released &lt;code&gt;x.y&lt;/code&gt; with the then-current version of
      &lt;code&gt;org.hibernate&lt;/code&gt;, which was &lt;code&gt;4.1.3&lt;/code&gt;. What version range would
      I have chosen when declaring this dependency?&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Well, for the lower bound I decided to lie and write
      &lt;code&gt;4.1.0&lt;/code&gt;. Typically, I hadn't actually &lt;em&gt;tested&lt;/em&gt; &lt;code&gt;x.y&lt;/code&gt; with
      versions &lt;code&gt;4.1.0&lt;/code&gt;, &lt;code&gt;4.1.1&lt;/code&gt; and &lt;code&gt;4.1.2&lt;/code&gt;, but I had been
      using &lt;code&gt;4.1.2&lt;/code&gt; in development at one stage and it seemed to
      work, and I didn't see any particular reason it wouldn't
      also work with &lt;code&gt;4.1.0&lt;/code&gt; and &lt;code&gt;4.1.1&lt;/code&gt;. On the other hand,
      maybe I could have just picked &lt;code&gt;4.1.3&lt;/code&gt;. (It's not going to
      matter for the rest of this argument.)&lt;/li&gt;
      &lt;li&gt;For the upper bound, I had no clue. How could I possibly
      have known at the time which future unreleased version of
      &lt;code&gt;org.hibernate&lt;/code&gt; would break my library? Assigning the
      upper bound of &lt;code&gt;4.1.3&lt;/code&gt; would have seemed much too
      restrictive, so what I did was assume that &lt;code&gt;org.hibernate&lt;/code&gt;
      is following the completely untestable
      &lt;a href=&quot;http://semver.org/&quot;&gt;semantic versioning&lt;/a&gt; standard, and
      that future versions of Hibernate 4.x would not have any
      bugs.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Thus, I arrived at the version range &lt;code&gt;4.[1.0-]&lt;/code&gt; using some
      imaginary syntax I just pulled out of my ahem, excuse me,
      invented for the sake of argument.&lt;/p&gt;
      
      &lt;p&gt;A critical thing to notice here is that, from the point of
      view of the library authors, there is &lt;em&gt;no reasonable way to
      determine an accurate upper bound to the version range&lt;/em&gt;.
      This is utterly typical and normal and is the case for
      almost any library author!&lt;/p&gt;
      
      &lt;p&gt;Now, sometime later, you released your library &lt;code&gt;a.b&lt;/code&gt;, which
      also depends on &lt;code&gt;org.hibernate&lt;/code&gt;. At this point, the current
      release of &lt;code&gt;org.hibernate&lt;/code&gt; was &lt;code&gt;4.2.0&lt;/code&gt;. Quite atypically,
      you actually &lt;em&gt;do&lt;/em&gt; test your library with a previous version
      of its dependency, and so you know that it is actually
      compatible with &lt;code&gt;4.1.5&lt;/code&gt; (the latest release of &lt;code&gt;4.1.x&lt;/code&gt;).
      Thus, you arrive at the version range &lt;code&gt;4.[1.5-]&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Now suppose some poor soul wants to use both our libraries
      together in their program, thus taking advantage of the bugs
      in both of them. So now, when assembling the program, what
      version of  &lt;code&gt;org.hibernate&lt;/code&gt; should the module system choose.
      Let's consider the reasonable options:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Pick the latest release that fits the version ranges, that
      is, the latest release of 4.x. This approach means that a
      new release of &lt;code&gt;org.hibernate&lt;/code&gt; can break our application.
      We're picking a release which hasn't been tested with
      either &lt;code&gt;x.y&lt;/code&gt; or &lt;code&gt;a.b&lt;/code&gt;. Not acceptable.&lt;/li&gt;
      &lt;li&gt;Pick the earliest release that fits the version ranges, in
      this case &lt;code&gt;4.1.5&lt;/code&gt;. This is better. At least there's a
      chance that one of the libraries (in this case, &lt;code&gt;a.b&lt;/code&gt;) has
      actually been tested with this version. Still, according
      to this strategy the system could in general pick a
      dependency version that's earlier than all the current
      versions when the libraries were developed. That seems
      quite suboptimal.&lt;/li&gt;
      &lt;li&gt;Pick 4.2.0, since that was the current version of
      &lt;code&gt;org.hibernate&lt;/code&gt; when one of the libraries was developed,
      so we &lt;em&gt;know for a fact&lt;/em&gt; that it works with at least one of
      the libraries, and it's newer that the version that the
      other library was developed with. This seems to me like
      it's by far the most robust and natural strategy.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;There are some variations on this scenario, which raise
      other possible choices, and I'm going to let you experiment
      with the variations yourself, and see how it affects the
      conclusion. But as far as I can tell, there's essentially
      no common scenario in which the third strategy isn't at
      least as good as any other possible strategy.&lt;/p&gt;
      
      &lt;p&gt;And now note that this third strategy doesn't actually use
      version ranges at all! We can write down this strategy
      without reference to version ranges. It just says: pick the
      latest version of the dependency among the versions with
      which the libraries were developed. Version ranges don't
      really add any useful additional information to that,
      especially in light of the fact that upper bounds are
      essentially impossible to determine, and even lower bounds
      often lie. Why inject additional inaccurate information into
      the mix when we already have an algorithm that produces a
      result without depending on guesses and lies and
      unverifiable assumptions? (I apologize for going all logical
      positivist on your arse.)&lt;/p&gt;
      
      &lt;p&gt;What do you think? Am I wrong? Is there some reasonably
      common scenario where the module system can be expected to
      produce a better outcome with the addition of version range
      information? Is there a scenario in which upper bound
      information &lt;em&gt;doesn't&lt;/em&gt; lie? Is there a strategy involving
      version ranges that is unambiguously better than my
      admittedly unsophisticated &quot;pick the latest version&quot;
      approach?&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2014/11/03/plan</id>
    <title>New features coming soon</title>
    <updated>2014-11-03T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2014/11/03/plan" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      We've been spending time discussing the priorities for development
      of Ceylon 1.1.5 and 1.2, including soliciting
      community feedback. The plan is still
      suprisingly fluid right now, but there are a number of things that
      we've already started working on, or have decided to start working
      on, and so in the interest of transparency, I thought I would share
      them.
      
      Warning: we're not committing to a timeframe or release version for
      most of these features. It's merely a summary of what we're working
      on now, or plan to start work on soon.
      
      Serialization
      
      As already announced, ceylon.language 1.1.5 will feature an API for
      Serialization.
      Note that this API does not itself specify a serialization...
    </summary>
    <content type="html">
      &lt;p&gt;We've been spending time discussing the priorities for development
      of Ceylon 1.1.5 and 1.2, including soliciting
      &lt;a href=&quot;https://ceylon-lang.org/blog/2014/10/19/plan/&quot;&gt;community feedback&lt;/a&gt;. The plan is still
      suprisingly fluid right now, but there are a number of things that
      we've already started working on, or have decided to start working
      on, and so in the interest of transparency, I thought I would share
      them.&lt;/p&gt;
      
      &lt;p&gt;&lt;em&gt;Warning:&lt;/em&gt; we're not committing to a timeframe or release version for
      most of these features. It's merely a summary of what we're working
      on now, or plan to start work on soon.&lt;/p&gt;
      
      &lt;h2&gt;Serialization&lt;/h2&gt;
      
      &lt;p&gt;As already announced, &lt;code&gt;ceylon.language&lt;/code&gt; 1.1.5 will feature an API for
      &lt;a href=&quot;https://github.com/ceylon/ceylon-spec/issues/704&quot;&gt;Serialization&lt;/a&gt;.
      Note that this API does not itself specify a serialization format.
      Rather, it's a general-purpose and platform-neutral facility for
      marshalling objects to and from a serialized stream. Serialization
      libraries founded on this API may serialize to text-based formats
      like JSON or XML, to binary formats, or even to a database via ORM.&lt;/p&gt;
      
      &lt;p&gt;Work on this API is already well-advanced. Tom has already done the
      Java implementation, and Enrique has got it working in JavaScript.&lt;/p&gt;
      
      &lt;h2&gt;Type argument inference for function references&lt;/h2&gt;
      
      &lt;p&gt;In Ceylon 1.1, we made it possible to leave off the type of a
      parameter of an anonymous function that occurs in an argument list,
      letting the type be inferred by the compiler, for example:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;{Float*} measurements = ... ;
      Float product = measurements.fold(1.0)((x,y)=&amp;gt;x*y);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;In Ceylon 1.1.5, I've extended this approach to cover references
      to generic functions. So now, instead of this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;{Float*} measurements = ... ;
      Float product = measurements.fold(1.0)(times&amp;lt;Float&amp;gt;);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;You can write this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;{Float*} measurements = ... ;
      Float product = measurements.fold(1.0)(times);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This even works for static value references, so instead of this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;{[Float+]*} sequences = ... ;
      {Float*} heads = sequences.map(Iterable&amp;lt;Float&amp;gt;.first);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;You can write simply this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;{[Float+]*} sequences = ... ;
      {Float*} heads = sequences.map(Iterable.first);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;This is already implemented, and you can try it out in git. It will
      be released in Ceylon 1.1.5.&lt;/p&gt;
      
      &lt;h2&gt;Named constructors&lt;/h2&gt;
      
      &lt;p&gt;In Ceylon 1.1, there is only one &quot;constructor&quot; of a class, the body
      of the class itself. For the vast majority of classes this is far
      more elegant and convenient. But in a minority of cases, there is
      a true need to have multiple initialization paths, and so we've
      designed a &lt;code&gt;new&lt;/code&gt; syntax to support that. It took us a while to come
      up with something elegant and regular that didn't break the block
      structure of the language or the rules about definite initialization,
      but I'm very happy with the final outcome.&lt;/p&gt;
      
      &lt;p&gt;Since Ceylon doesn't have overloading (except for Java interop),
      constructors have distinct names.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class Point {
          shared Float x;
          shared Float y;
      
          //the &quot;default&quot; constructor
          shared new Point(Float x, Float y) {
              this.x = x;
              this.y = y;
          }
      
          //an additional constructor
          shared new Diagonal(Float d) {
              x = (d^2/2)^0.5 * d.sign;
              y = x;
          }
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Every constructor must initialize all members which are left
      uninitialized by the body of the class, and must delegate to a
      constructor of the superclass (in this case, they delegate to
      &lt;code&gt;Basic()&lt;/code&gt; by default). Now we can create a &lt;code&gt;Point&lt;/code&gt; in two
      different ways:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Point p1 = Point(2.0, 3.0);  //call the default constructor
      Point p2 = Point.Diagonal(1.0);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;The typechecker already supports constructors, and Tom has made
      good progress on implementing this feature for the Java backend.
      I'm not sure if this will make it into 1.1.5, but if it does
      then we might actually need to rename 1.1.5 to 1.2, given that
      this is a pretty significant enhancement to the language itself.&lt;/p&gt;
      
      &lt;h2&gt;Extensions to the expression syntax&lt;/h2&gt;
      
      &lt;p&gt;We're making several extensions to the expression syntax. These
      features are already supported in the typechecker, but not yet
      by the backends. Note that these features are especially useful
      when combined with certain other features of the language, like
      comprehensions, anonymous functions, named argument lists, and
      fat arrow function definitions.&lt;/p&gt;
      
      &lt;h3&gt;Inline &lt;code&gt;object&lt;/code&gt; expressions&lt;/h3&gt;
      
      &lt;p&gt;An &lt;a href=&quot;https://github.com/ceylon/ceylon-spec/issues/333&quot;&gt;inline anonymous &lt;code&gt;object&lt;/code&gt; expression&lt;/a&gt;
      is very similar to an anonymous class in Java, and is useful in
      essentially the same cases. For example:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;printAll(object satisfies {Integer+} {
          iterator() =&amp;gt;
              object satisfies Iterator&amp;lt;Integer&amp;gt; {
                  variable value current = 0;
                  next() =&amp;gt; current++;
              };
      });
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h3&gt;
      &lt;code&gt;let&lt;/code&gt; expressions&lt;/h3&gt;
      
      &lt;p&gt;A &lt;a href=&quot;https://github.com/ceylon/ceylon-spec/issues/747&quot;&gt;&lt;code&gt;let&lt;/code&gt; expression&lt;/a&gt;
      allows the definition of new &lt;code&gt;value&lt;/code&gt;s within an expression. For
      example:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Float d = ... ;
      value ptl = let (x = (d^2/2)^0.5 * d.sign) Point(x,x);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h3&gt;Inline &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;switch&lt;/code&gt; expressions&lt;/h3&gt;
      
      &lt;p&gt;Ceylon's &lt;code&gt;then&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; operators are nice, but they don't
      do anything special in terms of flow-sensitive typing, so we
      quite often run into cases where we're forced to use a whole
      &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;switch&lt;/code&gt; statement in a block. To alleviate that minor
      source of discomfort, we're now going to let you use
      &lt;a href=&quot;https://github.com/ceylon/ceylon-spec/issues/503&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; and
      &lt;a href=&quot;https://github.com/ceylon/ceylon-spec/issues/556&quot;&gt;&lt;code&gt;switch&lt;/code&gt;&lt;/a&gt;
      within expressions. For example:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;String string(Object it)
              =&amp;gt; if (is Person it) 
                 then it.name 
                 else it.string;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Or:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;String name(Person|Org it)
              =&amp;gt; switch (it) 
                 case (is Org) it.tradingName 
                 case (is Person) it.firstName + &quot; &quot; + it.lastName;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h2&gt;Cayla web framework&lt;/h2&gt;
      
      &lt;p&gt;Frameworks for developing web applications are a top request from
      the community. After some discussion, we've decided to focus first
      on the &lt;em&gt;server side&lt;/em&gt;, and come back later to the problem of
      client-side web frameworks. Note that there's no problem at all
      with using a native JS client-side web framework to call a Ceylon
      module compiled to JavaScript.&lt;/p&gt;
      
      &lt;p&gt;Julien is going to work on getting
      &lt;a href=&quot;https://github.com/vietj/ceylon-cayla&quot;&gt;Cayla&lt;/a&gt;, a web framework
      for use on Vert.x, ready for release.&lt;/p&gt;
      
      &lt;p&gt;To showcase Cayla, Ceylon, and Vert.x, Julien is going to do a
      partial port of Ceylon Herd from Java/Play to Ceylon/Cayla. That
      should make for a great demo.&lt;/p&gt;
      
      &lt;h2&gt;SDK modules &lt;code&gt;ceylon.html&lt;/code&gt; and &lt;code&gt;ceylon.promise&lt;/code&gt;
      &lt;/h2&gt;
      
      &lt;p&gt;Cayla will offer a choice of templating technologies, but one of
      the options we obviously want to offer is templates written in
      Ceylon. In order to avoid the cost of rebuilding the template
      from scratch on each request, &lt;code&gt;ceylon.html&lt;/code&gt; needs to be enhanced
      to support a mix of static nodes and nodes which are created or
      rendered dynamically.&lt;/p&gt;
      
      &lt;p&gt;Work on Cayla will also likely necessitate improvements to
      &lt;code&gt;ceylon.promise&lt;/code&gt;, and, in particular, we need to make this
      module cross-platform (right now it is only available on the
      JVM).&lt;/p&gt;
      
      &lt;h2&gt;Java EE integration&lt;/h2&gt;
      
      &lt;p&gt;Toby Crawley has started work on integration with Java EE. The
      first order of business here is to make it easy to write a
      servlet in Ceylon and package it into a &lt;code&gt;war&lt;/code&gt; archive. After
      that, we'll need to make sure Ceylon works well with CDI, JPA,
      JAX-RS, etc.&lt;/p&gt;
      
      &lt;h2&gt;Improved debugging in Ceylon IDE&lt;/h2&gt;
      
      &lt;p&gt;David is going to work on making Eclipse's debugger work better
      with Ceylon. This is now the only really major feature missing
      from Ceylon IDE, so when he's done with that, he's going to move
      onto the #1 requested feature from the Ceylon community, which
      is...&lt;/p&gt;
      
      &lt;h2&gt;IntelliJ-based IDE for Ceylon&lt;/h2&gt;
      
      &lt;p&gt;The IntelliJ plugin for Ceylon is still rudimentary, and not yet
      ready for release. But now that the Eclipse-based IDE is feature
      complete, we're going to refocus our tooling development efforts
      on IntelliJ.&lt;/p&gt;
      
      &lt;p&gt;Note that this doesn't really represent a change of direction
      for us; I'm an Eclipse user, I prefer Eclipse, and I see no good
      reason to change to IntelliJ. That's especially true since
      whenever I discover a nice feature of IntelliJ, I just go ahead
      and reimplement it in Ceylon IDE ;-) However, we recognize that
      there are plenty of folks on the other side of the fence, who,
      preferring IntelliJ, and likewise seeing no reason to change,
      deserve a great plugin for Ceylon. So I hereby promise that we
      will have absolutely awesome tooling for &lt;em&gt;both&lt;/em&gt; these IDEs.&lt;/p&gt;
      
      &lt;h2&gt;Source maps&lt;/h2&gt;
      
      &lt;p&gt;To make it easy to debug Ceylon code running on a JavaScript
      virtual machine, Enrique is going to add support for source maps
      to &lt;code&gt;ceylon compile-js&lt;/code&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Consume Typescript interface definitions&lt;/h2&gt;
      
      &lt;p&gt;Microsoft's Typescript project (which recently took inspiration
      from Ceylon by adopting our approach to union types and flow
      sensitive typing) has put a whole lot of work into defining
      statically typed definitions of important APIs in the JavaScript
      world. Now that Ceylon 1.1 has &lt;a href=&quot;https://ceylon-lang.org/blog/2014/10/13/dynamic-interfaces&quot;&gt;dynamic interfaces&lt;/a&gt;
      it's at least in principle possible to have a well-defined
      transformation from a Typescript API definition to a Ceylon type.
      This could take the form of a mechanical source translator, or
      even a &quot;model loader&quot; for the Ceylon compiler. Stef is going to
      investigate this.&lt;/p&gt;
      
      &lt;h2&gt;More&lt;/h2&gt;
      
      &lt;p&gt;The above is an incomplete list. If the thing you're waiting for
      (Android!!) isn't on that list, that doesn't mean we don't want
      to work on it, it just means I don't yet have a concrete plan for
      actually starting work on it right now. Feel very welcome to bug
      us about it in comments or on the mailing list or IRC :-)&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2014/10/28/cli-plugins</id>
    <title>Ceylon command-line plugins</title>
    <updated>2014-10-28T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2014/10/28/cli-plugins" rel="alternate" type="text/html" />
    <author>
      <name>St&#233;phane &#201;pardaud</name>
    </author>
    <summary>
      With Ceylon we try our best to make every developer’s life easier. We do this with a great
      language, a powerful IDE,
      a wonderful online module repository,
      but also with an amazing command-line interface (CLI).
      
      Our command line is built around the idea of discoverability where you get a single executable called
      ceylon and lots of subcommands that you can discover via --help or completion. We have a number
      of predefined subcommands, but
      every so often, we want to be able to write new subcommands.
      
      For example, I want to be able to invoke both Java and JavaScript compilers and generate the API documentation
      in a single command ceylon...
    </summary>
    <content type="html">
      &lt;p&gt;With Ceylon we try our best to make every developer’s life easier. We do this with a great
      language, &lt;a href=&quot;https://ceylon-lang.org/documentation/1.1/ide/&quot;&gt;a powerful IDE&lt;/a&gt;,
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.1/reference/repository/modules.ceylon-lang.org/&quot;&gt;a wonderful online module repository&lt;/a&gt;,
      but also with an amazing &lt;a href=&quot;https://ceylon-lang.org/documentation/1.1/reference/tool/ceylon/&quot;&gt;command-line interface (CLI)&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;Our command line is built around the idea of &lt;em&gt;discoverability&lt;/em&gt; where you get a single executable called
      &lt;code&gt;ceylon&lt;/code&gt; and lots of subcommands that you can discover via &lt;code&gt;--help&lt;/code&gt; or completion. We have a number
      of &lt;a href=&quot;https://ceylon-lang.org/documentation/current/reference/tool/ceylon/subcommands/index.html&quot;&gt;predefined subcommands&lt;/a&gt;, but
      every so often, we want to be able to write new subcommands.&lt;/p&gt;
      
      &lt;p&gt;For example, I want to be able to invoke both Java and JavaScript compilers and generate the API documentation
      in a single command &lt;code&gt;ceylon all&lt;/code&gt;, or I want to be able to invoke the
      &lt;a href=&quot;https://herd.ceylon-lang.org/modules/ceylon.formatter&quot;&gt;&lt;code&gt;ceylon.formatter&lt;/code&gt;&lt;/a&gt; module with
      &lt;code&gt;ceylon format&lt;/code&gt; instead of &lt;code&gt;ceylon run ceylon.formatter&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Well, with Ceylon 1.1 we now &lt;a href=&quot;https://ceylon-lang.org/documentation/1.1/reference/tool/plugin/&quot;&gt;support custom subcommands&lt;/a&gt;,
      fashioned after the &lt;code&gt;git&lt;/code&gt; plugin system. They’re easy to write: just place them in &lt;code&gt;script/your/module/ceylon-foo&lt;/code&gt;
      and package them with &lt;code&gt;ceylon plugin pack your.module&lt;/code&gt;, and you can publish them to Herd.&lt;/p&gt;
      
      &lt;p&gt;Now every one can install your CLI plugin with &lt;code&gt;ceylon plugin install your.module/1.0&lt;/code&gt; and call them with
      &lt;code&gt;ceylon foo&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;What’s even better is that they will be listed in the &lt;code&gt;ceylon --help&lt;/code&gt; and even work with autocompletion.&lt;/p&gt;
      
      &lt;p&gt;&lt;code&gt;ceylon.formatter&lt;/code&gt; uses one, and I encourage you to install them with &lt;code&gt;ceylon plugin install ceylon.formatter/1.1.0&lt;/code&gt;
      and format your code at will with &lt;code&gt;ceylon format&lt;/code&gt; :)&lt;/p&gt;
      
      &lt;p&gt;&lt;code&gt;ceylon.build.engine&lt;/code&gt; also defines one and it just feels great being able to build your Ceylon project with
      &lt;code&gt;ceylon build compile&lt;/code&gt;, I have to say. Although, unfortunately that particular module has not yet been
      published to Herd yet, but hopefully it will be pushed soon.&lt;/p&gt;
      
      &lt;p&gt;You can find out &lt;a href=&quot;https://ceylon-lang.org/documentation/1.1/reference/tool/plugin/&quot;&gt;all about them in our reference&lt;/a&gt;.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2014/10/19/plan</id>
    <title>Planning the future of Ceylon 1.x</title>
    <updated>2014-10-19T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2014/10/19/plan" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      With the release of Ceylon 1.1, we've
      reached a point where we need to do some serious thinking about what
      are our priorities for the development of Ceylon 1.1.5, 1.2, and
      beyond. I definitely don't yet have a crystal clear vision of what is
      going to be in 1.2, so we're also looking for community feedback on
      this.
      
      I do know of one item which is the top priority right now, and will
      be the main feature of Ceylon 1.1.5:
      
      
      Serialization.
      
      
      
      This was a feature that slipped from Ceylon 1.0, and which again
      narrowly missed out on inclusion in Ceylon 1.1. The concept behind
      serialization in Ceylon is to have an...
    </summary>
    <content type="html">
      &lt;p&gt;With the release of &lt;a href=&quot;https://ceylon-lang.org/blog/2014/10/09/ceylon-1/&quot;&gt;Ceylon 1.1&lt;/a&gt;, we've
      reached a point where we need to do some serious thinking about what
      are our priorities for the development of Ceylon 1.1.5, 1.2, and
      beyond. I definitely don't yet have a crystal clear vision of what is
      going to be in 1.2, so we're also looking for community feedback on
      this.&lt;/p&gt;
      
      &lt;p&gt;I &lt;em&gt;do&lt;/em&gt; know of one item which is the top priority right now, and will
      be the main feature of Ceylon 1.1.5:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/ceylon/ceylon-spec/issues/704&quot;&gt;Serialization&lt;/a&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;This was a feature that slipped from Ceylon 1.0, and which again
      narrowly missed out on inclusion in Ceylon 1.1. The concept behind
      serialization in Ceylon is to have an API responsible for assembling
      and disassembling objects that is agnostic as to the actual format of
      the serialized stream. Of course, this API also has to be platform
      neutral, in order to allow serialization between programs running on
      the JVM and programs running on a JavaScript VM. Tom Bentley already
      has a working prototype implementation. Once this feature is done,
      we can start working on serialization libraries supporting JSON and
      whatever else.&lt;/p&gt;
      
      &lt;p&gt;I also count the following as a high priority areas of work:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Java EE integration, and support for technologies like JPA and CDI.&lt;/li&gt;
      &lt;li&gt;Adding &lt;a href=&quot;https://github.com/ceylon/ceylon-spec/issues/685&quot;&gt;properties&lt;/a&gt;
      to the language, that is, a new syntax for attribute references,
      allowing easy MVC UI bindings.&lt;/li&gt;
      &lt;li&gt;Improving the Cayla web framework, and &lt;code&gt;ceylon.html&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Beyond that, we're not sure where else we should concentrate development
      effort. Here are some things that stick out to me:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Addition of named
      &lt;a href=&quot;https://github.com/ceylon/ceylon-spec/issues/796&quot;&gt;constructors&lt;/a&gt;,
      allowing multiple ways to instantiate and initialize a class.&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/ceylon/ceylon-compiler/issues/1865&quot;&gt;AST transformers&lt;/a&gt;—a
      system of compiler plugins, based around &lt;code&gt;ceylon.ast&lt;/code&gt;, enabling
      advanced compile-time metaprogramming, which would form the foundation
      for LINQ-style queries, interceptors and proxies, and autogeneration
      of &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, and &lt;code&gt;string&lt;/code&gt;, and more.&lt;/li&gt;
      &lt;li&gt;Addition of a syntax for expressing
      &lt;a href=&quot;https://github.com/ceylon/ceylon-spec/issues/902&quot;&gt;patterns in BNF&lt;/a&gt;.&lt;/li&gt;
      &lt;li&gt;The Ceylon plugin for IntelliJ IDEA.&lt;/li&gt;
      &lt;li&gt;Android support.&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/ceylon/ceylon-spec/issues/667&quot;&gt;Assemblies&lt;/a&gt;—a
      facility for packaging multiple modules into a deployable
      &quot;application&quot;.&lt;/li&gt;
      &lt;li&gt;New platform modules defining &lt;code&gt;dynamic&lt;/code&gt; interfaces for typesafe
      interaction with JavaScript APIs such as the DOM, jQuery, etc.&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/ceylon/ceylon-compiler/issues/1859&quot;&gt;Interoperation with dynamic languages on the
      JVM&lt;/a&gt;, via
      Ceylon's &lt;code&gt;dynamic&lt;/code&gt; blocks and &lt;code&gt;dynamic&lt;/code&gt; interfaces.&lt;/li&gt;
      &lt;li&gt;Enabling the use of Ceylon for
      &lt;a href=&quot;https://github.com/ceylon/ceylon-spec/issues/200&quot;&gt;scripting&lt;/a&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;We can't do all of this in Ceylon 1.2. Therefore, we're looking for
      feedback from the community. Let us know, here in comments, or &lt;a href=&quot;https://groups.google.com/forum/?utm_medium=email&amp;amp;utm_source=footer#!topic/ceylon-users/hl0lZXTn_eY&quot;&gt;on
      the mailing list&lt;/a&gt;,
      what you feel is missing from Ceylon, either from the above list, or
      whatever else you think is important.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2014/10/13/dynamic-interfaces</id>
    <title>Typesafe APIs for the browser</title>
    <updated>2014-10-13T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2014/10/13/dynamic-interfaces" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      A new feature in Ceylon 1.1, that I've not blogged about before, is
      dynamic interfaces. This was something that Enrique and I worked
      on together with Corbin Uselton, one of our GSoC students.
      
      Ordinarily, when we interact with JavaScript objects, we do it from
      within a dynamic block, where Ceylon's usual scrupulous typechecking
      is suppressed. The problem with this approach is that if it's an API
      I use regularly, my IDE can't help me get remember the names and
      signatures of all the operations of the API.
      
      Dynamic interfaces make it possible to ascribe static types to an
      untyped JavaScript API. For example, we could write a dynamic
      interface for...
    </summary>
    <content type="html">
      &lt;p&gt;A new feature in Ceylon 1.1, that I've not blogged about before, is
      &lt;em&gt;dynamic interfaces&lt;/em&gt;. This was something that Enrique and I worked
      on together with Corbin Uselton, one of our GSoC students.&lt;/p&gt;
      
      &lt;p&gt;Ordinarily, when we interact with JavaScript objects, we do it from
      within a &lt;code&gt;dynamic&lt;/code&gt; block, where Ceylon's usual scrupulous typechecking
      is suppressed. The problem with this approach is that if it's an API
      I use regularly, my IDE can't help me get remember the names and
      signatures of all the operations of the API.&lt;/p&gt;
      
      &lt;p&gt;Dynamic interfaces make it possible to ascribe static types to an
      untyped JavaScript API. For example, we could write a dynamic
      interface for the HTML 5 &lt;code&gt;CanvasRenderingContext2D&lt;/code&gt; like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;dynamic CanvasRenderingContext2D {
          shared formal variable String|CanvasGradient|CanvasPattern fillStyle;
          shared formal variable String font;
      
          shared formal void beginPath();
          shared formal void closePath();
      
          shared formal void moveTo(Integer x, Integer y);
          shared formal void lineTo(Integer x, Integer y);
      
          shared formal void fill();
          shared formal void stroke();
      
          shared formal void fillText(String text, Integer x, Integer y, Integer maxWidth=-1);
      
          shared formal void arc(Integer x, Integer y, Integer radius, Float startAngle, Float endAngle, Boolean anticlockwise);
          shared formal void arcTo(Integer x1, Integer y1, Integer x2, Float y2, Integer radius);
      
          shared formal void bezierCurveTo(Integer cp1x, Integer cp1y, Integer cp2x, Float cp2y, Integer x, Integer y);
      
          shared formal void strokeRect(Integer x, Integer y, Integer width, Integer height);
          shared formal void fillRect(Integer x, Integer y, Integer width, Integer height);
          shared formal void clearRect(Integer x, Integer y, Integer width, Integer height);
      
          shared formal CanvasGradient createLinearGradient(Integer x0, Integer y0, Integer x1, Integer y1);
          shared formal CanvasGradient createRadialGradient(Integer x0, Integer y0, Integer r0, Integer x1, Integer y1, Integer r1);
          shared formal CanvasPattern createPattern(dynamic image, String repetition);
      
          //TODO: more operations!!
      }
      
      dynamic CanvasGradient {
          shared formal void addColorStop(Integer offset, String color);
      }
      
      dynamic CanvasPattern {
          //todo
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now, if we assign an instance of JavaScript's &lt;code&gt;CanvasRenderingContext2D&lt;/code&gt; to this interface
      type, we won't need to be inside a &lt;code&gt;dynamic&lt;/code&gt; block when we call its methods. You can try it
      out in your own browser by clicking the &quot;TRY ONLINE&quot; button!&lt;/p&gt;
      
      &lt;!-- try:
          dynamic CanvasRenderingContext2D {
              shared formal variable String|CanvasGradient|CanvasPattern fillStyle;
              shared formal variable String font;
              
              shared formal void beginPath();
              shared formal void closePath();
              
              shared formal void moveTo(Integer x, Integer y);
              shared formal void lineTo(Integer x, Integer y);
              
              shared formal void fill();
              shared formal void stroke();
              
              shared formal void fillText(String text, Integer x, Integer y, Integer maxWidth=-1);
              
              shared formal void arc(Integer x, Integer y, Integer radius, Float startAngle, Float endAngle, Boolean anticlockwise);
              shared formal void arcTo(Integer x1, Integer y1, Integer x2, Float y2, Integer radius);
              
              shared formal void bezierCurveTo(Integer cp1x, Integer cp1y, Integer cp2x, Float cp2y, Integer x, Integer y);
              
              shared formal void strokeRect(Integer x, Integer y, Integer width, Integer height);
              shared formal void fillRect(Integer x, Integer y, Integer width, Integer height);
              shared formal void clearRect(Integer x, Integer y, Integer width, Integer height);
              
              shared formal CanvasGradient createLinearGradient(Integer x0, Integer y0, Integer x1, Integer y1);
              shared formal CanvasGradient createRadialGradient(Integer x0, Integer y0, Integer r0, Integer x1, Integer y1, Integer r1);
              shared formal CanvasPattern createPattern(dynamic image, String repetition);
              
              //TODO: more operations!!
          }
          
          dynamic CanvasGradient {
              shared formal void addColorStop(Integer offset, String color);
          }
          
          dynamic CanvasPattern {
              //todo
          }
      
          CanvasRenderingContext2D ctx;
          
          dynamic {
              dynamic win = openCanvasWindow();
              dynamic canvas = win.ceylonCanvas;
              canvas.width = 600;
              canvas.height = 300;
              ctx = canvas.getContext(&quot;2d&quot;);
          }
          
          ctx.fillStyle = &quot;navy&quot;;
          ctx.fillRect(50, 50, 235, 60);
          ctx.beginPath();
          ctx.moveTo(100,50);
          ctx.lineTo(60,5);
          ctx.lineTo(75,75);
          ctx.fill();
          ctx.fillStyle = &quot;orange&quot;;
          ctx.font = &quot;40px PT Sans&quot;;
          ctx.fillText(&quot;Hello world!&quot;, 60, 95);
      --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;CanvasRenderingContext2D ctx;
      dynamic {
          //get the CanvasRenderingContext2D from the 
          //canvas element using dynamically typed code
          ctx = ... ;
      }
      
      //typesafe code, checked at compile time 
      ctx.fillStyle = &quot;navy&quot;;
      ctx.fillRect(50, 50, 235, 60);
      ctx.beginPath();
      ctx.moveTo(100,50);
      ctx.lineTo(60,5);
      ctx.lineTo(75,75);
      ctx.fill();
      ctx.fillStyle = &quot;orange&quot;;
      ctx.font = &quot;40px PT Sans&quot;;
      ctx.fillText(&quot;Hello world!&quot;, 60, 95);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Notice that we don't need to ascribe an explicit type to &lt;em&gt;every&lt;/em&gt;
      operation of the interface. We can leave some methods, or even
      just some parameters of a method untyped, by declaring them
      &lt;code&gt;dynamic&lt;/code&gt;. Such operations may only be called from within a
      &lt;code&gt;dynamic&lt;/code&gt; block, however.&lt;/p&gt;
      
      &lt;p&gt;A word of caution: dynamic interfaces are a convenient fiction.
      They can help make it easier to work with an API in your IDE,
      but at runtime there is nothing Ceylon can do to ensure that
      the object you assign to the dynamic interface type &lt;em&gt;actually
      implements the operations&lt;/em&gt; you've ascribed to it.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2014/10/10/ceylon-osgi-jee</id>
    <title>Write in Ceylon, deploy as OSGI, use in Java EE</title>
    <updated>2014-10-10T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2014/10/10/ceylon-osgi-jee" rel="alternate" type="text/html" />
    <author>
      <name>David Festal</name>
    </author>
    <summary>
      ... or how to use Ceylon inside Java EE application servers.
      
      The Ceylon language is inherently modular, and is shipped with a complete
      infrastructure that allows leveraging this modularity out-of-the box.
      However Ceylon is not captive of its own infrastructure. After the Java
      and JS interoperability efforts, the 1.1.0 version has brought out-of-the-box
      compatibility with OSGI, which enables running Ceylon code inside many other
      containers.
      
      Every module archive produced by the Ceylon compiler contains OSGI headers
      in its MANIFEST file, that describe the module as it should seen by OSGI
      containers.
      
      Containers tested so far are:
      
      
      Apache Felix 4.4.1,
      Oracle Glassfish v4.1,
      Equinox platform,
      JBoss WildFly 8.0.0.alpha3 (with JBossOSGi installed)
      
      
      
      Of course, the Ceylon distribution...
    </summary>
    <content type="html">
      &lt;h3&gt;... or how to use Ceylon inside Java EE application servers.&lt;/h3&gt;
      
      &lt;p&gt;The Ceylon language is inherently modular, and is shipped with a complete
      infrastructure that allows leveraging this modularity out-of-the box.
      However Ceylon is &lt;em&gt;not captive of its own infrastructure&lt;/em&gt;. After the Java
      and JS interoperability efforts, the 1.1.0 version has brought out-of-the-box
      compatibility with OSGI, which enables running Ceylon code inside many other
      containers.&lt;/p&gt;
      
      &lt;p&gt;Every module archive produced by the Ceylon compiler contains OSGI headers
      in its MANIFEST file, that describe the module as it should seen by OSGI
      containers.&lt;/p&gt;
      
      &lt;p&gt;Containers tested so far are:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Apache Felix 4.4.1,&lt;/li&gt;
      &lt;li&gt;Oracle Glassfish v4.1,&lt;/li&gt;
      &lt;li&gt;Equinox platform,&lt;/li&gt;
      &lt;li&gt;JBoss WildFly 8.0.0.alpha3 (with JBossOSGi installed)&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Of course, the Ceylon distribution and SDK modules should first be added
      inside the OSGI container as OSGI bundles.&lt;/p&gt;
      
      &lt;p&gt;But instead of writing long explanations here, let me direct you to some
      concrete examples provided, with the required instructions, in the
      following repository:&lt;/p&gt;
      
      &lt;p&gt;&lt;a href=&quot;https://github.com/davidfestal/Ceylon-Osgi-Examples/&quot;&gt;https://github.com/davidfestal/Ceylon-Osgi-Examples/&lt;/a&gt;&lt;/p&gt;
      
      &lt;p&gt;For the moment, it contains a single example that, though very simple, will
      give you the main steps to start.&lt;/p&gt;
      
      &lt;p&gt;It also shows the use of a Ceylon module &lt;em&gt;totally outside Ceylon's standard
      infrastructure&lt;/em&gt;, even &lt;em&gt;outside the JBoss world&lt;/em&gt;, in a
      &lt;strong&gt;Web application servlet running on a Glassfish v4.1 application server&lt;/strong&gt;.
      But of course you should be able to run it inside other OSGI-enabled
      application servers or containers.&lt;/p&gt;
      
      &lt;p&gt;In the next examples we'll try to go further an do more interesting things
      such as providing services, using Ceylon annotations (which are compatible
      with Java annotations), or using OSGI services.&lt;/p&gt;
      
      &lt;p&gt;Please report any problem you might encounter while testing, and feel free
      to submit pull requests for any other successful use cases  you might have
      built.&lt;/p&gt;
      
      &lt;p&gt;Looking forward for your remarks, and for the time to write the following
      examples.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2014/10/09/ceylon-1</id>
    <title>Ceylon 1.1.0 is now available</title>
    <updated>2014-10-09T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2014/10/09/ceylon-1" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      Ten whole months in the making, this is the biggest release
      of Ceylon so far! Ceylon 1.1.0 incorporates oodles of
      enhancements and bugfixes, with well over 1400 issues
      closed.
      
      Ceylon is a modern, modular, statically typed programming
      language for the Java and JavaScript virtual machines. The
      language features a flexible and very readable syntax, a
      unique and uncommonly elegant static type system, a powerful
      module architecture, and excellent tooling, including an
      awesome Eclipse-based IDE.
      
      Ceylon enables the development of cross-platform modules
      that execute portably in both virtual machine environments.
      Alternatively, a Ceylon module may target one or the other
      platform, in which case it may interoperate with native code
      written for that platform.
      
      For the...
    </summary>
    <content type="html">
      &lt;p&gt;Ten whole months in the making, this is the biggest release
      of Ceylon so far! &lt;a href=&quot;https://ceylon-lang.org/download/&quot;&gt;Ceylon 1.1.0&lt;/a&gt; incorporates oodles of
      enhancements and bugfixes, with well over &lt;a href=&quot;https://ceylon-lang.org/documentation/1.0/roadmap/&quot;&gt;1400 issues&lt;/a&gt;
      closed.&lt;/p&gt;
      
      &lt;p&gt;Ceylon is a modern, modular, statically typed programming
      language for the Java and JavaScript virtual machines. The
      language features a flexible and very readable syntax, a
      unique and uncommonly elegant static type system, a powerful
      module architecture, and excellent tooling, including an
      awesome Eclipse-based IDE.&lt;/p&gt;
      
      &lt;p&gt;Ceylon enables the development of cross-platform modules
      that execute portably in both virtual machine environments.
      Alternatively, a Ceylon module may target one or the other
      platform, in which case it may interoperate with native code
      written for that platform.&lt;/p&gt;
      
      &lt;p&gt;For the end user, the most significant improvements in
      Ceylon 1.1 are:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;strong&gt;performance enhancements&lt;/strong&gt;, especially to compilation
      times in the IDE,&lt;/li&gt;
      &lt;li&gt;even smoother &lt;strong&gt;interoperation with Java overloading and
      Java generics&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;out of the box support for deployment of &lt;strong&gt;Ceylon modules
      on OSGi containers&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;enhancements to the Ceylon SDK, including the &lt;strong&gt;new
      platform modules&lt;/strong&gt; &lt;code&gt;ceylon.promise&lt;/code&gt;, &lt;code&gt;ceylon.locale&lt;/code&gt;, and
      &lt;code&gt;ceylon.logging&lt;/code&gt;, along with many improvements to
      &lt;code&gt;ceylon.language&lt;/code&gt;, &lt;code&gt;ceylon.collection&lt;/code&gt;, and &lt;code&gt;ceylon.test&lt;/code&gt;,&lt;/li&gt;
      &lt;li&gt;many new features and improvements in &lt;strong&gt;Ceylon IDE&lt;/strong&gt;,
      including&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.formatter&lt;/code&gt;, a high-quality &lt;strong&gt;code formatter&lt;/strong&gt;
      written in Ceylon,&lt;/li&gt;
      &lt;li&gt;support for command line tool plugins, including the new
      &lt;code&gt;ceylon format&lt;/code&gt; and &lt;code&gt;ceylon build&lt;/code&gt; plugins, and&lt;/li&gt;
      &lt;li&gt;
      &lt;a href=&quot;https://github.com/vert-x/mod-lang-ceylon&quot;&gt;integration with vert.x&lt;/a&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;A longer list of changes may be found
      &lt;a href=&quot;https://ceylon-lang.org/blog/2014/08/10/progress-report/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;In the box&lt;/h2&gt;
      
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/download&quot;&gt;This release&lt;/a&gt; includes:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;a complete &lt;a href=&quot;https://ceylon-lang.org/documentation/1.1/spec&quot;&gt;language specification&lt;/a&gt; that defines the
      syntax and semantics of Ceylon in language accessible to
      the professional developer,&lt;/li&gt;
      &lt;li&gt;a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.1/reference/tool/ceylon/subcommands/index.html&quot;&gt;command line toolset&lt;/a&gt; including compilers for
      Java and JavaScript, a documentation compiler, and support
      for executing modular programs on the JVM and Node.js,&lt;/li&gt;
      &lt;li&gt;a powerful module architecture for code organization,
      dependency management, and module isolation at runtime,&lt;/li&gt;
      &lt;li&gt;the &lt;a href=&quot;https://herd.ceylon-lang.org/modules/ceylon.language&quot;&gt;language module&lt;/a&gt;, our minimal,
      cross-platform foundation of the &lt;a href=&quot;https://modules.ceylon-lang.org/categories/SDK&quot;&gt;Ceylon SDK&lt;/a&gt;, and&lt;/li&gt;
      &lt;li&gt;a &lt;a href=&quot;https://ceylon-lang.org/documentation/1.1/ide/features/&quot;&gt;full-featured&lt;/a&gt; Eclipse-based integrated
      development environment.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Language&lt;/h2&gt;
      
      &lt;p&gt;Ceylon is a highly understandable object-oriented language
      with static typing. The language features:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;an emphasis upon &lt;strong&gt;readability&lt;/strong&gt; and a strong bias toward
      &lt;strong&gt;omission or elimination of potentially-harmful or
      potentially-ambiguous constructs&lt;/strong&gt; and toward highly
      &lt;strong&gt;disciplined use of static types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;an extremely powerful and uncommonly elegant type system
      combining subtype and parametric polymorphism with:
      
      &lt;ul&gt;
      &lt;li&gt;first-class &lt;strong&gt;union and intersection types&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;both &lt;strong&gt;declaration-site and use-site variance&lt;/strong&gt;, and&lt;/li&gt;
      &lt;li&gt;the use of principal types for &lt;strong&gt;local type inference&lt;/strong&gt;
      and &lt;strong&gt;flow-sensitive typing&lt;/strong&gt;,&lt;/li&gt;
      &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;a unique treatment of &lt;strong&gt;function and tuple types&lt;/strong&gt;,
      enabling powerful abstractions, along with the most
      &lt;strong&gt;elegant approach to &lt;code&gt;null&lt;/code&gt;&lt;/strong&gt; of any modern language,&lt;/li&gt;
      &lt;li&gt;first-class constructs for defining &lt;strong&gt;modules and
      dependencies between modules&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;a very flexible syntax including &lt;strong&gt;comprehensions&lt;/strong&gt; and
      support for expressing &lt;strong&gt;tree-like structures&lt;/strong&gt;, and&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;fully-reified generic types&lt;/strong&gt;, on both the JVM and
      JavaScript virtual machines, and a unique &lt;strong&gt;typesafe
      metamodel&lt;/strong&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;More information about these language features may be
      found in the &lt;a href=&quot;https://ceylon-lang.org/features&quot;&gt;feature list&lt;/a&gt; and
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.1/introduction/&quot;&gt;quick introduction&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;This release introduces the following new language features:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;support for &lt;strong&gt;use-site variance&lt;/strong&gt;, enabling complete
      interop with Java generics,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;&lt;code&gt;dynamic&lt;/code&gt; interfaces&lt;/strong&gt;, providing a typesafe way to
      interoperate with dynamically typed native JavaScript code,&lt;/li&gt;
      &lt;li&gt;
      &lt;strong&gt;type inference for parameters of anonymous functions&lt;/strong&gt;
      that occur in an argument list, and&lt;/li&gt;
      &lt;li&gt;a &lt;strong&gt;&lt;code&gt;Byte&lt;/code&gt; class&lt;/strong&gt; that is optimized by the compiler.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Language module&lt;/h2&gt;
      
      &lt;p&gt;The language module was a major focus of attention in this
      release, with substantial performance improvements, API
      optimizations, and new features, including the addition of
      a raft of powerful operations for working with streams.&lt;/p&gt;
      
      &lt;p&gt;The language module now includes an API for deploying Ceylon
      modules programmatically from Java.&lt;/p&gt;
      
      &lt;p&gt;The language module is now considered stable, and no further
      breaking changes to its API are contemplated.&lt;/p&gt;
      
      &lt;h2&gt;Command line tools&lt;/h2&gt;
      
      &lt;p&gt;The &lt;code&gt;ceylon&lt;/code&gt; command now supports a plugin architecture. For
      example, type:&lt;/p&gt;
      
      &lt;!-- lang: bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;ceylon plugin install ceylon.formatter/1.1.0
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;To install the &lt;code&gt;ceylon format&lt;/code&gt; subcommand.&lt;/p&gt;
      
      &lt;h2&gt;IDE&lt;/h2&gt;
      
      &lt;p&gt;This release of the IDE features dramatic improvements to
      build performance, and introduces many new features,
      including:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;a &lt;strong&gt;code formatter&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;seven &lt;strong&gt;new refactorings&lt;/strong&gt; and many improvements to existing
      refactorings,&lt;/li&gt;
      &lt;li&gt;many &lt;strong&gt;new quick fixes/assists&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;IntelliJ-style &lt;strong&gt;&quot;chain completion&quot;&lt;/strong&gt; and completion of toplevel
      functions applying to a value,&lt;/li&gt;
      &lt;li&gt;a rewritten &lt;strong&gt;Explorer view&lt;/strong&gt;, with better presentation of modules
      and modular dependencies,&lt;/li&gt;
      &lt;li&gt;synchronization of all keyboard accelerators with JDT
      equivalents,&lt;/li&gt;
      &lt;li&gt;Quick Find References, Recently Edited Files, Format Block,
      Visualize Modular Dependencies, Open in Type Hierarchy View,
      Go to Refined Declaration, and much more.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;SDK&lt;/h2&gt;
      
      &lt;p&gt;The &lt;a href=&quot;https://modules.ceylon-lang.org/categories/SDK&quot;&gt;platform modules&lt;/a&gt;, recompiled for 1.1.0, are
      available in the shared community repository, &lt;a href=&quot;https://herd.ceylon-lang.org&quot;&gt;Ceylon Herd&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;This release introduces the following new platform modules:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.promise&lt;/code&gt;, cross-platform support for &lt;strong&gt;promises&lt;/strong&gt;,&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.locale&lt;/code&gt;, a cross-platform library for
       &lt;strong&gt;internationalization&lt;/strong&gt;, and&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ceylon.logging&lt;/code&gt;, a simple &lt;strong&gt;logging API&lt;/strong&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;In addition, there were many improvements to
      &lt;code&gt;ceylon.collection&lt;/code&gt;, which is now considered stable, and to
      &lt;code&gt;ceylon.test&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;The Ceylon SDK is available from &lt;a href=&quot;https://herd.ceylon-lang.org&quot;&gt;Ceylon Herd&lt;/a&gt;, the community
      module repository.&lt;/p&gt;
      
      &lt;h2&gt;Vert.x integration&lt;/h2&gt;
      
      &lt;p&gt;&lt;code&gt;mod-lang-ceylon&lt;/code&gt; implements Ceylon 1.1 support for
      Vert.x 2.1.x, and may be downloaded
      &lt;a href=&quot;https://github.com/vert-x/mod-lang-ceylon/releases/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Community&lt;/h2&gt;
      
      &lt;p&gt;The Ceylon community site, &lt;a href=&quot;http://ceylon-lang.org&quot;&gt;http://ceylon-lang.org&lt;/a&gt;, includes
      &lt;a href=&quot;https://ceylon-lang.org/documentation/1.1&quot;&gt;documentation&lt;/a&gt;, and information about &lt;a href=&quot;https://ceylon-lang.org/community&quot;&gt;getting involved&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Source code&lt;/h2&gt;
      
      &lt;p&gt;The source code for Ceylon, its specification, and its website
      is freely available from &lt;a href=&quot;https://github.com/ceylon&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Issues&lt;/h2&gt;
      
      &lt;p&gt;Bugs and suggestions may be reported in GitHub's
      &lt;a href=&quot;https://ceylon-lang.org/code/issues&quot;&gt;issue tracker&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Acknowledgement&lt;/h2&gt;
      
      &lt;p&gt;We're deeply indebted to the community volunteers who contributed a
      substantial part of the current Ceylon codebase, working in their own
      spare time. The following people have contributed to this release:&lt;/p&gt;
      
      &lt;p&gt;Gavin King, Stéphane Épardaud, Tako Schotanus, Emmanuel Bernard,
      Tom Bentley, Aleš Justin, David Festal, Max Rydahl Andersen,
      Mladen Turk, James Cobb, Tomáš Hradec, Ross Tate, Ivo Kasiuk,
      Enrique Zamudio, Roland Tepp, Diego Coronel, Daniel Rochetti,
      Loic Rouchon, Matej Lazar, Lucas Werkmeister, Akber Choudhry,
      Corbin Uselton, Julien Viet, Stephane Gallès, Paco Soberón,
      Renato Athaydes, Michael Musgrove, Flavio Oliveri, Michael Brackx,
      Brent Douglas, Lukas Eder, Markus Rydh, Julien Ponge, Pete Muir,
      Henning Burdack, Nicolas Leroux, Brett Cannon, Geoffrey De Smet,
      Guillaume Lours, Gunnar Morling, Jeff Parsons, Jesse Sightler,
      Oleg Kulikov, Raimund Klein, Sergej Koščejev, Chris Marshall,
      Simon Thum, Maia Kozheva, Shelby, Aslak Knutsen, Fabien Meurisse,
      Sjur Bakka, Xavier Coulon, Ari Kast, Dan Allen, Deniz Türkoglu,
      F. Meurisse, Jean-Charles Roger, Johannes Lehmann, Alexander Altman,
      allentc, Nikolay Tsankov, Chris Horne, gabriel-mirea, Georg Ragaller,
      Griffin DeJohn, Harald Wellmann, klinger, Luke, Oliver Gondža,
      Stephen Crawley.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2014/08/10/progress-report</id>
    <title>Ceylon 1.1 progress report</title>
    <updated>2014-08-10T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2014/08/10/progress-report" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      Ceylon 1.1 has been in development for 6 months already, so
      it's way past time for a progress report! Since the release
      is nearly ready, this is going to have to take the form of a
      summary of what we've been working on. Well, that's a
      daunting task, since we've already closed more than 650
      issues in the compiler and language module, and 300 in the
      IDE. Phew!
      
      The top priorities for Ceylon 1.1 were:
      
      
      Finalize and freeze the language module APIs.
      Clean up and minimize the use of Java and JavaScript
      native code in the language module.
      Mop up remaining issues affecting Java interop.
      Performance.
      IDE build performance.
      Finish ceylon.collection and freeze its...
    </summary>
    <content type="html">
      &lt;p&gt;Ceylon 1.1 has been in development for 6 months already, so
      it's way past time for a progress report! Since the release
      is nearly ready, this is going to have to take the form of a
      summary of what we've been working on. Well, that's a
      daunting task, since we've already closed more than 650
      issues in the compiler and language module, and 300 in the
      IDE. Phew!&lt;/p&gt;
      
      &lt;p&gt;The top priorities for Ceylon 1.1 were:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Finalize and freeze the language module APIs.&lt;/li&gt;
      &lt;li&gt;Clean up and minimize the use of Java and JavaScript
      native code in the language module.&lt;/li&gt;
      &lt;li&gt;Mop up remaining issues affecting Java interop.&lt;/li&gt;
      &lt;li&gt;Performance.&lt;/li&gt;
      &lt;li&gt;IDE build performance.&lt;/li&gt;
      &lt;li&gt;Finish &lt;code&gt;ceylon.collection&lt;/code&gt; and freeze its public API.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Naturally, we've also fixed hundreds of bugs unrelated to
      those priorities.&lt;/p&gt;
      
      &lt;h2&gt;Language changes&lt;/h2&gt;
      
      &lt;p&gt;There have been very few changes to the language, which has
      been considered stable since last year's 1.0 release. The
      big new features in 1.1 are:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Support for &lt;a href=&quot;https://ceylon-lang.org/blog/2014/07/14/wildcards&quot;&gt;use-site variance&lt;/a&gt;.&lt;/li&gt;
      &lt;li&gt;Introduction of a &lt;code&gt;Byte&lt;/code&gt; class that may be optimized by
      the compiler to &lt;code&gt;byte&lt;/code&gt; on the JVM.&lt;/li&gt;
      &lt;li&gt;Type inference for parameters of anonymous functions that
      occur as arguments in positional argument lists.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Other notable changes are:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Powerful disjointness analysis for sequence and tuple
      types.&lt;/li&gt;
      &lt;li&gt;Allow comprehensions to begin with an &lt;code&gt;if&lt;/code&gt; clause.&lt;/li&gt;
      &lt;li&gt;New &lt;code&gt;sealed&lt;/code&gt; annotation to prevent extension or
      instantiation of a type outside the module in which it is
      defined.&lt;/li&gt;
      &lt;li&gt;Introduction of &lt;code&gt;dynamic&lt;/code&gt; interfaces, designed for
      wrapping native JavaScript APIs.&lt;/li&gt;
      &lt;li&gt;Redefined &lt;code&gt;-&lt;/code&gt; operator to work for any &lt;code&gt;Invertible&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Allow metamodel references to &lt;code&gt;object&lt;/code&gt;s and members of
      &lt;code&gt;object&lt;/code&gt;s.&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;try (x)&lt;/code&gt; was changed to distinguish between the
      lifecycles of &lt;code&gt;Obtainable&lt;/code&gt; and &lt;code&gt;Destroyable&lt;/code&gt; resources.&lt;/li&gt;
      &lt;li&gt;The type of the expression &lt;code&gt;{}&lt;/code&gt; is now &lt;code&gt;{Nothing*}&lt;/code&gt;
      instead of &lt;code&gt;[]&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Allow refinement of multiple overloaded versions of a Java
      supertype method.&lt;/li&gt;
      &lt;li&gt;Added ability to &lt;code&gt;catch&lt;/code&gt; instances of &lt;code&gt;Throwable&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Minor adjustment to type argument inference algorithm for
      covariant and contravariant type parameters.&lt;/li&gt;
      &lt;li&gt;Change to the syntax for dynamic enumeration expressions
      in native JavaScript interop.&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;case (foo, bar)&lt;/code&gt; is now written &lt;code&gt;case (foo|bar)&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Removal of operator-style invocation expressions.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;The last four changes are breaking changes but should not
      impact very many programs.&lt;/p&gt;
      
      &lt;p&gt;Finally, note that:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Runnable functions must now be &lt;code&gt;shared&lt;/code&gt;, eliminating an
      inconsistency between Ceylon on JVM and on JS.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Language module changes&lt;/h2&gt;
      
      &lt;p&gt;For the 1.1 release, we've invested a lot of thought and
      development effort in the language module, carefully
      reviewing its design and scope, reducing the use of native
      code to an absolute minimum, optimizing performance, and
      picking on anything that looked like a mistake.&lt;/p&gt;
      
      &lt;p&gt;Therefore, this release makes several breaking changes,
      which will impact existing programs. As of Ceylon 1.1, the
      language module is considered stable, and we won't make
      further breaking changes.&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Addition of a raft of new methods and functions for
      working with streams.&lt;/li&gt;
      &lt;li&gt;Optimization of the performance of &lt;code&gt;Array&lt;/code&gt;, along with
      some minor improvements to interop with Java native arrays.&lt;/li&gt;
      &lt;li&gt;Removal of the &lt;code&gt;Cloneable&lt;/code&gt; interface, and addition of a
      &lt;code&gt;clone()&lt;/code&gt; method to &lt;code&gt;Collection&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Addition of &lt;code&gt;Throwable&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Replacement of &lt;code&gt;Closeable&lt;/code&gt; with &lt;code&gt;Obtainable&lt;/code&gt; and
      &lt;code&gt;Destroyable&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;Correspondence.items()&lt;/code&gt; changed to &lt;code&gt;getAll()&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;Map&lt;/code&gt;s and &lt;code&gt;Entry&lt;/code&gt;s may now have null items.&lt;/li&gt;
      &lt;li&gt;Various minor changes to the operations of &lt;code&gt;Iterable&lt;/code&gt;,
      &lt;code&gt;List&lt;/code&gt;, and &lt;code&gt;Map&lt;/code&gt;, including breaking changes to the
      signatures of &lt;code&gt;Iterable.sequence()&lt;/code&gt; and &lt;code&gt;Iterable.fold()&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;ArraySequence&lt;/code&gt; is now &lt;code&gt;sealed&lt;/code&gt; and may be instantiated
      via the &lt;code&gt;sequence()&lt;/code&gt; function.&lt;/li&gt;
      &lt;li&gt;Substantial redesign of &lt;code&gt;Enumerable&lt;/code&gt; and &lt;code&gt;Range&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Several changes to the type hierarchy for numeric types.&lt;/li&gt;
      &lt;li&gt;Improvements to &lt;code&gt;StringBuilder&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Removal of &lt;code&gt;SequenceBuilder&lt;/code&gt;, of redundant functions
      &lt;code&gt;entries()&lt;/code&gt; and &lt;code&gt;coalesce()&lt;/code&gt;, and of &lt;code&gt;LazyList&lt;/code&gt;, &lt;code&gt;LazySet&lt;/code&gt;,
      and &lt;code&gt;LazyMap&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Addition of &lt;code&gt;Array.sortInPlace()&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Modularity&lt;/h2&gt;
      
      &lt;p&gt;We're currently investing effort in trying to make it easier
      to use Ceylon modules outside of the Ceylon module runtime.&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Ceylon &lt;code&gt;.car&lt;/code&gt; archives now include automatically generated
      OSGi and Maven metadata, and can execute in an OSGi
      container.&lt;/li&gt;
      &lt;li&gt;New API for cross-platform resource loading.&lt;/li&gt;
      &lt;li&gt;Support for deploying Ceylon modules to
      &lt;a href=&quot;http://vertx.io&quot;&gt;Vert.x&lt;/a&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;SDK&lt;/h2&gt;
      
      &lt;p&gt;Notable changes to the SDK include:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Introduction of &lt;code&gt;ceylon.locale&lt;/code&gt;, &lt;code&gt;ceylon.logging&lt;/code&gt;, and
      &lt;code&gt;ceylon.promise&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Many enhancements to &lt;code&gt;ceylon.collection&lt;/code&gt;, including
      addition of &lt;code&gt;ArrayList&lt;/code&gt;, &lt;code&gt;TreeSet&lt;/code&gt;, &lt;code&gt;TreeMap&lt;/code&gt;, and
      &lt;code&gt;PriorityQueue&lt;/code&gt; classes, along with &lt;code&gt;Stack&lt;/code&gt; and &lt;code&gt;Queue&lt;/code&gt;
      interfaces.&lt;/li&gt;
      &lt;li&gt;Various improvements to &lt;code&gt;ceylon.dbc&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;The collections module is now considered stable, and its API
      is frozen.&lt;/p&gt;
      
      &lt;p&gt;Additionally, the &lt;code&gt;ceylon.test&lt;/code&gt; module has been
      significantly enhanced, including the following improvements:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;New &lt;code&gt;testSuit&lt;/code&gt;, &lt;code&gt;testListeners&lt;/code&gt;, and &lt;code&gt;testExecutor&lt;/code&gt;
      annotations.&lt;/li&gt;
      &lt;li&gt;Redesigned events model.&lt;/li&gt;
      &lt;li&gt;HTML report generation in &lt;code&gt;ceylon.test&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Support for TAP v13 (Test Anything Protocol).&lt;/li&gt;
      &lt;li&gt;Many improvements to &lt;code&gt;ceylon.test&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Addition of &lt;code&gt;ceylon test-js&lt;/code&gt; command.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;IDE&lt;/h2&gt;
      
      &lt;p&gt;Development of the IDE has been extremely active, with many
      new features and major performance enhancements.&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;Complete rework of build process, for much improved
      performance.&lt;/li&gt;
      &lt;li&gt;New refactorings: Move Out, Make Receiver, Move to Unit,
      Extract Parameter, Collect Parameters, Invert Boolean,
      Safe Delete.&lt;/li&gt;
      &lt;li&gt;Major enhancements to the Change Parameters refactoring.&lt;/li&gt;
      &lt;li&gt;Inline refactoring now works for shared class/interface
      members.&lt;/li&gt;
      &lt;li&gt;Much better handling of anonymous functions and function
      references in Extract and Inline refactorings.&lt;/li&gt;
      &lt;li&gt;Brand new high quality code formatter.&lt;/li&gt;
      &lt;li&gt;Rewritten Ceylon Explorer with much better presentation of
      modules and modular dependencies.&lt;/li&gt;
      &lt;li&gt;New navigation actions: Open in Type Hierarchy View,
      Go to Refined Declaration.&lt;/li&gt;
      &lt;li&gt;Popup Quick Find References and Recently Edited Files.&lt;/li&gt;
      &lt;li&gt;Graphical Visualize Modular Dependencies.&lt;/li&gt;
      &lt;li&gt;Further integration of &quot;linked mode&quot; with refactorings and
      quick assists.&lt;/li&gt;
      &lt;li&gt;Useful Format Block source action.&lt;/li&gt;
      &lt;li&gt;Auto-escape special characters when pasting into string
      literals.&lt;/li&gt;
      &lt;li&gt;Synchronization of all keyboard accelerators with JDT
      equivalents (by popular request).&lt;/li&gt;
      &lt;li&gt;Save actions in Ceylon Editor preferences.&lt;/li&gt;
      &lt;li&gt;IntelliJ-style &quot;chain completion&quot; (hit ctrl-space twice).&lt;/li&gt;
      &lt;li&gt;Propose toplevel functions applying to a type alongside
      members of the type.&lt;/li&gt;
      &lt;li&gt;Several new options for customizing autocompletion and
      appearance in Ceylon Editor preferences.&lt;/li&gt;
      &lt;li&gt;New quick fixes/assists: convert between string
      interpolation and concatenation, convert to/from verbatim
      string, add satisfied interfaces, add type parameter,
      change named argument list to positional, fill in
      argument names, export module, convert to verbose form
      refinement, print expression, fix refining method signature,
      change to &lt;code&gt;if (exists)&lt;/code&gt;, change module version, assign to
      &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;try&lt;/code&gt;/&lt;code&gt;if (exists)&lt;/code&gt;/&lt;code&gt;if (nonempty)&lt;/code&gt;/&lt;code&gt;if (is)&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Run As Ceylon Test on node.js.&lt;/li&gt;
      &lt;li&gt;Support for running all tests in a project or source
      folder.&lt;/li&gt;
      &lt;li&gt;New default color scheme for syntax highlighting and many
      other aesthetic improvements.&lt;/li&gt;
      &lt;/ul&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2014/07/14/wildcards</id>
    <title>Why I distrust wildcards and why we need them anyway</title>
    <updated>2014-07-14T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2014/07/14/wildcards" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      In any programming language that combines subtype polymorphism
      (object orientation) with parametric polymorphism (generics),
      the question of variance arises. Suppose I have a list of
      strings, type List&lt;String&gt;. Can I pass that to a function
      which accepts List&lt;Object&gt;? Let's start with this definition:
      
      
      
      
      interface List&lt;T&gt; {
          void add(T element);
          Iterator&lt;T&gt; iterator();
          ...
      }
      
      
      Broken covariance
      
      Intuitively, we might at first think that this should be
      allowed. This looks OK:
      
      
      
      
      void iterate(List&lt;Object&gt; list) {
          Iterator&lt;Object&gt; it = list.iterator();
          ...
      }
      iterate(ArrayList&lt;String&gt;());
      
      
      Indeed, certain languages, including Eiffel and Dart do
      accept this code. Sadly, it's unsound, as can be seen in...
    </summary>
    <content type="html">
      &lt;p&gt;In any programming language that combines subtype polymorphism
      (object orientation) with parametric polymorphism (generics),
      the question of &lt;em&gt;variance&lt;/em&gt; arises. Suppose I have a list of
      strings, type &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;. Can I pass that to a function
      which accepts &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;? Let's start with this definition:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;interface List&amp;lt;T&amp;gt; {
          void add(T element);
          Iterator&amp;lt;T&amp;gt; iterator();
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h2&gt;Broken covariance&lt;/h2&gt;
      
      &lt;p&gt;Intuitively, we might at first think that this should be
      allowed. This looks OK:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;void iterate(List&amp;lt;Object&amp;gt; list) {
          Iterator&amp;lt;Object&amp;gt; it = list.iterator();
          ...
      }
      iterate(ArrayList&amp;lt;String&amp;gt;());
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Indeed, certain languages, including Eiffel and Dart do
      accept this code. Sadly, it's unsound, as can be seen in the
      following example:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;//Eiffel/Dart-like language with 
      //broken covariance:
      void put(List&amp;lt;Object&amp;gt; list) {
          list.add(10);
      }
      put(ArrayList&amp;lt;String&amp;gt;());
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Here we pass a &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; to a function accepting
      &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;, which attempts to add an &lt;code&gt;Integer&lt;/code&gt; to the
      list.&lt;/p&gt;
      
      &lt;p&gt;Java makes this same mistake with arrays. The following code
      compiles:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;//Java:
      void put(Object[] list) {
          list[0]=10;
      }
      put(new String[1]);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;It fails at runtime with an &lt;code&gt;ArrayStoreException&lt;/code&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Use-site variance&lt;/h2&gt;
      
      &lt;p&gt;Java takes a different approach, however, for generic class
      and interface types. By default, a class or interface type
      is &lt;em&gt;invariant&lt;/em&gt;, which is to say, that:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;L&amp;lt;U&amp;gt;&lt;/code&gt; is assignable to &lt;code&gt;L&amp;lt;V&amp;gt;&lt;/code&gt; if and only if &lt;code&gt;U&lt;/code&gt; is
      exactly the same type as &lt;code&gt;V&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Since this is &lt;em&gt;extremely&lt;/em&gt; inconvenient much of the time,
      Java supports something called &lt;em&gt;use-site variance&lt;/em&gt;, where:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;L&amp;lt;U&amp;gt;&lt;/code&gt; is assignable to &lt;code&gt;L&amp;lt;? extends V&amp;gt;&lt;/code&gt; if &lt;code&gt;U&lt;/code&gt; is a
      subtype of &lt;code&gt;V&lt;/code&gt;, and&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;L&amp;lt;U&amp;gt;&lt;/code&gt; is assignable to &lt;code&gt;L&amp;lt;? super V&amp;gt;&lt;/code&gt; if &lt;code&gt;U&lt;/code&gt; is a
      supertype of &lt;code&gt;V&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;The ugly syntax &lt;code&gt;? extends V&lt;/code&gt; or &lt;code&gt;? super V&lt;/code&gt; is called a
      &lt;em&gt;wildcard&lt;/em&gt;. We also say that:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;L&amp;lt;? extends V&amp;gt;&lt;/code&gt; is &lt;em&gt;covariant&lt;/em&gt; in &lt;code&gt;V&lt;/code&gt;, and that&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;L&amp;lt;? super V&amp;gt;&lt;/code&gt; is &lt;em&gt;contravariant&lt;/em&gt; in &lt;code&gt;V&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Since Java's wildcard notation is so ugly, we're not going
      to use it anymore in this discussion. Instead, we'll write
      wildcards using the keywords &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; for
      contravariance and covariance respectively. Thus:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;L&amp;lt;out V&amp;gt;&lt;/code&gt; is &lt;em&gt;covariant&lt;/em&gt; in &lt;code&gt;V&lt;/code&gt;, and&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;L&amp;lt;in V&amp;gt;&lt;/code&gt; is &lt;em&gt;contravariant&lt;/em&gt; in &lt;code&gt;V&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;A given &lt;code&gt;V&lt;/code&gt; is called the &lt;em&gt;bound&lt;/em&gt; of the wildcard:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;
      &lt;code&gt;out V&lt;/code&gt; is an &lt;em&gt;upper-bounded&lt;/em&gt; wildcard, and &lt;code&gt;V&lt;/code&gt; is its upper
      bound, and&lt;/li&gt;
      &lt;li&gt;
      &lt;code&gt;in V&lt;/code&gt; is a &lt;em&gt;lower-bounded&lt;/em&gt; wildcard, and &lt;code&gt;V&lt;/code&gt; is its lower
      bound.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;In theory, we could have a wildcard with both an upper and
      lower bound, for example, &lt;code&gt;L&amp;lt;out X in Y&amp;gt;&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;We can express multiple upper bounds or multiple lower bounds
      using an intersection type, for example, &lt;code&gt;L&amp;lt;out U&amp;amp;V&amp;gt;&lt;/code&gt; or
      &lt;code&gt;L&amp;lt;in U&amp;amp;V&amp;gt;&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Note that the type expressions &lt;code&gt;L&amp;lt;out Anything&amp;gt;&lt;/code&gt; and
      &lt;code&gt;L&amp;lt;in Nothing&amp;gt;&lt;/code&gt; refer to exactly the same type, and this
      type is a supertype of all instantiations of &lt;code&gt;L&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;You'll often see people refer to wildcarded types as
      &lt;em&gt;existential types&lt;/em&gt;. What they mean by this is that if I
      know that &lt;code&gt;list&lt;/code&gt; is of type &lt;code&gt;List&amp;lt;out Object&amp;gt;&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;List&amp;lt;out Object&amp;gt; list;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Then I know that there exists an unknown type &lt;code&gt;T&lt;/code&gt;, a subtype
      of &lt;code&gt;Object&lt;/code&gt;, such that &lt;code&gt;list&lt;/code&gt; is of type &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;Alternatively, we can take a more Ceylonic point of view,
      and say that &lt;code&gt;List&amp;lt;out Object&amp;gt;&lt;/code&gt; is the union of all types
      &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a subtype of &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;In a system with use-site variance, the following code does
      not compile:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;void iterate(List&amp;lt;Object&amp;gt; list) {
          Iterator&amp;lt;Object&amp;gt; it = list.iterator();
          ...
      }
      iterate(ArrayList&amp;lt;String&amp;gt;()); //error: List&amp;lt;String&amp;gt; not a List&amp;lt;Object&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;But this code does:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;void iterate(List&amp;lt;out Object&amp;gt; list) {
          Iterator&amp;lt;out Object&amp;gt; it = list.iterator();
          ...
      }
      iterate(ArrayList&amp;lt;String&amp;gt;());
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Correctly, this code does not compile:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;void put(List&amp;lt;out Object&amp;gt; list) {
          list.add(10); //error: Integer is not a Nothing
      }
      put(ArrayList&amp;lt;String&amp;gt;());
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now we're at the entrance to the rabbit hole. In order to
      integrate wildcarded types into the type system, while
      rejecting unsound code like the above example, we need a
      much more complicated algorithm for type argument
      substitution.&lt;/p&gt;
      
      &lt;h2&gt;Member typing in use-site variance&lt;/h2&gt;
      
      &lt;p&gt;That is, when we have a generic type like &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, with a
      method &lt;code&gt;void add(T element)&lt;/code&gt;, instead of just
      straightforwardly substituting &lt;code&gt;Object&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;, like we do
      with ordinary invariant types, we need to consider the
      &lt;em&gt;variance&lt;/em&gt; of the location in which the type parameter
      occurs. In this case, &lt;code&gt;T&lt;/code&gt; occurs in a &lt;em&gt;contravariant location&lt;/em&gt;
      of the type &lt;code&gt;List&lt;/code&gt;, namely, as the type of a method parameter.
      The complicated algorithm, which I won't write down here,
      tells us that we should substitute &lt;code&gt;Nothing&lt;/code&gt;, the bottom type,
      in this location.&lt;/p&gt;
      
      &lt;p&gt;Now imagine that our &lt;code&gt;List&lt;/code&gt; interface has a &lt;code&gt;partition()&lt;/code&gt;
      method with this signature:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;interface List&amp;lt;T&amp;gt; {
          List&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; partition(Integer length);
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt; What is the return type of &lt;code&gt;partition()&lt;/code&gt; for a
       &lt;code&gt;List&amp;lt;out Y&amp;gt;&lt;/code&gt;? Well, without losing precision, it is:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt; List&amp;lt;in List&amp;lt;in Y out Nothing&amp;gt; out List&amp;lt;in Nothing out Y&amp;gt;&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Ouch.&lt;/p&gt;
      
      &lt;p&gt;Since nobody in their right mind wants to have to think
      about types like this, a sensible language would throw away
      some of those bounds, leaving something like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;List&amp;lt;out List&amp;lt;out Y&amp;gt;&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Which is vaguely acceptable. Sadly, even in this very simple
      case, we're already well beyond the point where the programmer
      can easily follow along with what the typechecker is doing.&lt;/p&gt;
      
      &lt;p&gt;So here's the essence of why I distrust use-site variance:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;A strong principle in the design of Ceylon is that the
      programmer should always be able to reproduce the
      reasoning of the compiler. It is &lt;em&gt;very&lt;/em&gt; difficult to
      reason about some of the complex types that arise with
      use-site variance.&lt;/li&gt;
      &lt;li&gt;It has a viral effect: once those wildcard types get a
      foothold in the code, they start to propagate, and it's
      quite hard to get back to my ordinary invariant types.&lt;/li&gt;
      &lt;/ul&gt;&lt;h2&gt;Declaration-site variance&lt;/h2&gt;
      
      &lt;p&gt;A much saner alternative to use-site variance is
      &lt;em&gt;declaration-site variance&lt;/em&gt;, where we specify the variance
      of a generic type when we declare it. This is the system we
      use in Ceylon. Under this system, we need to split &lt;code&gt;List&lt;/code&gt;
      into three interfaces:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;interface List&amp;lt;out T&amp;gt; {
           Iterator&amp;lt;T&amp;gt; iterator();
           List&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; partition(Integer length);
           ...
      }
      
      interface ListMutator&amp;lt;in T&amp;gt; {
          void add(T element);
      }
      
      interface MutableList&amp;lt;T&amp;gt;
          satisfies List&amp;lt;T&amp;gt;&amp;amp;ListMutator&amp;lt;T&amp;gt; {}
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;&lt;code&gt;List&lt;/code&gt; is declared to be a covariant type, &lt;code&gt;ListMutator&lt;/code&gt; a
      contravariant type, and &lt;code&gt;MutableList&lt;/code&gt; an invariant subtype
      of both.&lt;/p&gt;
      
      &lt;p&gt;It might seem that the requirement for multiple interfaces
      is a big disadvantage of declaration-site variance, but it
      often turns out to be useful to separate mutation from
      read operations, and:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;mutating operations are very often invariant, whereas&lt;/li&gt;
      &lt;li&gt;read operations are very often covariant.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Now we can write our functions like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;void iterate(List&amp;lt;Object&amp;gt; list) {
          Iterator&amp;lt;Object&amp;gt; it = list.iterator();
          ...
      }
      iterate(ArrayList&amp;lt;String&amp;gt;());
      
      void put(ListMutator&amp;lt;Integer&amp;gt; list) {
          list.add(10);
      }
      put(ArrayList&amp;lt;String&amp;gt;()); //error: List&amp;lt;String&amp;gt; is not a ListMutator&amp;lt;Integer&amp;gt;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;You can read more about declaration-site variance
      &lt;a href=&quot;http://ceylon-lang.org/documentation/1.0/tour/generics/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Why we need use-site variance in Ceylon&lt;/h2&gt;
      
      &lt;p&gt;Sadly, Java doesn't have declaration-site variance, and
      clean interoperation with Java is something that is very
      important to us. I don't like adding a major feature to the
      typesystem of our language purely for the purposes of
      interoperation with Java, and so I've resisted adding
      wildcards to Ceylon for years. In the end, reality and
      practicality won, and my stubborness lost. So Ceylon 1.1
      now features use-site variance with single-bounded wildcards.&lt;/p&gt;
      
      &lt;p&gt;I've tried to keep this feature as tightly constrained as
      possible, with just the minimum required for decent Java
      interop. That means that, like in Java:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;there are no double-bounded wildcards, of form
      &lt;code&gt;List&amp;lt;in X out Y&amp;gt;&lt;/code&gt;, and&lt;/li&gt;
      &lt;li&gt;a wildcarded type can not occur in the &lt;code&gt;extends&lt;/code&gt; or
      &lt;code&gt;satisfies&lt;/code&gt; clause of a class or interface definition.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Furthermore, unlike Java:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;there are no implicitly-bounded wildcards, upper bounds
      must always be written in explicitly, and&lt;/li&gt;
      &lt;li&gt;there is no support for &lt;em&gt;wildcard capture&lt;/em&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Wildcard capture is a very clever feature of Java, which
      makes use of the &quot;existential&quot; interpretation of a wildcard
      type. Given a generic function like this one:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;List&amp;lt;T&amp;gt; unmodifiableList&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt; list) =&amp;gt; ... :
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Java would let me call &lt;code&gt;unmodifiableList()&lt;/code&gt;, passing a
      wildcarded type like &lt;code&gt;List&amp;lt;out Object&amp;gt;&lt;/code&gt;, returning another
      wildcarded &lt;code&gt;List&amp;lt;out Object&amp;gt;&lt;/code&gt;, reasoning that there is some
      unknown &lt;code&gt;X&lt;/code&gt;, a subtype of &lt;code&gt;Object&lt;/code&gt; for which the invocation
      would be well-typed. That is, this code is considered
      well-typed, even though the type &lt;code&gt;List&amp;lt;out Object&amp;gt;&lt;/code&gt; is not
      assignable to &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; for any &lt;code&gt;T&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;List&amp;lt;out Object&amp;gt; objects = .... ;
      List&amp;lt;out Object&amp;gt; unmodifiable = unmodifiableList(objects);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;In Java, typing errors involving wildcard capture
      are almost impossible to understand, since they involve the
      unknown, and undenoteable, type. I have no plans to add
      support for wildcard capture to Ceylon.&lt;/p&gt;
      
      &lt;h2&gt;Try it out&lt;/h2&gt;
      
      &lt;p&gt;Use-site variance is already implemented and already works
      in Ceylon 1.1, which you can get from GitHub, if you're
      super-motivated.&lt;/p&gt;
      
      &lt;p&gt;Even though the main motivation for this feature was great
      Java interop, there will be other, hopefully rare, occasions
      where wildcards will be useful. That doesn't, however,
      indicate any significant shift in our approach. We will
      continue using declaration-site variance in the Ceylon SDK
      except in extreme cases.&lt;/p&gt;
      
      &lt;p&gt;UPDATE:&lt;/p&gt;
      
      &lt;p&gt;I just realized I forgot to say thanks to Ross Tate for
      helping me with the finer points of the member typing
      algorithm for use site variance. Very tricky stuff that Ross
      knows off the top of his head!&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2014/05/12/ranges</id>
    <title>Ranges and slices</title>
    <updated>2014-05-12T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2014/05/12/ranges" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      I guess we've all seen Dijkstra's
      famous argument
      that a range of natural numbers should be expressed using an
      inclusive lower bound and exclusive upper bound, and that, as
      a corollary, arrays should be indexed from 0. It's a thought
      provoking little nugget of reasoning, though it fails to
      contemplate several objections, including that:
      
      
      The inclusive lower bound/exclusive upper bound combination
      (let's call that a Dijkstra range) isn't natural for a
      range which includes negative integers. The range start&lt;=i&lt;=0
      would be written as start&lt;=i&lt;1. Dijkstra ranges are
      nastily asymmetrical!
      Zero-based indexing is infuriatingly inconvenient when
      accessing the last element of an array, or when indexing
      from the end of the array. Who here loves...
    </summary>
    <content type="html">
      &lt;p&gt;I guess we've all seen Dijkstra's
      &lt;a href=&quot;http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html&quot;&gt;famous argument&lt;/a&gt;
      that a range of natural numbers should be expressed using an
      inclusive lower bound and exclusive upper bound, and that, as
      a corollary, arrays should be indexed from 0. It's a thought
      provoking little nugget of reasoning, though it fails to
      contemplate several objections, including that:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;The inclusive lower bound/exclusive upper bound combination
      (let's call that a &lt;em&gt;Dijkstra range&lt;/em&gt;) isn't natural for a
      range which includes negative integers. The range &lt;code&gt;start&amp;lt;=i&amp;lt;=0&lt;/code&gt;
      would be written as &lt;code&gt;start&amp;lt;=i&amp;lt;1&lt;/code&gt;. Dijkstra ranges are
      nastily asymmetrical!&lt;/li&gt;
      &lt;li&gt;Zero-based indexing is infuriatingly inconvenient when
      accessing the last element of an array, or when indexing
      from the end of the array. Who here loves &lt;code&gt;array[length-i-1]&lt;/code&gt;?
      This inconvenience, at least arguably, outweighs the
      convenience of being able to write &lt;code&gt;0&amp;lt;=i&amp;lt;length&lt;/code&gt; instead of
      &lt;code&gt;1&amp;lt;=i&amp;lt;length+1&lt;/code&gt;, and thus substantially undermines Dijkstra's
      case for zero-based indexing, &lt;em&gt;even if we accept his argument
      for Dijkstra ranges!&lt;/em&gt;
      &lt;/li&gt;
      &lt;li&gt;Two endpoints isn't the only way to specify a range of
      integers!&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Ceylon doesn't have a traditional &lt;code&gt;for&lt;/code&gt; loop, and we don't
      iterate list elements by looping over the indices of the list.
      Nevertheless, we still need a way to express ranges of integers.
      Our solution to this problem is a bit different to other
      languages, and amounts to a partial rejection of Dijkstra's
      conclusions, so it's worth explaining the reasoning behind it.&lt;/p&gt;
      
      &lt;h2&gt;Ranges&lt;/h2&gt;
      
      &lt;p&gt;Our design is premised on the observation that we almost never,
      &lt;em&gt;in practice&lt;/em&gt;, naturally find ourselves with an inclusive lower
      bound/exclusive upper bound combination. What naturally arises
      in our program is almost always either:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;two (inclusive) endpoints, or&lt;/li&gt;
      &lt;li&gt;an (inclusive) starting point and a length.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Using a Dijkstra range, we can express either case without too
      much discomfort:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;start&amp;lt;=i&amp;lt;end+1&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;start&amp;lt;=i&amp;lt;start+length&lt;/code&gt;&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Thus, we can view the traditional use of Dijkstra ranges as a
      sort of compromise between these two cases: a choice that makes
      neither option too painful.&lt;/p&gt;
      
      &lt;p&gt;But, of course, by clearly distinguishing these two common
      cases, it becomes clear that both case are amenable to further
      optimization. Thus, Ceylon provides two options for expressing
      a range of integers:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;The &lt;em&gt;spanned range&lt;/em&gt; operator expresses a range in terms of
      its two endpoints as &lt;code&gt;start..end&lt;/code&gt;. In the case that &lt;code&gt;end&amp;lt;start&lt;/code&gt;,
      the range is of &lt;em&gt;decreasing&lt;/em&gt; values. In the case that
      &lt;code&gt;end==start&lt;/code&gt;, the range has exactly one value.&lt;/li&gt;
      &lt;li&gt;The &lt;em&gt;segmented range&lt;/em&gt; operator expresses a range in terms of
      its starting point and length as &lt;code&gt;start:length&lt;/code&gt;. In the case
      of a nonpositive length, the range is empty.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Thus, a traditional C-style &lt;code&gt;for&lt;/code&gt; loop of this form:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;for (i=0; i&amp;lt;length; i++) { ... }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;is written like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;for (i in 0:length) { ... }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now, since integers aren't the only things we can form ranges
      of, the &lt;code&gt;..&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; operators are generalized to any type &lt;code&gt;T&lt;/code&gt;
      that satisfies the interfaces &lt;code&gt;Ordinal &amp;amp; Comparable&amp;lt;T&amp;gt;&lt;/code&gt;. So,
      for example, we can iterate the letters of the English alphabet
      like this:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;for (c in 'a'..'z') { ... }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;h2&gt;Slices&lt;/h2&gt;
      
      &lt;p&gt;A closely related problem is that of &quot;slicing&quot; lists. Python
      uses Dijkstra ranges to express a slice of a list, so
      &lt;code&gt;list[start:end]&lt;/code&gt; contains the elements
      &lt;code&gt;list[start], list[start+1], ..., list[end-1]&lt;/code&gt;. For the
      reasons already given above, this is a reasonable compromise.&lt;/p&gt;
      
      &lt;p&gt;Ceylon goes one better, giving you the choice between:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;The &lt;em&gt;span&lt;/em&gt; operator, written &lt;code&gt;list[start..end]&lt;/code&gt; for the
      elements &lt;code&gt;list[start], list[start+1], ..., list[end]&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;The &lt;em&gt;segment&lt;/em&gt; operator, written &lt;code&gt;list[start:length]&lt;/code&gt; for the
      elements &lt;code&gt;list[start], list[start+1], ..., list[start+length-1]&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;The span and segment operators are defined in terms of the
      rather abstract interface &lt;code&gt;Ranged&lt;/code&gt; and therefore apply to more
      than just &lt;code&gt;List&lt;/code&gt;s. For example, the platform module
      &lt;code&gt;ceylon.collection&lt;/code&gt; lets you express subranges of a &lt;code&gt;SortedMap&lt;/code&gt;
      or &lt;code&gt;SortedSet&lt;/code&gt; using these operators.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2014/05/10/about-plus</id>
    <title>About the plus symbol</title>
    <updated>2014-05-10T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2014/05/10/about-plus" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      Operators in Ceylon can't be overloaded. That is to say, I
      can't redefine an operator like + to do something totally
      arbitrary, say, add a new element to a list. Instead,
      the semantics of each operator is defined by the language
      specification in terms of types defined in the language
      module. However, many of these types, and therefore the
      definitions of the operators associated with them, are quite
      abstract. For example, + is defined in terms of an
      interface called Summable. So if you want to define your
      own Complex number class, you just make it satisfy
      Summable, and you can use + to add complex numbers. We
      call this approach...
    </summary>
    <content type="html">
      &lt;p&gt;Operators in Ceylon can't be overloaded. That is to say, I
      can't redefine an operator like &lt;code&gt;+&lt;/code&gt; to do something totally
      arbitrary, say, add a new element to a list. Instead,
      the semantics of each operator is defined by the language
      specification in terms of types defined in the language
      module. However, many of these types, and therefore the
      definitions of the operators associated with them, are quite
      abstract. For example, &lt;code&gt;+&lt;/code&gt; is defined in terms of an
      interface called &lt;code&gt;Summable&lt;/code&gt;. So if you want to define your
      own &lt;code&gt;Complex&lt;/code&gt; number class, you just make it satisfy
      &lt;code&gt;Summable&lt;/code&gt;, and you can use &lt;code&gt;+&lt;/code&gt; to add complex numbers. We
      call this approach &lt;em&gt;operator polymorphism&lt;/em&gt;.&lt;/p&gt;
      
      &lt;p&gt;One of the first things people notice about Ceylon is that,
      right after singing the praises of not having operator
      overloading, we go right ahead and use &lt;code&gt;+&lt;/code&gt; for string
      concatenation! I've seen a number of folks object that
      string concatenation has nothing to do with numeric addition,
      and that this is therefore an example of us breaking our own
      rules.&lt;/p&gt;
      
      &lt;p&gt;Well, perhaps. I admit that the main motivation for using &lt;code&gt;+&lt;/code&gt;
      for string concatenation is simply that this is what most
      other programming languages use, and that therefore this is
      what we find easiest on the eyes.&lt;/p&gt;
      
      &lt;p&gt;On the other hand, I don't think there's a strong reason to
      object to the use of &lt;code&gt;+&lt;/code&gt; for concatenation. There's no single
      notion of &quot;addition&quot; in mathematics. Quite a few different
      operations are traditionally called &quot;addition&quot;, and written
      with the &lt;code&gt;+&lt;/code&gt; symbol, including addition of vectors and
      matrices.&lt;/p&gt;
      
      &lt;p&gt;Generalizing over all these operations is the job of
      &lt;em&gt;abstract algebra&lt;/em&gt;. So I recently spent some time nailing
      down and documenting how Ceylon's language module types and
      operators relate to the algebraic structures from abstract
      algebra.&lt;/p&gt;
      
      &lt;p&gt;The following three famous algebraic structures are of
      most interest to us:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;A &lt;em&gt;semigroup&lt;/em&gt; is a set of values with an associative
      binary operation.&lt;/li&gt;
      &lt;li&gt;A &lt;em&gt;monoid&lt;/em&gt; is a semigroup with an identity element.&lt;/li&gt;
      &lt;li&gt;A &lt;em&gt;group&lt;/em&gt; is a monoid where each value has an inverse
      element.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;If the binary operation is also commutative, we get a
      &lt;em&gt;commutative semigroup&lt;/em&gt;, a &lt;em&gt;commutative monoid&lt;/em&gt;, or an
      &lt;em&gt;abelian group&lt;/em&gt;.&lt;/p&gt;
      
      &lt;p&gt;Finally, a &lt;em&gt;ring&lt;/em&gt; is a set of values with &lt;em&gt;two&lt;/em&gt; binary
      operations, named addition and multiplication, where:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;the ring is an abelian group with respect to addition,&lt;/li&gt;
      &lt;li&gt;the ring is a monoid with respect to multiplication, and&lt;/li&gt;
      &lt;li&gt;multiplication distributes over addition.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Strings with concatenation form a monoid, since string
      concatenation is associative, and the empty string is an
      identity element with respect to concatenation. They don't
      form a group, since there are no inverse strings. Also,
      string concatenation isn't commutative.&lt;/p&gt;
      
      &lt;p&gt;On the other hand, integers with addition form an abelian
      group. Together with both addition and multiplication,
      the integers form a ring.&lt;/p&gt;
      
      &lt;p&gt;We could have chosen to say that Ceylon's &lt;code&gt;+&lt;/code&gt; operator
      applies only to abelian groups, or perhaps only to groups,
      or perhaps only to commutative monoids or only to
      commutative semigroups. But any of those choices would be
      as arbitrary as any other. Instead, we've decided to say
      that the interface &lt;code&gt;Summable&lt;/code&gt; abstracts over all semigroups,
      thereby blessing the use of &lt;code&gt;+&lt;/code&gt; with any mathematical
      semigroup. Thus, we can legally use it to denote string
      concatenation or any other pure associative binary operation.&lt;/p&gt;
      
      &lt;p&gt;Furthermore:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;The interface &lt;code&gt;Invertible&lt;/code&gt; abstracts over groups, allowing
      the use of the &lt;code&gt;-&lt;/code&gt; operator with any mathematical group.&lt;/li&gt;
      &lt;li&gt;The interface &lt;code&gt;Numeric&lt;/code&gt; abstracts over &lt;em&gt;rings&lt;/em&gt;, allowing
      the use of the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; operators with any mathematical
      ring.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Of course, we could have called these interfaces &lt;code&gt;Semigroup&lt;/code&gt;,
      &lt;code&gt;Group&lt;/code&gt;, and &lt;code&gt;Ring&lt;/code&gt;, and that would have made us feel smart,
      perhaps, but we're trying to communicate with programmers
      here, not mathematicians.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2014/02/19/oo-not-imperative</id>
    <title>Object-oriented != imperative</title>
    <updated>2014-02-19T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2014/02/19/oo-not-imperative" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      Dear FP community: one of the things I really like about you folks
      is the rigor you've brought to the field of programming language
      design. Compared to the kind of magical and folklore-based thinking
      we've grown accustomed to in the field of computing, your approach
      to problems is a massive breath of fresh air. But there's one area
      where you guys seem to have fallen into some rather fuzzy and
      unfounded rhetoric. What I'm taking about is your continued
      conflation of object orientation with imperative programming.
      
      When we program with classes and objects, we have the choice between
      expressing ourselves using:
      
      
      mutable objects, or
      immutable objects.
      
      
      
      This is no different to programming...
    </summary>
    <content type="html">
      &lt;p&gt;Dear FP community: one of the things I really like about you folks
      is the &lt;em&gt;rigor&lt;/em&gt; you've brought to the field of programming language
      design. Compared to the kind of magical and folklore-based thinking
      we've grown accustomed to in the field of computing, your approach
      to problems is a massive breath of fresh air. But there's one area
      where you guys seem to have fallen into some rather fuzzy and
      unfounded rhetoric. What I'm taking about is your continued
      conflation of &lt;em&gt;object orientation&lt;/em&gt; with &lt;em&gt;imperative programming&lt;/em&gt;.&lt;/p&gt;
      
      &lt;p&gt;When we program with classes and objects, we have the choice between
      expressing ourselves using:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;mutable objects, or&lt;/li&gt;
      &lt;li&gt;immutable objects.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;This is &lt;em&gt;no different&lt;/em&gt; to programming using functions, where we have
      the choice between:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;impure functions, or&lt;/li&gt;
      &lt;li&gt;pure functions.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;The use of mutable objects and impure functions is called &lt;em&gt;imperative
      programming&lt;/em&gt; and is the norm in business and scientific computing.
      Another way to describe it is &quot;programming with side-effects&quot;. Savvy
      programmers from both the OO and FP traditions have long understood
      that side-effects make it more difficult to reason about complex code,
      and that a design based upon immutable objects and/or pure functions
      is often superior.&lt;/p&gt;
      
      &lt;p&gt;Indeed, I've been hearing the advice to prefer immutable objects, and
      avoid side-effects, for as long as I've been programming using
      object-oriented languages.&lt;/p&gt;
      
      &lt;p&gt;Oh, but wait, you might respond: isn't my point totally specious, when
      so many of the objects that people actually write in practice are
      actually mutable? Well, no, I don't think so. The truth is, that almost
      as many of the &lt;em&gt;functions&lt;/em&gt; that people actually write in practice are
      impure. Programming with functions, and without objects, does not in
      itself innoculate us against side-effects. Indeed, the disciplined use
      of immutability that we see in some parts of the FP community is simply
      not the norm in business or scientific computing, even in languages
      which don't support object orientation. Trust me, the old Fortran code
      I used to mess about with when I was doing scientific computing work
      back in university was certainly no more free of side-effects than
      typical object-oriented code I've worked with since.&lt;/p&gt;
      
      &lt;p&gt;Perhaps a source of the confusion here is that we say that objects
      &quot;hold state and behavior&quot;. When some people who aren't so familiar with
      OO read this, they imagine that by &quot;state&quot;, we mean &lt;em&gt;mutable state&lt;/em&gt;.
      But that's not quite right. What this statement is saying is that an
      object holds references to other objects, along with functions that
      make use of those references. Thus, we can distinguish one instance
      of a class from another instance, by the different references (state)
      it holds. We don't mean, &lt;em&gt;necessarily&lt;/em&gt; that those references are
      &lt;em&gt;mutable&lt;/em&gt;, and, indeed, they're very often immutable, especially in
      well-designed code.&lt;/p&gt;
      
      &lt;p&gt;&quot;So&quot;, replies my imaginary FP interlocutor, &quot;how then would such an
      immutable object be any different to a closure?&quot; Well, at some level
      &lt;em&gt;it's not any different&lt;/em&gt;, and that's the point! There's nothing
      &lt;em&gt;unfunctional&lt;/em&gt; about objects! You can think of a class as a function
      that returns the closure of its own exported nested declarations.
      (Indeed, this is precisely how we think of a class in Ceylon.)&lt;/p&gt;
      
      &lt;p&gt;Among the modern languages, what really distinguishes a language as
      object-oriented is whether it supports &lt;em&gt;subtype polymorphism&lt;/em&gt; (or
      &lt;em&gt;structural polymorphism&lt;/em&gt;, which I consider just a special kind of
      subtyping). Thus, some languages that people consider &quot;functional&quot;
      (ML, Haskell) aren't object-oriented. Others (OCaml, F#) are.&lt;/p&gt;
      
      &lt;p&gt;A request: FP folks, please, please improve your use of terminology,
      because I've seen your misuse of the term &quot;object-oriented&quot; creating
      a lot of confusion in discussions about programming languages.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2014/02/05/first-ceylon-tour-in-paris</id>
    <title>First Ceylon Tour in Paris</title>
    <updated>2014-02-05T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2014/02/05/first-ceylon-tour-in-paris" rel="alternate" type="text/html" />
    <author>
      <name>St&#233;phane &#201;pardaud</name>
    </author>
    <summary>
      The Ceylon team recently had its almost yearly face-to-face meeting in Paris. For those not
      familiar with how the Ceylon team works (and indeed how most of the open-source development
      teams work in Red Hat), the Ceylon team consists in surprisingly few individuals working
      remotely, and distributed world-wide. This includes not only developers such as me, paid
      by Red Hat to work full-time on Ceylon, but also the community of Ceylon enthusiasts who
      contribute time, code or discussions in their free time, without financial compensation other
      than the satisfaction of helping Ceylon be that much better that much sooner.
      
      This means that yes, we do all work...
    </summary>
    <content type="html">
      &lt;p&gt;The Ceylon team recently had its almost yearly face-to-face meeting in Paris. For those not
      familiar with how the Ceylon team works (and indeed how most of the open-source development
      teams work in Red Hat), the Ceylon team consists in surprisingly few individuals working
      remotely, and distributed world-wide. This includes not only developers such as me, paid
      by Red Hat to work full-time on Ceylon, but also the community of Ceylon enthusiasts who
      contribute time, code or discussions in their free time, without financial compensation other
      than the satisfaction of helping Ceylon be that much better that much sooner.&lt;/p&gt;
      
      &lt;p&gt;This means that yes, we do all work without seeing each other in person in most cases. Naturally,
      we communicate a lot in order to work together, but in our case that means via the Ceylon mailing
      list, or IRC channel, or via our issue tracker. We don't even do voice chats. This is pretty great
      for the Ceylon community, as 99% of our discussions are thus online and in the open and visible. I
      say 99% because there's always cases where there are some one-to-one discussions we have over private
      channels, especially when we want to prepare surprises :)&lt;/p&gt;
      
      &lt;p&gt;An interesting consequence of that is that we have met surprisingly few people of the team in person.
      A few of us met physically during conferences, others by being geographically close, and others yet
      during our previous face-to-face meeting two years ago in Barcelona, when we were very few. But overall,
      most of us had never seen each other in person, which is why we try to hold yearly face-to-faces.&lt;/p&gt;
      
      &lt;p&gt;The primary purpose of meeting together in my opinion is to have social interactions and talk about
      something else than work for once. It also allows us to lock people in a room and prevent them from
      going out before they've looked at something or given their opinion on something, which is something
      that can't happen so easily when distributed. An example of that is when Loïc (one of our great
      free-time contributors) came to present us &lt;code&gt;ceylon.build&lt;/code&gt; and wanted our opinion, which we had
      somewhat neglected to give previously, due to poor planning on our part.&lt;/p&gt;
      
      &lt;center&gt;
      &lt;embed type=&quot;application/x-shockwave-flash&quot; src=&quot;https://static.googleusercontent.com/external_content/picasaweb.googleusercontent.com/slideshow.swf&quot; width=&quot;600&quot; height=&quot;400&quot; flashvars=&quot;host=picasaweb.google.com&amp;amp;captions=1&amp;amp;hl=en_GB&amp;amp;feat=flashalbum&amp;amp;RGB=0x000000&amp;amp;feed=https%3A%2F%2Fpicasaweb.google.com%2Fdata%2Ffeed%2Fapi%2Fuser%2F103036382695763273919%2Falbumid%2F5972503475009012801%3Falt%3Drss%26kind%3Dphoto%26hl%3Den_GB&quot; pluginspage=&quot;http://www.macromedia.com/go/getflashplayer&quot;&gt;&lt;/embed&gt;
      &lt;/center&gt;
      
      
      &lt;p&gt;We did also discuss things such as language features, roadmap and priorities, but those have already
      been reflected openly via our mailing list and issue tracker, where the discussion can continue.&lt;/p&gt;
      
      &lt;p&gt;The last (pretty big) advantage of being all together at the same place, was that we could take
      this opportunity to hold our first Ceylon Tour conference!&lt;/p&gt;
      
      &lt;h2&gt;The first Ceylon Tour conference in Paris&lt;/h2&gt;
      
      &lt;p&gt;Thanks to the guys from &lt;a href=&quot;http://www.irill.org&quot;&gt;IRILL&lt;/a&gt; we were able to secure a very nice room to hold
      our first Ceylon conference, for free, where I'm glad to say lots of people showed up. We had people
      from from Slovenia, Germany and Austria, not to mention all over France and yes, even Paris. We were
      very surprised by the fact that people came from further than Paris, but it shows that Ceylon generates
      lots of interest.&lt;/p&gt;
      
      &lt;p&gt;We held the following talks during the morning :&lt;/p&gt;
      
      &lt;h3&gt;Ceylon introduction&lt;/h3&gt;
      
      &lt;center&gt;
      &lt;iframe src=&quot;http://www.slideshare.net/slideshow/embed_code/30854671?rel=0&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen&gt; &lt;/iframe&gt;
      &lt;div style=&quot;margin-bottom:5px&quot;&gt;
       &lt;strong&gt; &lt;a href=&quot;https://www.slideshare.net/UnFroMage/ceylon-introduction-by-stphane-pardaud&quot; title=&quot;Ceylon introduction by Stéphane Épardaud&quot; target=&quot;_blank&quot;&gt;Ceylon introduction by Stéphane Épardaud&lt;/a&gt; &lt;/strong&gt;
      &lt;/div&gt;
      &lt;/center&gt;
      
      
      &lt;h3&gt;Ceylon idioms&lt;/h3&gt;
      
      &lt;center&gt;
      &lt;iframe src=&quot;http://www.slideshare.net/slideshow/embed_code/30854189?rel=0&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;https://www.slideshare.net/UnFroMage/gavin-idioms&quot; title=&quot;Ceylon idioms by Gavin King&quot; target=&quot;_blank&quot;&gt;Ceylon idioms by Gavin King&lt;/a&gt; &lt;/strong&gt;
      &lt;/div&gt;
      &lt;/center&gt;
      
      
      &lt;h3&gt;Cayla and Vert.x in Ceylon&lt;/h3&gt;
      
      &lt;center&gt;
      &lt;iframe src=&quot;http://www.slideshare.net/slideshow/embed_code/30854155?rel=0&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;https://www.slideshare.net/UnFroMage/gavin-cayla&quot; title=&quot;Cayla and Vert.x in Ceylon, by Gavin King&quot; target=&quot;_blank&quot;&gt;Cayla and Vert.x in Ceylon, by Gavin King&lt;/a&gt; &lt;/strong&gt;
      &lt;/div&gt;
      &lt;/center&gt;
      
      
      &lt;h3&gt;Ceylon SDK&lt;/h3&gt;
      
      &lt;center&gt;
      &lt;iframe src=&quot;http://www.slideshare.net/slideshow/embed_code/30854663?rel=0&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;https://www.slideshare.net/UnFroMage/2014-01ceylontoursdk&quot; title=&quot;Ceylon SDK by Stéphane Épardaud&quot; target=&quot;_blank&quot;&gt;Ceylon SDK by Stéphane Épardaud&lt;/a&gt; &lt;/strong&gt; &lt;/div&gt;
      &lt;/center&gt;
      
      
      &lt;h3&gt;ceylon.build&lt;/h3&gt;
      
      &lt;center&gt;
      &lt;iframe src=&quot;http://www.slideshare.net/slideshow/embed_code/30854193?rel=0&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;https://www.slideshare.net/UnFroMage/loic-build&quot; title=&quot;Ceylon.build by Loïc Rouchon&quot; target=&quot;_blank&quot;&gt;Ceylon.build by Loïc Rouchon&lt;/a&gt; &lt;/strong&gt;
      &lt;/div&gt;
      &lt;/center&gt;
      
      
      &lt;h3&gt;ceylon.test&lt;/h3&gt;
      
      &lt;center&gt;
      &lt;iframe src=&quot;http://www.slideshare.net/slideshow/embed_code/30854118?rel=0&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;https://www.slideshare.net/UnFroMage/tomas-test&quot; title=&quot;Ceylon.test by Thomáš Hradec&quot; target=&quot;_blank&quot;&gt;Ceylon.test by Thomáš Hradec&lt;/a&gt; &lt;/strong&gt;
      &lt;/div&gt;
      &lt;/center&gt;
      
      
      &lt;h3&gt;Ceylon module repositories&lt;/h3&gt;
      
      &lt;center&gt;
      &lt;iframe src=&quot;http://www.slideshare.net/slideshow/embed_code/30854132?rel=0&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;https://www.slideshare.net/UnFroMage/ales-cmr&quot; title=&quot;Ceylon module repositories by Aleš Justin&quot; target=&quot;_blank&quot;&gt;Ceylon module repositories by Aleš Justin&lt;/a&gt; &lt;/strong&gt;
      &lt;/div&gt;
      &lt;/center&gt;
      
      
      &lt;h3&gt;Ceylon/Java interop&lt;/h3&gt;
      
      &lt;center&gt;
      &lt;iframe src=&quot;http://www.slideshare.net/slideshow/embed_code/30854207?rel=0&quot; width=&quot;427&quot; height=&quot;356&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;https://www.slideshare.net/UnFroMage/tako-interop&quot; title=&quot;Ceylon/Java interop by Tako Schotanus&quot; target=&quot;_blank&quot;&gt;Ceylon/Java interop by Tako Schotanus&lt;/a&gt; &lt;/strong&gt;
      &lt;/div&gt;
      &lt;/center&gt;
      
      
      &lt;h3&gt;Ceylon workshop&lt;/h3&gt;
      
      &lt;p&gt;And in the afternoon we had a great Ceylon workshop where people got to code in Ceylon, driven and helped
      by Gavin, and I'm glad to say that after 4 hours of workshop, most people were still not only awake, but
      engaged and coding, rather than just checking their email :)&lt;/p&gt;
      
      &lt;h3&gt;The next Ceylon Tour?&lt;/h3&gt;
      
      &lt;p&gt;All in all, we're very happy with the event, the content, the turnout and to answer the questions we got
      when we announced the first Ceylon Tour in Paris, yes we will try to plan another round in other locations,
      such as London, Berlin and the USA. If you think we should hold a Ceylon Tour event in your country/city,
      let us know and we'll happily discuss it.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2013/12/23/reduce</id>
    <title>The signature of reduce() in Ceylon</title>
    <updated>2013-12-23T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2013/12/23/reduce" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      The Iterable interface defines a method named fold() with
      this signature:
      
      
      
      
      Result fold&lt;Result&gt;(Result initial)
              (Result accumulating(Result partial, Element element))
      
      
      Where Element is the element type of the Iterable. This
      method accepts an initial value, and an accumulator function
      which is applied to each element of the iterable object in
      turn. For example:
      
      
      
      
      Integer sum = (1..10).fold(0)(plus);
      
      
      Sometimes, we don't need the initial value, since can simply
      start accumulating from the first element. Following the
      convention used by Scala and F#, let's call this function
      reduce(). Then we would like to be able to write:
      
      
      
      
      Integer sum = (1..10).reduce(plus);
      
      
      But what should the signature of this method...
    </summary>
    <content type="html">
      &lt;p&gt;The &lt;code&gt;Iterable&lt;/code&gt; interface defines a method named &lt;code&gt;fold()&lt;/code&gt; with
      this signature:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Result fold&amp;lt;Result&amp;gt;(Result initial)
              (Result accumulating(Result partial, Element element))
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Where &lt;code&gt;Element&lt;/code&gt; is the element type of the &lt;code&gt;Iterable&lt;/code&gt;. This
      method accepts an initial value, and an accumulator function
      which is applied to each element of the iterable object in
      turn. For example:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Integer sum = (1..10).fold(0)(plus);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Sometimes, we don't need the initial value, since can simply
      start accumulating from the first element. Following the
      convention used by Scala and F#, let's call this function
      &lt;code&gt;reduce()&lt;/code&gt;. Then we would like to be able to write:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Integer sum = (1..10).reduce(plus);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;But what should the signature of this method be? A first stab
      might give us:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Element reduce(Element accumulating(Element partial, Element elem))
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;But this signature is a bit more restrictive than it should
      be. It's perfectly reasonable for the result type of &lt;code&gt;reduce()&lt;/code&gt;
      to be a supertype of the element type. Scala handles this using
      a lower bound type constraint. Transliterating this to Ceylon,
      using an imaginary syntax for lower bounds, it would look like:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Result reduce&amp;lt;Result&amp;gt;(Result accumulating(Result partial, Element elem))
              given Result abstracts Element
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Here the lower bound constraint ensures that the first element
      is assignable to the first parameter of the accumulator
      function.&lt;/p&gt;
      
      &lt;p&gt;But Ceylon doesn't have lower bound type constraints. Why?
      Well, because it seems that we can in practice almost always
      use union types to achieve the same effect. So let's try that:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Result|Element reduce&amp;lt;Result&amp;gt;(
              Result accumulating(Result|Element partial, Element element))
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now let's try to implement this signature. One possibility
      would be:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Result|Element reduce&amp;lt;Result&amp;gt;(
              Result accumulating(Result|Element partial, Element element)) {
          assert (!empty, is Element initial = first);
          variable Result|Element partial = initial;
          for (elem in rest) {
              partial = accumulating(partial, elem);
          }
          return partial;
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;The assertion handles the case of an empty &lt;code&gt;Iterable&lt;/code&gt;, resulting
      in an &lt;code&gt;AssertionException&lt;/code&gt; if the iterable object has no first
      element.&lt;/p&gt;
      
      &lt;p&gt;Alternatively, we might prefer to return &lt;code&gt;null&lt;/code&gt; in the case of
      an empty &lt;code&gt;Iterable&lt;/code&gt;, which suggests the following implementation:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Result|Element|Null reduce&amp;lt;Result&amp;gt;(
              Result accumulating(Result|Element partial, Element element)) {
          if (!empty, is Element initial = first) {
              variable Result|Element partial = initial;
              for (elem in rest) {
                  partial = accumulating(partial, elem);
              }
              return partial;
          }
          else {
              return null;
          }
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Going back to Scala, we notice that Scala has two versions of
      &lt;code&gt;reduce()&lt;/code&gt;, which are exactly analogous to the two possibilities
      we've just seen. The first version throws an exception in the
      empty case, and the second version, &lt;code&gt;reduceOption()&lt;/code&gt;, returns an
      instance of the wrapper class &lt;code&gt;Option&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;But in Ceylon, we can do better. In Ceylon, &lt;code&gt;Iterable&lt;/code&gt; has a
      slightly mysterious-looking second type parameter, named &lt;code&gt;Absent&lt;/code&gt;,
      with an upper bound &lt;code&gt;given Absent satisfies Null&lt;/code&gt;. An
      &lt;code&gt;Iterable&amp;lt;T,Null&amp;gt;&lt;/code&gt;, which we usually write &lt;code&gt;{T*}&lt;/code&gt;, is a
      &lt;em&gt;possibly-empty&lt;/em&gt; iterable. An &lt;code&gt;Iterable&amp;lt;T,Nothing&amp;gt;&lt;/code&gt;, which we
      usually write &lt;code&gt;{T+}&lt;/code&gt;, is an iterable we know to be nonempty.&lt;/p&gt;
      
      &lt;p&gt;Thus we arrive at the following definition of &lt;code&gt;reduce()&lt;/code&gt;:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt; Result|Element|Absent reduce&amp;lt;Result&amp;gt;(
              Result accumulating(Result|Element partial, Element element)) {
          value initial = first;
          if (!empty, is Element initial) {
              variable Result|Element partial = initial;
              for (elem in rest) {
                  partial = accumulating(partial, elem);
              }
              return partial;
          }
          else {
              return initial;
          }
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Now, for a &quot;spanned&quot; range expression like &lt;code&gt;1..n&lt;/code&gt;, which is
      nonempty, we get a non-null return type:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Integer sum = (1..n).reduce(plus);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;On the other hand, for a &quot;segmented&quot; range expression like
      &lt;code&gt;1:n&lt;/code&gt;, which is possibly-empty, we get an optional return
      type:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;Integer? sum = (1:n).reduce(plus);
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Best of all, it never throws an exception. This is, I humbly
      submit, Pretty Damn Nice.&lt;/p&gt;
      
      &lt;p&gt;Notice just how much work union types are doing for us here.
      Compared to Scala's &lt;code&gt;reduce()&lt;/code&gt;/&lt;code&gt;reduceOption()&lt;/code&gt;, they let us
      eliminate:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;a lower bound type constraint,&lt;/li&gt;
      &lt;li&gt;a second, effectively overloaded, version of the method,
      and&lt;/li&gt;
      &lt;li&gt;the wrapper &lt;code&gt;Option&lt;/code&gt; class.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;I've added this definition of &lt;code&gt;reduce()&lt;/code&gt; to &lt;code&gt;Iterable&lt;/code&gt;, and
      it will be available in the next release of Ceylon.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2013/12/16/ceylon-test-news</id>
    <title>When ceylon.test met meta-model</title>
    <updated>2013-12-16T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2013/12/16/ceylon-test-news" rel="alternate" type="text/html" />
    <author>
      <name>Tom&#225;&#353; Hradec</name>
    </author>
    <summary>
      Ceylon has had support for unit testing since milestone four,
      but its functionality was pretty limited due lack of annotations and meta-model at that time.
      
      Fortunately this is not true anymore!
      With version 1.0 of Ceylon we also released a completely rewritten ceylon.test module.
      So let’s see what’s new and how we can use it now.
      
      Tests annotations
      
      Tests are now declaratively marked with the test annotation
      and can be written as top-level functions or methods inside top-level class,
      in case you want to group multiple tests together.
      
      Inside tests, assertions can be evaluated by using the language’s assert statement
      or with the various assert... functions, for example assertEquals, assertThatException...
    </summary>
    <content type="html">
      &lt;p&gt;Ceylon has had support for unit testing since milestone four,
      but its functionality was pretty limited due lack of annotations and meta-model at that time.&lt;/p&gt;
      
      &lt;p&gt;Fortunately this is not true anymore!
      With version 1.0 of Ceylon we also released a completely rewritten &lt;code&gt;ceylon.test&lt;/code&gt; module.
      So let’s see what’s new and how we can use it now.&lt;/p&gt;
      
      &lt;h2&gt;Tests annotations&lt;/h2&gt;
      
      &lt;p&gt;Tests are now declaratively marked with the &lt;code&gt;test&lt;/code&gt; annotation
      and can be written as top-level functions or methods inside top-level class,
      in case you want to group multiple tests together.&lt;/p&gt;
      
      &lt;p&gt;Inside tests, assertions can be evaluated by using the language’s &lt;code&gt;assert&lt;/code&gt; statement
      or with the various &lt;em&gt;assert...&lt;/em&gt; functions, for example &lt;code&gt;assertEquals&lt;/code&gt;, &lt;code&gt;assertThatException&lt;/code&gt; etc.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class YodaTest() {
      
          test
          void shouldBeJedi() {
              assert(yoda is Jedi, 
                     yoda.midichloriansCount &amp;gt; 1k);
          }
      
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Common initialization logic, which is shared by several tests,
      can be placed into functions or methods and marked with the &lt;code&gt;beforeTest&lt;/code&gt; or &lt;code&gt;afterTest&lt;/code&gt; annotations.
      The test framework will invoke them automatically before or after each test in its scope.
      So top-level initialization functions will be invoked for each test in the same package,
      while initialization methods will be invoked for each test in the same class.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;class DeathStarTest() {
      
          beforeTest
          void init() =&amp;gt; station.chargeLasers();
      
          afterTest
          void dispose() =&amp;gt; station.shutdownSystems();
      
          ...
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Sometimes you want to temporarily disable a test or a group of tests.
      This can be done via the &lt;code&gt;ignore&lt;/code&gt; annotation.
      This way the test will not be executed, but will be covered in the summary tests result.
      Ignore annotation can be used on test functions/methods, or on classes which contains tests,
      or even on packages or modules.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;test
      ignore(&quot;still not implemented&quot;)
      void shouldBeFasterThanLight() {
      }
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;All these features are of course supported in our Ceylon IDE.
      Where you can create a &lt;em&gt;Ceylon Test Launch Configuration&lt;/em&gt;
      or easily select what you want to run in the &lt;em&gt;Ceylon Explorer&lt;/em&gt; and in context menu select &lt;em&gt;Run-As → Ceylon Test&lt;/em&gt;.&lt;/p&gt;
      
      &lt;p&gt;&lt;img src=&quot;https://ceylon-lang.org/images/screenshots/ceylon-test-plugin/test-result-view.png&quot; alt=&quot;test-result-view&quot;&gt;&lt;/p&gt;
      
      &lt;h2&gt;Test command&lt;/h2&gt;
      
      &lt;p&gt;Our command line toolset has been enhanced by the new &lt;code&gt;ceylon test&lt;/code&gt; command,
      which allows you to easily execute tests in specific modules.&lt;/p&gt;
      
      &lt;p&gt;The following command will execute every test in the &lt;code&gt;com.acme.foo/1.0.0&lt;/code&gt; module
      and will print a report about them to console.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang:bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ ceylon test com.acme.foo/1.0.0
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;You can execute specific tests with the &lt;code&gt;--test&lt;/code&gt; option,
      which takes a list of full-qualified declarations literals as values.
      The following examples show how to execute only the tests in a specified package, class or function.&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;!-- lang:bash --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;$ ceylon test --test='package com.acme.foo.bar' com.acme.foo/1.0.0
      $ ceylon test --test='class com.acme.foo.bar::Baz' com.acme.foo/1.0.0
      $ ceylon test --test='function com.acme.foo.bar::baz' com.acme.foo/1.0.0
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;More details about this command can be found
      &lt;a href=&quot;https://ceylon-lang.org/documentation/current/reference/tool/ceylon/subcommands/ceylon-test.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
      
      &lt;h2&gt;Next version&lt;/h2&gt;
      
      &lt;p&gt;In the next version, we will introduce other improvements.&lt;/p&gt;
      
      &lt;p&gt;There will be a test suite annotation, which allows you to combine several tests or test suites to run them together:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;testSuite({`class YodaTest`,
                 `class DarthVaderTest`,
                 `function starOfDeathTestSuite`})
      shared void starwarsTestSuite() {}
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;You will be able to declare custom test listeners, which will be notified during test execution:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;testListeners({`class DependencyInjectionTestListener`,
                     `class TransactionalTestListener`})
      package com.acme;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;And finally you will be able to specify custom implementation of the test executor, which is responsible for running tests:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;testExecutor(`class ArquillianTestExecutor`)
      package com.acme;
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;&lt;em&gt;Please note, that these APIs are not final yet, and can change.
      If you want to share your thoughts about it, don't hesitate and &lt;a href=&quot;https://ceylon-lang.org/community&quot;&gt;contact us&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2013/12/13/three-legged-elephants</id>
    <title>On three-legged elephants</title>
    <updated>2013-12-13T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2013/12/13/three-legged-elephants" rel="alternate" type="text/html" />
    <author>
      <name>Gavin King</name>
    </author>
    <summary>
      I've often argued that good design—of a language, library, or
      framework—isn't about packing in as many features as possible
      into your solution, rather it's about discovering a small set of
      interlocking features that act to reinforce each other. That is to
      say, we want to maximize the power/expressiveness of our solution,
      while simultaneously minimizing the surface area. I am, furthermore,
      quite often willing to sacrifice some flexibility for elegance.
      It's my view that elegant solutions are easier to learn, more
      enjoyable to use, and easier to abstract over.
      
      With this in mind, I would like to consider a problem that language
      designers have been working on for at least two...
    </summary>
    <content type="html">
      &lt;p&gt;I've often argued that good design—of a language, library, or
      framework—isn't about packing in as many features as possible
      into your solution, rather it's about discovering a small set of
      interlocking features that act to reinforce each other. That is to
      say, we want to maximize the power/expressiveness of our solution,
      while simultaneously minimizing the surface area. I am, furthermore,
      quite often willing to sacrifice some &lt;em&gt;flexibility&lt;/em&gt; for &lt;em&gt;elegance&lt;/em&gt;.
      It's my view that elegant solutions are easier to learn, more
      enjoyable to use, and easier to abstract over.&lt;/p&gt;
      
      &lt;p&gt;With this in mind, I would like to consider a problem that language
      designers have been working on for at least two decades: how to
      combine &lt;em&gt;subtype polymorphism&lt;/em&gt; with &lt;em&gt;parametric polymorphism&lt;/em&gt; (generics).
      This is a central problem faced by any object-oriented language with
      static typing. Recent languages have come progressively closer to a
      satisfying solution, but I would like to submit, if it doesn't sound
      too self-serving, that Ceylon offers the most satisfying solution so
      far.&lt;/p&gt;
      
      &lt;p&gt;Our mascot is Trompon the elephant, because an elephant has four
      legs and would fall over if one of his legs were missing. Ceylon's
      type system is exactly like this! (Yes, this is a baxplanation.)&lt;/p&gt;
      
      &lt;p&gt;The four legs of the type system are:&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;declaration site variance&lt;/li&gt;
      &lt;li&gt;ad hoc union and intersection types&lt;/li&gt;
      &lt;li&gt;type inference based on principal typing&lt;/li&gt;
      &lt;li&gt;covariant refinement and principal
      instantiation inheritance&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;If we were to take away any one of those four characteristics, all
      of a sudden stuff that Just Works would simply not work anymore, or,
      even if we could make it work, it would turn out way more complex,
      and involve reasoning that is difficult for the programmer to
      reproduce.&lt;/p&gt;
      
      &lt;p&gt;Consider this really simple line of code:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;value animals = ArrayList { Cat(), Dog(), Person() };
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;The inferred type of &lt;code&gt;animals&lt;/code&gt; is &lt;code&gt;ArrayList&amp;lt;Cat|Dog|Person&amp;gt;&lt;/code&gt;.&lt;/p&gt;
      
      &lt;ul&gt;
      &lt;li&gt;If we were to take away declaration site covariance, then &lt;code&gt;animals&lt;/code&gt;
      would not be assignable to &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;If we were to take away union and intersection types, then the
      process for inferring the type argument would be ambiguous and much
      more complex. (Ceylon's type argument inference algorithm is defined
      in two pages of pseudocode in the language specification, which sounds
      like a lot, until you realize how problematic and underspecified this
      algorithm is in other languages, and that the actual implementation
      of the algorithm is not much more longer.)&lt;/li&gt;
      &lt;li&gt;If we were to take away type inference, or principal typing, we would
      need to explicitly write down some uninteresting types in this line
      of code.&lt;/li&gt;
      &lt;/ul&gt;&lt;p&gt;Minus any one of these characteristics, we're left with a &lt;a href=&quot;http://www.telegraph.co.uk/earth/wildlife/4966620/Mosha-the-elephant-gets-prosthetic-leg.html&quot;&gt;three-legged
      elephant&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;Principal instantiation inheritance is a kind-of hidden feature of
      Ceylon that we don't talk about much, even though we use it extensively
      throughout the design of our container types. It lets us say, for example,
      that a &lt;code&gt;List&amp;lt;Element&amp;gt;&lt;/code&gt; is a &lt;code&gt;Ranged&amp;lt;List&amp;lt;Element&amp;gt;&amp;gt;&lt;/code&gt;, and that a
      &lt;code&gt;Sequence&amp;lt;Element&amp;gt;&lt;/code&gt; is a  &lt;code&gt;List&amp;lt;Element&amp;gt;&amp;amp;Ranged&amp;lt;Sequence&amp;lt;Element&amp;gt;&amp;gt;&lt;/code&gt;.
      Principal instantiation inheritance meshes really nicely with
      declaration-site covariance, and with ad hoc union/intersection types.
      Consider the following code:&lt;/p&gt;
      
      &lt;!-- try: --&gt;
      
      
      &lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt;|Integer[] ranged = ... ;
      value span = ranged.span(0,max); 
      &lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;Here, the inferred type of &lt;code&gt;span&lt;/code&gt; is &lt;code&gt;List&amp;lt;String&amp;gt;|Integer[]&lt;/code&gt;. Isn't
      that nice? The typechecker has reasoned that the &lt;em&gt;principal supertype
      instantiation&lt;/em&gt; of &lt;code&gt;Ranged&lt;/code&gt; for &lt;code&gt;List&amp;lt;String&amp;gt;|Integer[]&lt;/code&gt; is the type
      &lt;code&gt;Ranged&amp;lt;List&amp;lt;String&amp;gt;|Integer[]&amp;gt;&lt;/code&gt;, and thereby determined the perfect
      return type for &lt;code&gt;span()&lt;/code&gt;.&lt;/p&gt;
      
      &lt;p&gt;If we were to take away any one of declaration site covariance,
      principal instantiation inheritance, or union types, then this
      reasoning would no longer be sound. The elephant would fall on his
      ass.&lt;/p&gt;
    </content>
  </entry>
  <entry>
    <id>https://ceylon-lang.org/blog/2013/12/12/ceylon-tour-comes-to-paris</id>
    <title>Ceylon Tour comes to Paris</title>
    <updated>2013-12-12T00:00:00+00:00</updated>
    <link href="https://ceylon-lang.org/blog/2013/12/12/ceylon-tour-comes-to-paris" rel="alternate" type="text/html" />
    <author>
      <name>St&#233;phane &#201;pardaud</name>
    </author>
    <summary>
      A Ceylon conference in Paris in January 2014
      
      We have so many exciting things to talk about in the Ceylon ecosystem that it's impossible for everyone
      to keep track of everything that is happening, but if you live in Paris or not too far from it, we can
      help you, because we will organise our first Ceylon Tour conference in Paris in January 2014.
      
      
      
      The whole Ceylon team will be there, there will be many short talks, discussions and a workshop. The
      conference is free, but availability is limited so we advise you to reserve your ticket as soon as
      possible, but only if you're sure...
    </summary>
    <content type="html">
      &lt;h1&gt;A Ceylon conference in Paris in January 2014&lt;/h1&gt;
      
      &lt;p&gt;We have so many exciting things to talk about in the Ceylon ecosystem that it's impossible for everyone
      to keep track of everything that is happening, but if you live in Paris or not too far from it, we can
      help you, because we will organise our first Ceylon Tour conference in Paris in January 2014.&lt;/p&gt;
      
      &lt;p&gt;&lt;a href=&quot;https://ceylon-lang.org/community/conferences/ceylon-tour-paris-2014&quot;&gt;&lt;img src=&quot;https://ceylon-lang.org/images/ceylon-tour-paris-2014.png&quot; alt=&quot;Ceylon Tour Paris 2014 logo&quot;&gt;&lt;/a&gt;&lt;/p&gt;
      
      &lt;p&gt;The whole Ceylon team will be there, there will be many short talks, discussions and a workshop. The
      conference is free, but availability is limited so we advise you to reserve your ticket as soon as
      possible, but only if you're sure to come (it wouldn't be fair to others to reserve a ticket and not come).&lt;/p&gt;
      
      &lt;p&gt;Registration, as well as all the info about this conference is detailed on the
      &lt;a href=&quot;https://ceylon-lang.org/community/conferences/ceylon-tour-paris-2014&quot;&gt;conference page&lt;/a&gt;.&lt;/p&gt;
      
      &lt;p&gt;If you live near Paris, any excuse is good to visit Paris, especially a free Ceylon conference :)&lt;/p&gt;
      
      &lt;p&gt;If you don't live near Paris, hopefully this is only the start and we will visit your country soon!&lt;/p&gt;
    </content>
  </entry>
</feed>
